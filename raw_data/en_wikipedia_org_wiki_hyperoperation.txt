Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Definition Toggle Definition subsection 1.1 Definition, most common 1.2 Definition, using iteration 2 Computation Toggle Computation subsection 2.1 TRS based on definition sub 1.1 2.2 TRS based on definition sub 1.2 3 Examples 4 Special cases 5 History 6 Notations Toggle Notations subsection 6.1 Variant starting from a 6.2 Variant starting from 0 6.3 Lower hyperoperations 6.4 Commutative hyperoperations 7 Numeration systems based on the hyperoperation sequence 8 See also 9 Notes 10 References 11 Bibliography Toggle the table of contents Hyperoperation 18 languages Català Dansk Deutsch Español Esperanto Français Galego 한국어 עברית 日本語 Português Русский Simple English Slovenščina Türkçe Українська Tiếng Việt 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikifunctions Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Generalization of addition, multiplication, exponentiation, tetration, etc.

This article is about the arithmetic concept. For the group theory hyperoperation concept, see Hyperstructure .

In mathematics , the hyperoperation sequence [ nb 1 ] is an infinite sequence of arithmetic operations (called hyperoperations in this context) [ 1 ] [ 11 ] [ 13 ] that starts with a unary operation (the successor function with n = 0). The sequence continues with the binary operations of addition ( n = 1), multiplication ( n = 2), and exponentiation ( n = 3).

After that, the sequence proceeds with further binary operations extending beyond exponentiation, using right-associativity .  For the operations beyond exponentiation, the n th member of this sequence is named by Reuben Goodstein after the Greek prefix of n suffixed with -ation (such as tetration ( n = 4), pentation ( n = 5), hexation ( n = 6), etc.) [ 5 ] and can be written using n − 2 arrows in Knuth's up-arrow notation .
Each hyperoperation may be understood recursively in terms of the previous one by: a [ n ] b = a [ n − − 1 ] ( a [ n − − 1 ] ( a [ n − − 1 ] ( ⋯ ⋯ a [ n − − 1 ] ( a [ n − − 1 ] ( a [ n − − 1 ] a ) ) ⋯ ⋯ ) ) ) ⏟ ⏟ b copies of a , n ≥ ≥ 2 {\displaystyle a[n]b=\underbrace {a[n-1](a[n-1](a[n-1](\cdots a[n-1](a[n-1](a[n-1]a))\cdots )))} _{\displaystyle b{\mbox{ copies of }}a},\quad n\geq 2} It may also be defined according to the recursion rule part of the definition, as in Knuth's up-arrow version of the Ackermann function : a [ n ] b = a [ n − − 1 ] ( a [ n ] ( b − − 1 ) ) , n ≥ ≥ 1 {\displaystyle a[n]b=a[n-1]\left(a[n]\left(b-1\right)\right),\quad n\geq 1} This can be used to easily show numbers much larger than those which scientific notation can, such as Skewes's number and googolplexplex (e.g.

50 [ 50 ] 50 {\displaystyle 50[50]50} is much larger than Skewes's number and googolplexplex), but there are some numbers which even they cannot easily show, such as Graham's number and TREE(3) .

[ 14 ] This recursion rule is common to many variants of hyperoperations.

Definition [ edit ] Definition, most common [ edit ] The hyperoperation sequence H n ( a , b ) : : ( N 0 ) 3 → → N 0 {\displaystyle H_{n}(a,b)\colon (\mathbb {N} _{0})^{3}\rightarrow \mathbb {N} _{0}} is the sequence of binary operations H n : : ( N 0 ) 2 → → N 0 {\displaystyle H_{n}\colon (\mathbb {N} _{0})^{2}\rightarrow \mathbb {N} _{0}} , defined recursively as follows: H n ( a , b ) = a [ n ] b = { b + 1 if n = 0 a if n = 1 and b = 0 0 if n = 2 and b = 0 1 if n ≥ ≥ 3 and b = 0 H n − − 1 ( a , H n ( a , b − − 1 ) ) otherwise {\displaystyle H_{n}(a,b)=a[n]b={\begin{cases}b+1&{\text{if }}n=0\\a&{\text{if }}n=1{\text{ and }}b=0\\0&{\text{if }}n=2{\text{ and }}b=0\\1&{\text{if }}n\geq 3{\text{ and }}b=0\\H_{n-1}(a,H_{n}(a,b-1))&{\text{otherwise}}\end{cases}}} (Note that for n = 0, the binary operation essentially reduces to a unary operation ( successor function ) by ignoring the first argument.) For n = 0, 1, 2, 3, this definition reproduces the basic arithmetic operations of successor (which is a unary operation), addition , multiplication , and exponentiation , respectively, as H 0 ( a , b ) = b + 1 , H 1 ( a , b ) = a + b , H 2 ( a , b ) = a × × b , H 3 ( a , b ) = a ↑ ↑ b = a b .

{\displaystyle {\begin{aligned}H_{0}(a,b)&=b+1,\\H_{1}(a,b)&=a+b,\\H_{2}(a,b)&=a\times b,\\H_{3}(a,b)&=a\uparrow {b}=a^{b}.\end{aligned}}} The H n {\displaystyle H_{n}} operations for n ≥ 3 can be written in Knuth's up-arrow notation .

So what will be the next operation after exponentiation? We defined multiplication so that H 2 ( a , 3 ) = a [ 2 ] 3 = a × × 3 = a + a + a , {\displaystyle H_{2}(a,3)=a[2]3=a\times 3=a+a+a,} and defined exponentiation so that H 3 ( a , 3 ) = a [ 3 ] 3 = a ↑ ↑ 3 = a 3 = a × × a × × a , {\displaystyle H_{3}(a,3)=a[3]3=a\uparrow 3=a^{3}=a\times a\times a,} so it seems logical to define the next operation, tetration, so that H 4 ( a , 3 ) = a [ 4 ] 3 = a ↑ ↑ ↑ ↑ 3 = tetration ⁡ ⁡ ( a , 3 ) = a a a , {\displaystyle H_{4}(a,3)=a[4]3=a\uparrow \uparrow 3=\operatorname {tetration} (a,3)=a^{a^{a}},} with a tower of three 'a'. Analogously, the pentation of (a, 3) will be tetration(a, tetration(a, a)), with three "a" in it.

H 4 ( a , b ) = a ↑ ↑ ↑ ↑ b , H 5 ( a , b ) = a ↑ ↑ ↑ ↑ ↑ ↑ b , … … H n ( a , b ) = a ↑ ↑ n − − 2 b for n ≥ ≥ 3 , … … {\displaystyle {\begin{aligned}H_{4}(a,b)&=a\uparrow \uparrow {b},\\H_{5}(a,b)&=a\uparrow \uparrow \uparrow {b},\\\ldots &\\H_{n}(a,b)&=a\uparrow ^{n-2}b{\text{ for }}n\geq 3,\\\ldots &\\\end{aligned}}} Knuth's notation could be extended to negative indices ≥ −2 in such a way as to agree with the entire hyperoperation sequence, except for the lag in the indexing: H n ( a , b ) = a ↑ ↑ n − − 2 b for n ≥ ≥ 0.

{\displaystyle H_{n}(a,b)=a\uparrow ^{n-2}b{\text{ for }}n\geq 0.} The hyperoperations can thus be seen as an answer to the question "what's next" in the sequence : successor , addition , multiplication , exponentiation , and so on. Noting that a + b = ( a + ( b − − 1 ) ) + 1 a ⋅ ⋅ b = a + ( a ⋅ ⋅ ( b − − 1 ) ) a b = a ⋅ ⋅ ( a ( b − − 1 ) ) a [ 4 ] b = a a [ 4 ] ( b − − 1 ) {\displaystyle {\begin{aligned}a+b&=(a+(b-1))+1\\a\cdot b&=a+(a\cdot (b-1))\\a^{b}&=a\cdot \left(a^{(b-1)}\right)\\a[4]b&=a^{a[4](b-1)}\end{aligned}}} the relationship between basic arithmetic operations is illustrated, allowing the higher operations to be defined naturally as above.  The parameters of the hyperoperation hierarchy are sometimes referred to by their analogous exponentiation term; [ 15 ] so a is the base , b is the exponent (or hyperexponent ), [ 12 ] and n is the rank (or grade ), [ 6 ] and moreover, H n ( a , b ) {\displaystyle H_{n}(a,b)} is read as "the b th n -ation of a ", e.g.

H 4 ( 7 , 9 ) {\displaystyle H_{4}(7,9)} is read as "the 9th tetration of 7", and H 123 ( 456 , 789 ) {\displaystyle H_{123}(456,789)} is read as "the 789th 123-ation of 456".

In common terms, the hyperoperations are ways of compounding numbers that increase in growth based on the iteration of the previous hyperoperation. The concepts of successor, addition, multiplication and exponentiation are all hyperoperations; the successor operation (producing x + 1 from x ) is the most primitive, the addition operator specifies the number of times 1 is to be added to itself to produce a final value, multiplication specifies the number of times a number is to be added to itself, and exponentiation refers to the number of times a number is to be multiplied by itself.

Definition, using iteration [ edit ] Define iteration of a function f of two variables as f x ( a , b ) = { f ( a , b ) if x = 1 f ( a , f x − − 1 ( a , b ) ) if x > 1 {\displaystyle f^{x}(a,b)={\begin{cases}f(a,b)&{\text{if }}x=1\\f(a,f^{x-1}(a,b))&{\text{if }}x>1\end{cases}}} The hyperoperation sequence can be defined in terms of iteration, as follows.  For all integers x , n , a , b ≥ ≥ 0 , {\displaystyle x,n,a,b\geq 0,} define H 0 ( a , b ) = b + 1 H 1 ( a , 0 ) = a H 2 ( a , 0 ) = 0 H n + 3 ( a , 0 ) = 1 H n + 1 ( a , b + 1 ) = H n b + 1 ( a , H n + 1 ( a , 0 ) ) H n x + 2 ( a , b ) = H n ( a , H n x + 1 ( a , b ) ) {\displaystyle {\begin{array}{lcl}H_{0}(a,b)&=&b+1\\H_{1}(a,0)&=&a\\H_{2}(a,0)&=&0\\H_{n+3}(a,0)&=&1\\H_{n+1}(a,b+1)&=&H_{n}^{b+1}(a,H_{n+1}(a,0))\\H_{n}^{x+2}(a,b)&=&H_{n}(a,H_{n}^{x+1}(a,b))\end{array}}} As iteration is associative , the last line can be replaced by H n x + 2 ( a , b ) = H n x + 1 ( a , H n ( a , b ) ) {\displaystyle {\begin{array}{lcl}H_{n}^{x+2}(a,b)&=&H_{n}^{x+1}(a,H_{n}(a,b))\end{array}}} Computation [ edit ] The definitions of the hyperoperation sequence can naturally be transposed to term rewriting systems (TRS) .

TRS based on definition sub 1.1 [ edit ] The basic definition of the hyperoperation sequence corresponds with the reduction rules (r1) H ( 0 , a , b ) → → S ( b ) (r2) H ( S ( 0 ) , a , 0 ) → → a (r3) H ( S ( S ( 0 ) ) , a , 0 ) → → 0 (r4) H ( S ( S ( S ( n ) ) ) , a , 0 ) → → S ( 0 ) (r5) H ( S ( n ) , a , S ( b ) ) → → H ( n , a , H ( S ( n ) , a , b ) ) {\displaystyle {\begin{array}{lll}{\text{(r1)}}&H(0,a,b)&\rightarrow &S(b)\\{\text{(r2)}}&H(S(0),a,0)&\rightarrow &a\\{\text{(r3)}}&H(S(S(0)),a,0)&\rightarrow &0\\{\text{(r4)}}&H(S(S(S(n))),a,0)&\rightarrow &S(0)\\{\text{(r5)}}&H(S(n),a,S(b))&\rightarrow &H(n,a,H(S(n),a,b))\end{array}}} To compute H n ( a , b ) {\displaystyle H_{n}(a,b)} one can use a stack , which initially contains the elements ⟨ ⟨ n , a , b ⟩ ⟩ {\displaystyle \langle n,a,b\rangle } .

Then, repeatedly until no longer possible, three elements are popped and replaced according to the rules [ nb 2 ] (r1) 0 , a , b → → ( b + 1 ) (r2) 1 , a , 0 → → a (r3) 2 , a , 0 → → 0 (r4) ( n + 3 ) , a , 0 → → 1 (r5) ( n + 1 ) , a , ( b + 1 ) → → n , a , ( n + 1 ) , a , b {\displaystyle {\begin{array}{lllllllll}{\text{(r1)}}&0&,&a&,&b&\rightarrow &(b+1)\\{\text{(r2)}}&1&,&a&,&0&\rightarrow &a\\{\text{(r3)}}&2&,&a&,&0&\rightarrow &0\\{\text{(r4)}}&(n+3)&,&a&,&0&\rightarrow &1\\{\text{(r5)}}&(n+1)&,&a&,&(b+1)&\rightarrow &n&,&a&,&(n+1)&,&a&,&b\end{array}}} Schematically, starting from ⟨ ⟨ n , a , b ⟩ ⟩ {\displaystyle \langle n,a,b\rangle } : WHILE stackLength <> 1
{ POP 3 elements; PUSH 1 or 5 elements according to the rules r1, r2, r3, r4, r5;
} Example Compute H 2 ( 2 , 2 ) → → ∗ ∗ 4 {\displaystyle H_{2}(2,2)\rightarrow _{*}4} .

[ 16 ] The reduction sequence is [ nb 2 ] [ 17 ] H ( S ( S ( 0 ) ) , S ( S ( 0 ) ) , S ( S ( 0 ) ) ) _ _ {\displaystyle {\underline {H(S(S(0)),S(S(0)),S(S(0)))}}} → → r 5 H ( S ( 0 ) , S ( S ( 0 ) ) , H ( S ( S ( 0 ) ) , S ( S ( 0 ) ) , S ( 0 ) ) _ _ ) {\displaystyle \rightarrow _{r5}H(S(0),S(S(0)),{\underline {H(S(S(0)),S(S(0)),S(0))}})} → → r 5 H ( S ( 0 ) , S ( S ( 0 ) ) , H ( S ( 0 ) , S ( S ( 0 ) ) , H ( S ( S ( 0 ) ) , S ( S ( 0 ) ) , 0 ) _ _ ) ) {\displaystyle \rightarrow _{r5}H(S(0),S(S(0)),H(S(0),S(S(0)),{\underline {H(S(S(0)),S(S(0)),0)}}))} → → r 3 H ( S ( 0 ) , S ( S ( 0 ) ) , H ( S ( 0 ) , S ( S ( 0 ) ) , 0 ) _ _ ) {\displaystyle \rightarrow _{r3}H(S(0),S(S(0)),{\underline {H(S(0),S(S(0)),0)}})} → → r 2 H ( S ( 0 ) , S ( S ( 0 ) ) , S ( S ( 0 ) ) ) _ _ {\displaystyle \rightarrow _{r2}{\underline {H(S(0),S(S(0)),S(S(0)))}}} → → r 5 H ( 0 , S ( S ( 0 ) ) , H ( S ( 0 ) , S ( S ( 0 ) ) , S ( 0 ) ) _ _ ) {\displaystyle \rightarrow _{r5}H(0,S(S(0)),{\underline {H(S(0),S(S(0)),S(0))}})} → → r 5 H ( 0 , S ( S ( 0 ) ) , H ( 0 , S ( S ( 0 ) ) , H ( S ( 0 ) , S ( S ( 0 ) ) , 0 ) _ _ ) ) {\displaystyle \rightarrow _{r5}H(0,S(S(0)),H(0,S(S(0)),{\underline {H(S(0),S(S(0)),0)}}))} → → r 2 H ( 0 , S ( S ( 0 ) ) , H ( 0 , S ( S ( 0 ) ) , S ( S ( 0 ) ) ) _ _ ) {\displaystyle \rightarrow _{r2}H(0,S(S(0)),{\underline {H(0,S(S(0)),S(S(0)))}})} → → r 1 H ( 0 , S ( S ( 0 ) ) , S ( S ( S ( 0 ) ) ) ) _ _ {\displaystyle \rightarrow _{r1}{\underline {H(0,S(S(0)),S(S(S(0))))}}} → → r 1 S ( S ( S ( S ( 0 ) ) ) ) {\displaystyle \rightarrow _{r1}S(S(S(S(0))))} When implemented using a stack, on input ⟨ ⟨ 2 , 2 , 2 ⟩ ⟩ {\displaystyle \langle 2,2,2\rangle } the stack configurations represent the equations 2 , 2 , 2 _ _ {\displaystyle {\underline {2,2,2}}} H 2 ( 2 , 2 ) {\displaystyle H_{2}(2,2)} → → r 5 1 , 2 , 2 , 2 , 1 _ _ {\displaystyle \rightarrow _{r5}1,2,{\underline {2,2,1}}} = H 1 ( 2 , H 2 ( 2 , 1 ) ) {\displaystyle =H_{1}(2,H_{2}(2,1))} → → r 5 1 , 2 , 1 , 2 , 2 , 2 , 0 _ _ {\displaystyle \rightarrow _{r5}1,2,1,2,{\underline {2,2,0}}} = H 1 ( 2 , H 1 ( 2 , H 2 ( 2 , 0 ) ) ) {\displaystyle =H_{1}(2,H_{1}(2,H_{2}(2,0)))} → → r 3 1 , 2 , 1 , 2 , 0 _ _ {\displaystyle \rightarrow _{r3}1,2,{\underline {1,2,0}}} = H 1 ( 2 , H 1 ( 2 , 0 ) ) {\displaystyle =H_{1}(2,H_{1}(2,0))} → → r 2 1 , 2 , 2 _ _ {\displaystyle \rightarrow _{r2}{\underline {1,2,2}}} = H 1 ( 2 , 2 ) {\displaystyle =H_{1}(2,2)} → → r 5 0 , 2 , 1 , 2 , 1 _ _ {\displaystyle \rightarrow _{r5}0,2,{\underline {1,2,1}}} = H 0 ( 2 , H 1 ( 2 , 1 ) ) {\displaystyle =H_{0}(2,H_{1}(2,1))} → → r 5 0 , 2 , 0 , 2 , 1 , 2 , 0 _ _ {\displaystyle \rightarrow _{r5}0,2,0,2,{\underline {1,2,0}}} = H 0 ( 2 , H 0 ( 2 , H 1 ( 2 , 0 ) ) ) {\displaystyle =H_{0}(2,H_{0}(2,H_{1}(2,0)))} → → r 2 0 , 2 , 0 , 2 , 2 _ _ {\displaystyle \rightarrow _{r2}0,2,{\underline {0,2,2}}} = H 0 ( 2 , H 0 ( 2 , 2 ) ) {\displaystyle =H_{0}(2,H_{0}(2,2))} → → r 1 0 , 2 , 3 _ _ {\displaystyle \rightarrow _{r1}{\underline {0,2,3}}} = H 0 ( 2 , 3 ) {\displaystyle =H_{0}(2,3)} → → r 1 4 {\displaystyle \rightarrow _{r1}4} = 4 {\displaystyle =4} TRS based on definition sub 1.2 [ edit ] The definition using iteration leads to a different set of reduction rules (r6) H ( S ( 0 ) , 0 , a , b ) → → S ( b ) (r7) H ( S ( 0 ) , S ( 0 ) , a , 0 ) → → a (r8) H ( S ( 0 ) , S ( S ( 0 ) ) , a , 0 ) → → 0 (r9) H ( S ( 0 ) , S ( S ( S ( n ) ) ) , a , 0 ) → → S ( 0 ) (r10) H ( S ( 0 ) , S ( n ) , a , S ( b ) ) → → H ( S ( b ) , n , a , H ( S ( 0 ) , S ( n ) , a , 0 ) ) (r11) H ( S ( S ( x ) ) , n , a , b ) → → H ( S ( 0 ) , n , a , H ( S ( x ) , n , a , b ) ) {\displaystyle {\begin{array}{lll}{\text{(r6)}}&H(S(0),0,a,b)&\rightarrow &S(b)\\{\text{(r7)}}&H(S(0),S(0),a,0)&\rightarrow &a\\{\text{(r8)}}&H(S(0),S(S(0)),a,0)&\rightarrow &0\\{\text{(r9)}}&H(S(0),S(S(S(n))),a,0)&\rightarrow &S(0)\\{\text{(r10)}}&H(S(0),S(n),a,S(b))&\rightarrow &H(S(b),n,a,H(S(0),S(n),a,0))\\{\text{(r11)}}&H(S(S(x)),n,a,b)&\rightarrow &H(S(0),n,a,H(S(x),n,a,b))\end{array}}} As iteration is associative , instead of rule r11 one can define (r12) H ( S ( S ( x ) ) , n , a , b ) → → H ( S ( x ) , n , a , H ( S ( 0 ) , n , a , b ) ) {\displaystyle {\begin{array}{lll}{\text{(r12)}}&H(S(S(x)),n,a,b)&\rightarrow &H(S(x),n,a,H(S(0),n,a,b))\end{array}}} Like in the previous section the computation of H n ( a , b ) = H n 1 ( a , b ) {\displaystyle H_{n}(a,b)=H_{n}^{1}(a,b)} can be implemented using a stack.

Initially the stack contains the four elements ⟨ ⟨ 1 , n , a , b ⟩ ⟩ {\displaystyle \langle 1,n,a,b\rangle } .

Then, until termination, four elements are popped and replaced according to the rules [ nb 2 ] (r6) 1 , 0 , a , b → → ( b + 1 ) (r7) 1 , 1 , a , 0 → → a (r8) 1 , 2 , a , 0 → → 0 (r9) 1 , ( n + 3 ) , a , 0 → → 1 (r10) 1 , ( n + 1 ) , a , ( b + 1 ) → → ( b + 1 ) , n , a , 1 , ( n + 1 ) , a , 0 (r11) ( x + 2 ) , n , a , b → → 1 , n , a , ( x + 1 ) , n , a , b {\displaystyle {\begin{array}{lllllllll}{\text{(r6)}}&1&,0&,a&,b&\rightarrow &(b+1)\\{\text{(r7)}}&1&,1&,a&,0&\rightarrow &a\\{\text{(r8)}}&1&,2&,a&,0&\rightarrow &0\\{\text{(r9)}}&1&,(n+3)&,a&,0&\rightarrow &1\\{\text{(r10)}}&1&,(n+1)&,a&,(b+1)&\rightarrow &(b+1)&,n&,a&,1&,(n+1)&,a&,0\\{\text{(r11)}}&(x+2)&,n&,a&,b&\rightarrow &1&,n&,a&,(x+1)&,n&,a&,b\end{array}}} Schematically, starting from ⟨ ⟨ 1 , n , a , b ⟩ ⟩ {\displaystyle \langle 1,n,a,b\rangle } : WHILE stackLength <> 1
{ POP 4 elements; PUSH 1 or 7 elements according to the rules r6, r7, r8, r9, r10, r11;
} Example Compute H 3 ( 0 , 3 ) → → ∗ ∗ 0 {\displaystyle H_{3}(0,3)\rightarrow _{*}0} .

On input ⟨ ⟨ 1 , 3 , 0 , 3 ⟩ ⟩ {\displaystyle \langle 1,3,0,3\rangle } the successive stack configurations are 1 , 3 , 0 , 3 _ _ → → r 10 3 , 2 , 0 , 1 , 3 , 0 , 0 _ _ → → r 9 3 , 2 , 0 , 1 _ _ → → r 11 1 , 2 , 0 , 2 , 2 , 0 , 1 _ _ → → r 11 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 _ _ → → r 10 1 , 2 , 0 , 1 , 2 , 0 , 1 , 1 , 0 , 1 , 2 , 0 , 0 _ _ → → r 8 1 , 2 , 0 , 1 , 2 , 0 , 1 , 1 , 0 , 0 _ _ → → r 7 1 , 2 , 0 , 1 , 2 , 0 , 0 _ _ → → r 8 1 , 2 , 0 , 0 _ _ → → r 8 0.

{\displaystyle {\begin{aligned}&{\underline {1,3,0,3}}\rightarrow _{r10}3,2,0,{\underline {1,3,0,0}}\rightarrow _{r9}{\underline {3,2,0,1}}\rightarrow _{r11}1,2,0,{\underline {2,2,0,1}}\rightarrow _{r11}1,2,0,1,2,0,{\underline {1,2,0,1}}\\&\rightarrow _{r10}1,2,0,1,2,0,1,1,0,{\underline {1,2,0,0}}\rightarrow _{r8}1,2,0,1,2,0,{\underline {1,1,0,0}}\rightarrow _{r7}1,2,0,{\underline {1,2,0,0}}\rightarrow _{r8}{\underline {1,2,0,0}}\rightarrow _{r8}0.\end{aligned}}} The corresponding equalities are H 3 ( 0 , 3 ) = H 2 3 ( 0 , H 3 ( 0 , 0 ) ) = H 2 3 ( 0 , 1 ) = H 2 ( 0 , H 2 2 ( 0 , 1 ) ) = H 2 ( 0 , H 2 ( 0 , H 2 ( 0 , 1 ) ) = H 2 ( 0 , H 2 ( 0 , H 1 ( 0 , H 2 ( 0 , 0 ) ) ) ) = H 2 ( 0 , H 2 ( 0 , H 1 ( 0 , 0 ) ) ) = H 2 ( 0 , H 2 ( 0 , 0 ) ) = H 2 ( 0 , 0 ) = 0.

{\displaystyle {\begin{aligned}&H_{3}(0,3)=H_{2}^{3}(0,H_{3}(0,0))=H_{2}^{3}(0,1)=H_{2}(0,H_{2}^{2}(0,1))=H_{2}(0,H_{2}(0,H_{2}(0,1))\\&=H_{2}(0,H_{2}(0,H_{1}(0,H_{2}(0,0))))=H_{2}(0,H_{2}(0,H_{1}(0,0)))=H_{2}(0,H_{2}(0,0))=H_{2}(0,0)=0.\end{aligned}}} When reduction rule r11 is replaced by rule r12, the stack is transformed according to (r12) ( x + 2 ) , n , a , b → → ( x + 1 ) , n , a , 1 , n , a , b {\displaystyle {\begin{array}{lllllllll}{\text{(r12)}}&(x+2)&,n&,a&,b&\rightarrow &(x+1)&,n&,a&,1&,n&,a&,b\end{array}}} The successive stack configurations will then be 1 , 3 , 0 , 3 _ _ → → r 10 3 , 2 , 0 , 1 , 3 , 0 , 0 _ _ → → r 9 3 , 2 , 0 , 1 _ _ → → r 12 2 , 2 , 0 , 1 , 2 , 0 , 1 _ _ → → r 10 2 , 2 , 0 , 1 , 1 , 0 , 1 , 2 , 0 , 0 _ _ → → r 8 2 , 2 , 0 , 1 , 1 , 0 , 0 _ _ → → r 7 2 , 2 , 0 , 0 _ _ → → r 12 1 , 2 , 0 , 1 , 2 , 0 , 0 _ _ → → r 8 1 , 2 , 0 , 0 _ _ → → r 8 0 {\displaystyle {\begin{aligned}&{\underline {1,3,0,3}}\rightarrow _{r10}3,2,0,{\underline {1,3,0,0}}\rightarrow _{r9}{\underline {3,2,0,1}}\rightarrow _{r12}2,2,0,{\underline {1,2,0,1}}\rightarrow _{r10}2,2,0,1,1,0,{\underline {1,2,0,0}}\\&\rightarrow _{r8}2,2,0,{\underline {1,1,0,0}}\rightarrow _{r7}{\underline {2,2,0,0}}\rightarrow _{r12}1,2,0,{\underline {1,2,0,0}}\rightarrow _{r8}{\underline {1,2,0,0}}\rightarrow _{r8}0\end{aligned}}} The corresponding equalities are H 3 ( 0 , 3 ) = H 2 3 ( 0 , H 3 ( 0 , 0 ) ) = H 2 3 ( 0 , 1 ) = H 2 2 ( 0 , H 2 ( 0 , 1 ) ) = H 2 2 ( 0 , H 1 ( 0 , H 2 ( 0 , 0 ) ) ) = H 2 2 ( 0 , H 1 ( 0 , 0 ) ) = H 2 2 ( 0 , 0 ) = H 2 ( 0 , H 2 ( 0 , 0 ) ) = H 2 ( 0 , 0 ) = 0 {\displaystyle {\begin{aligned}&H_{3}(0,3)=H_{2}^{3}(0,H_{3}(0,0))=H_{2}^{3}(0,1)=H_{2}^{2}(0,H_{2}(0,1))=H_{2}^{2}(0,H_{1}(0,H_{2}(0,0)))\\&=H_{2}^{2}(0,H_{1}(0,0))=H_{2}^{2}(0,0)=H_{2}(0,H_{2}(0,0))=H_{2}(0,0)=0\end{aligned}}} Remarks H 3 ( 0 , 3 ) = 0 {\displaystyle H_{3}(0,3)=0} is a special case. See below.

[ nb 3 ] [ nb 4 ] The computation of H n ( a , b ) {\displaystyle H_{n}(a,b)} according to the rules {r6 - r10, r11} is heavily recursive. The culprit is the order in which iteration is executed: H n ( a , b ) = H ( a , H n − − 1 ( a , b ) ) {\displaystyle H^{n}(a,b)=H(a,H^{n-1}(a,b))} . The first H {\displaystyle H} disappears only after the whole sequence is unfolded. For instance, H 4 ( 2 , 4 ) {\displaystyle H_{4}(2,4)} converges  to 65536 in 2863311767 steps, the maximum depth of recursion [ 18 ] is 65534.

The computation according to the rules {r6 - r10, r12} is more efficient in that respect. The implementation of iteration H n ( a , b ) {\displaystyle H^{n}(a,b)} as H n − − 1 ( a , H ( a , b ) ) {\displaystyle H^{n-1}(a,H(a,b))} mimics the repeated execution of a procedure H.

[ 19 ] The depth of recursion, (n+1), matches the loop nesting.

Meyer & Ritchie (1967) formalized this correspondence. The computation of H 4 ( 2 , 4 ) {\displaystyle H_{4}(2,4)} according to the rules {r6-r10, r12} also needs 2863311767 steps to converge on 65536, but the maximum depth of recursion is only 5, as tetration is the 5th operator in the hyperoperation sequence.

The considerations above concern the recursion depth only. Either way of iterating leads to the same number of reduction steps, involving the same rules (when the rules r11 and r12 are considered "the same"). As the example shows the reduction of H 3 ( 0 , 3 ) {\displaystyle H_{3}(0,3)} converges in 9 steps: 1 X r7, 3 X r8, 1 X r9, 2 X r10, 2 X r11/r12. The modus iterandi only affects the order in which the reduction rules are applied.

Examples [ edit ] Below is a list of the first seven (0th to 6th) hyperoperations ( 0⁰ is defined as 1).

n Operation, H n ( a , b ) Definition Names Domain 0 b + 1 {\displaystyle b+1} or a [ 0 ] b {\displaystyle a[0]b} 1 + 1 + 1 + ⋯ ⋯ + 1 + 1 + 1 ⏟ ⏟ b copies of 1 + 1 {\displaystyle \underbrace {1+1+1+\cdots +1+1+1} _{\displaystyle b{\mbox{ copies of 1}}}+1} Increment, successor , zeration, hyper0 Arbitrary 1 a + b {\displaystyle a+b} or a [ 1 ] b {\displaystyle a[1]b} a + 1 + 1 + 1 + ⋯ ⋯ + 1 + 1 + 1 ⏟ ⏟ b copies of 1 {\displaystyle a+\underbrace {1+1+1+\cdots +1+1+1} _{\displaystyle b{\mbox{ copies of 1}}}} Addition , hyper1 2 a × × b {\displaystyle a\times {b}} or a [ 2 ] b {\displaystyle a[2]b} a + a + a + ⋯ ⋯ + a + a + a ⏟ ⏟ b copies of a {\displaystyle \underbrace {a+a+a+\cdots +a+a+a} _{\displaystyle b{\mbox{ copies of }}a}} Multiplication , hyper2 3 a b {\displaystyle a^{b}} or a [ 3 ] b {\displaystyle a[3]b} a × × a × × a × × ⋯ ⋯ × × a × × a × × a ⏟ ⏟ b copies of a {\displaystyle \underbrace {a\times a\times a\times \;\cdots \;\times a\times a\times a} _{\displaystyle b{\mbox{ copies of }}a}} Exponentiation , hyper3 b real, with some multivalued extensions to complex numbers 4 b a {\displaystyle ^{b}a} or a [ 4 ] b {\displaystyle a[4]b} a [ 3 ] ( a [ 3 ] ( a [ 3 ] ( ⋯ ⋯ [ 3 ] ( a [ 3 ] ( a [ 3 ] a ) ) ⋯ ⋯ ) ) ) ⏟ ⏟ b copies of a {\displaystyle \underbrace {a[3](a[3](a[3](\cdots [3](a[3](a[3]a))\cdots )))} _{\displaystyle b{\mbox{ copies of }}a}} Tetration , hyper4 a ≥ 0 or an integer, b an integer ≥ −1 [ nb 5 ] (with some proposed extensions) 5 b a {\displaystyle _{b}a} or a [ 5 ] b {\displaystyle a[5]b} a [ 4 ] ( a [ 4 ] ( a [ 4 ] ( ⋯ ⋯ [ 4 ] ( a [ 4 ] ( a [ 4 ] a ) ) ⋯ ⋯ ) ) ) ⏟ ⏟ b copies of a {\displaystyle \underbrace {a[4](a[4](a[4](\cdots [4](a[4](a[4]a))\cdots )))} _{\displaystyle b{\mbox{ copies of }}a}} Pentation , hyper5 a , b integers ≥ −1 [ nb 5 ] 6 a [ 6 ] b {\displaystyle a[6]b} a [ 5 ] ( a [ 5 ] ( a [ 5 ] ( ⋯ ⋯ [ 5 ] ( a [ 5 ] ( a [ 5 ] a ) ) ⋯ ⋯ ) ) ) ⏟ ⏟ b copies of a {\displaystyle \underbrace {a[5](a[5](a[5](\cdots [5](a[5](a[5]a))\cdots )))} _{\displaystyle b{\mbox{ copies of }}a}} Hexation, hyper6 Special cases [ edit ] H n (0, b ) = b + 1, when n = 0 b , when n = 1 0, when n = 2 1, when n = 3 and b = 0 [ nb 3 ] [ nb 4 ] 0, when n = 3 and b > 0 [ nb 3 ] [ nb 4 ] 1, when n > 3 and b is even (including 0) 0, when n > 3 and b is odd H n (1, b ) = b , when n = 2 1, when n ≥ 3 H n ( a , 0) = 0, when n = 2 1, when n = 0, or n ≥ 3 a , when n = 1 H n ( a , 1) = 2, when n = 0 a + 1, when n = 1 a , when n ≥ 2 H n ( a , a ) = H n+1 ( a , 2), when n ≥ 1 H n ( a , −1) = [ nb 5 ] 0, when n = 0, or n ≥ 4 a − 1, when n = 1 − a , when n = 2 ⁠ 1 / a ⁠ , when n = 3 H n (2, 2) = 3, when n = 0 4, when n ≥ 1, easily demonstrable recursively.

History [ edit ] One of the earliest discussions of hyperoperations was that of Albert Bennett in 1914, who developed some of the theory of commutative hyperoperations (see below ).

[ 6 ] About 12 years later, Wilhelm Ackermann defined the function ϕ ϕ ( a , b , n ) {\displaystyle \phi (a,b,n)} , which somewhat resembles the hyperoperation sequence.

[ 20 ] In his 1947 paper, [ 5 ] Reuben Goodstein introduced the specific sequence of operations that are now called hyperoperations , and also suggested the Greek names tetration , pentation, etc., for the extended operations beyond exponentiation (because they correspond to the indices 4, 5, etc.).   As a three-argument function, e.g., G ( n , a , b ) = H n ( a , b ) {\displaystyle G(n,a,b)=H_{n}(a,b)} , the hyperoperation sequence as a whole is seen to be a version of the original Ackermann function ϕ ϕ ( a , b , n ) {\displaystyle \phi (a,b,n)} — recursive but not primitive recursive — as modified by Goodstein to incorporate the primitive successor function together with the other three basic operations of arithmetic ( addition , multiplication , exponentiation ), and to make a more seamless extension of these beyond exponentiation.

The original three-argument Ackermann function ϕ ϕ {\displaystyle \phi } uses the same recursion rule as does Goodstein's version of it (i.e., the hyperoperation sequence), but differs from it in two ways. First, ϕ ϕ ( a , b , n ) {\displaystyle \phi (a,b,n)} defines a sequence of operations starting from addition ( n = 0) rather than the successor function , then multiplication ( n = 1), exponentiation ( n = 2), etc.  Secondly, the initial conditions for ϕ ϕ {\displaystyle \phi } result in ϕ ϕ ( a , b , 3 ) = G ( 4 , a , b + 1 ) = a [ 4 ] ( b + 1 ) {\displaystyle \phi (a,b,3)=G(4,a,b+1)=a[4](b+1)} , thus differing from the hyperoperations beyond exponentiation.

[ 7 ] [ 21 ] [ 22 ] The significance of the b + 1 in the previous expression is that ϕ ϕ ( a , b , 3 ) {\displaystyle \phi (a,b,3)} = a a ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ a {\displaystyle a^{a^{\cdot ^{\cdot ^{\cdot ^{a}}}}}} , where b counts the number of operators (exponentiations), rather than counting the number of operands ("a"s) as does the b in a [ 4 ] b {\displaystyle a[4]b} , and so on for the higher-level operations. (See the Ackermann function article for details.) Notations [ edit ] This is a list of notations that have been used for hyperoperations.

Name Notation equivalent to H n ( a , b ) {\displaystyle H_{n}(a,b)} Comment Knuth's up-arrow notation a ↑ ↑ n − − 2 b {\displaystyle a\uparrow ^{n-2}b} Used by Knuth [ 23 ] (for n ≥ 3), and found in several reference books.

[ 24 ] [ 25 ] Hilbert's notation ϕ ϕ n ( a , b ) {\displaystyle \phi _{n}(a,b)} Used by David Hilbert .

[ 26 ] Goodstein's notation G ( n , a , b ) {\displaystyle G(n,a,b)} Used by Reuben Goodstein .

[ 5 ] Original Ackermann function ϕ ϕ ( a , b , n − − 1 ) for 1 ≤ ≤ n ≤ ≤ 3 ϕ ϕ ( a , b − − 1 , n − − 1 ) for n ≥ ≥ 4 {\displaystyle {\begin{matrix}\phi (a,b,n-1)\ {\text{ for }}1\leq n\leq 3\\\phi (a,b-1,n-1)\ {\text{ for }}n\geq 4\end{matrix}}} Used by Wilhelm Ackermann (for n ≥ 1) [ 20 ] Ackermann–Péter function A ( n , b − − 3 ) + 3 for a = 2 {\displaystyle A(n,b-3)+3\ {\text{for }}a=2} This corresponds to hyperoperations for base 2 ( a = 2) Nambiar's notation a ⊗ ⊗ n − − 1 b {\displaystyle a\otimes ^{n-1}b} Used by Nambiar (for n ≥ 1) [ 27 ] Superscript notation a ( n ) b {\displaystyle a{}^{(n)}b} Used by Robert Munafo .

[ 21 ] Subscript notation (for lower hyperoperations) a ( n ) b {\displaystyle a{}_{(n)}b} Used for lower hyperoperations by Robert Munafo.

[ 21 ] Operator notation (for "extended operations") a O n − − 1 b {\displaystyle aO_{n-1}b} Used for lower hyperoperations by John Doner and Alfred Tarski (for n ≥ 1).

[ 28 ] Square bracket notation a [ n ] b {\displaystyle a[n]b} Used in many online forums; convenient for ASCII .

Conway chained arrow notation a → → b → → ( n − − 2 ) {\displaystyle a\to b\to (n-2)} Used by John Horton Conway (for n ≥ 3) Variant starting from a [ edit ] Main article: Ackermann function In 1928, Wilhelm Ackermann defined a 3-argument function ϕ ϕ ( a , b , n ) {\displaystyle \phi (a,b,n)} which gradually evolved into a 2-argument function known as the Ackermann function . The original Ackermann function ϕ ϕ {\displaystyle \phi } was less similar to modern hyperoperations, because his initial conditions start with ϕ ϕ ( a , 0 , n ) = a {\displaystyle \phi (a,0,n)=a} for all n > 2. Also he assigned addition to n = 0, multiplication to n = 1 and exponentiation to n = 2, so the initial conditions produce very different operations for tetration and beyond.

n Operation Comment 0 F 0 ( a , b ) = a + b {\displaystyle F_{0}(a,b)=a+b} 1 F 1 ( a , b ) = a ⋅ ⋅ b {\displaystyle F_{1}(a,b)=a\cdot b} 2 F 2 ( a , b ) = a b {\displaystyle F_{2}(a,b)=a^{b}} 3 F 3 ( a , b ) = a [ 4 ] ( b + 1 ) {\displaystyle F_{3}(a,b)=a[4](b+1)} An offset form of tetration . The iteration of this operation is different than the iteration of tetration.

4 F 4 ( a , b ) = ( x ↦ ↦ a [ 4 ] ( x + 1 ) ) b ( a ) {\displaystyle F_{4}(a,b)=(x\mapsto a[4](x+1))^{b}(a)} Not to be confused with pentation .

Another initial condition that has been used is A ( 0 , b ) = 2 b + 1 {\displaystyle A(0,b)=2b+1} (where the base is constant a = 2 {\displaystyle a=2} ), due to Rózsa Péter , which does not form a hyperoperation hierarchy.

Variant starting from 0 [ edit ] In 1984, C. W. Clenshaw and F. W. J. Olver began the discussion of using hyperoperations to prevent computer floating-point overflows.

[ 29 ] Since then, many other authors [ 30 ] [ 31 ] [ 32 ] have renewed interest in the application of hyperoperations to floating-point representation. (Since H n ( a , b ) are all defined for b = -1.) While discussing tetration , Clenshaw et al.

assumed the initial condition F n ( a , 0 ) = 0 {\displaystyle F_{n}(a,0)=0} , which makes yet another hyperoperation hierarchy. Just like in the previous variant, the fourth operation is very similar to tetration , but offset by one.

n Operation Comment 0 F 0 ( a , b ) = b + 1 {\displaystyle F_{0}(a,b)=b+1} 1 F 1 ( a , b ) = a + b {\displaystyle F_{1}(a,b)=a+b} 2 F 2 ( a , b ) = a ⋅ ⋅ b = e ln ⁡ ⁡ ( a ) + ln ⁡ ⁡ ( b ) {\displaystyle F_{2}(a,b)=a\cdot b=e^{\ln(a)+\ln(b)}} 3 F 3 ( a , b ) = a b {\displaystyle F_{3}(a,b)=a^{b}} 4 F 4 ( a , b ) = a [ 4 ] ( b − − 1 ) {\displaystyle F_{4}(a,b)=a[4](b-1)} An offset form of tetration . The iteration of this operation is much different than the iteration of tetration.

5 F 5 ( a , b ) = ( x ↦ ↦ a [ 4 ] ( x − − 1 ) ) b ( 0 ) = 0 if a > 0 {\displaystyle F_{5}(a,b)=\left(x\mapsto a[4](x-1)\right)^{b}(0)=0{\text{ if }}a>0} Not to be confused with pentation .

Lower hyperoperations [ edit ] An alternative for these hyperoperations is obtained by evaluation from left to right.

[ 9 ] Since a + b = ( a + ( b − − 1 ) ) + 1 a ⋅ ⋅ b = ( a ⋅ ⋅ ( b − − 1 ) ) + a a b = ( a ( b − − 1 ) ) ⋅ ⋅ a {\displaystyle {\begin{aligned}a+b&=(a+(b-1))+1\\a\cdot b&=(a\cdot (b-1))+a\\a^{b}&=\left(a^{(b-1)}\right)\cdot a\end{aligned}}} define (with ° or subscript) a ( n + 1 ) b = ( a ( n + 1 ) ( b − − 1 ) ) ( n ) a {\displaystyle a_{(n+1)}b=\left(a_{(n+1)}(b-1)\right)_{(n)}a} with a ( 1 ) b = a + b a ( 2 ) 0 = 0 a ( n ) 1 = a for n > 2 {\displaystyle {\begin{aligned}a_{(1)}b&=a+b\\a_{(2)}0&=0\\a_{(n)}1&=a&{\text{for }}n>2\\\end{aligned}}} This was extended to ordinal numbers by Doner and Tarski, [ 33 ] by : α α O 0 β β = α α + β β α α O γ γ β β = sup η η < β β , ξ ξ < γ γ ( α α O γ γ η η ) O ξ ξ α α {\displaystyle {\begin{aligned}\alpha O_{0}\beta &=\alpha +\beta \\\alpha O_{\gamma }\beta &=\sup \limits _{\eta <\beta ,\xi <\gamma }(\alpha O_{\gamma }\eta )O_{\xi }\alpha \end{aligned}}} It follows from Definition 1(i), Corollary 2(ii), and Theorem 9, that, for a ≥ 2 and b ≥ 1, that [ original research?

] a O n b = a ( n + 1 ) b {\displaystyle aO_{n}b=a_{(n+1)}b} But this suffers a kind of collapse, failing to form the "power tower" traditionally expected of hyperoperators: [ 34 ] [ nb 6 ] α α ( 4 ) ( 1 + β β ) = α α ( α α β β ) .

{\displaystyle \alpha _{(4)}(1+\beta )=\alpha ^{\left(\alpha ^{\beta }\right)}.} If α ≥ 2 and γ ≥ 2, [ 28 ] [Corollary 33(i)] [ nb 6 ] α α ( 1 + 2 γ γ + 1 ) β β ≤ ≤ α α ( 1 + 2 γ γ ) ( 1 + 3 α α β β ) .

{\displaystyle \alpha _{(1+2\gamma +1)}\beta \leq \alpha _{(1+2\gamma )}(1+3\alpha \beta ).} n Operation Comment 0 F 0 ( a , b ) = a + 1 {\displaystyle F_{0}(a,b)=a+1} Increment, successor, zeration 1 F 1 ( a , b ) = a + b {\displaystyle F_{1}(a,b)=a+b} 2 F 2 ( a , b ) = a ⋅ ⋅ b {\displaystyle F_{2}(a,b)=a\cdot b} 3 F 3 ( a , b ) = a b {\displaystyle F_{3}(a,b)=a^{b}} 4 F 4 ( a , b ) = a ( a ( b − − 1 ) ) {\displaystyle F_{4}(a,b)=a^{\left(a^{(b-1)}\right)}} Not to be confused with tetration .

5 F 5 ( a , b ) = ( x ↦ ↦ x x ( a − − 1 ) ) b − − 1 ( a ) {\displaystyle F_{5}(a,b)=\left(x\mapsto x^{x^{(a-1)}}\right)^{b-1}(a)} Not to be confused with pentation .

Similar to tetration .

Commutative hyperoperations [ edit ] Commutative hyperoperations were considered by Albert Bennett as early as 1914, [ 6 ] which is possibly the earliest remark about any hyperoperation sequence. Commutative hyperoperations are defined by the recursion rule F n + 1 ( a , b ) = exp ⁡ ⁡ ( F n ( ln ⁡ ⁡ ( a ) , ln ⁡ ⁡ ( b ) ) ) {\displaystyle F_{n+1}(a,b)=\exp(F_{n}(\ln(a),\ln(b)))} which is symmetric in a and b , meaning all hyperoperations are commutative. This sequence does not contain exponentiation , and so does not form a hyperoperation hierarchy.

n Operation Comment 0 F 0 ( a , b ) = ln ⁡ ⁡ ( e a + e b ) {\displaystyle F_{0}(a,b)=\ln \left(e^{a}+e^{b}\right)} Smooth maximum 1 F 1 ( a , b ) = a + b {\displaystyle F_{1}(a,b)=a+b} 2 F 2 ( a , b ) = a ⋅ ⋅ b = e ln ⁡ ⁡ ( a ) + ln ⁡ ⁡ ( b ) {\displaystyle F_{2}(a,b)=a\cdot b=e^{\ln(a)+\ln(b)}} This is due to the properties of the logarithm .

3 F 3 ( a , b ) = a ln ⁡ ⁡ ( b ) = e ln ⁡ ⁡ ( a ) ln ⁡ ⁡ ( b ) {\displaystyle F_{3}(a,b)=a^{\ln(b)}=e^{\ln(a)\ln(b)}} In a finite field , this is the Diffie–Hellman key exchange operation.

4 F 4 ( a , b ) = e e ln ⁡ ⁡ ( ln ⁡ ⁡ ( a ) ) ln ⁡ ⁡ ( ln ⁡ ⁡ ( b ) ) {\displaystyle F_{4}(a,b)=e^{e^{\ln(\ln(a))\ln(\ln(b))}}} Not to be confused with tetration .

Numeration systems based on the hyperoperation sequence [ edit ] R. L. Goodstein [ 5 ] used the sequence of hyperoperators to create systems of numeration for the nonnegative integers.  The so-called complete hereditary representation of integer n , at level k and base b , can be expressed as follows using only the first k hyperoperators and using as digits only 0, 1, ..., b − 1, together with the base b itself: For 0 ≤ n ≤ b − 1, n is represented simply by the corresponding digit.

For n > b − 1, the representation of n is found recursively, first representing n in the form b [ k ] x k [ k − 1] x k − 1 [ k - 2] ... [2] x 2 [1] x 1 where x k , ..., x 1 are the largest integers satisfying (in turn) b [ k ] x k ≤ n b [ k ] x k [ k − 1] x k − 1 ≤ n ...

b [ k ] x k [ k − 1] x k − 1 [ k - 2] ... [2] x 2 [1] x 1 ≤ n Any x i exceeding b − 1 is then re-expressed in the same manner, and so on, repeating this procedure until the resulting form contains only the digits 0, 1, ..., b − 1, together with the base b .

Unnecessary parentheses can be avoided by giving higher-level operators higher precedence in the order of evaluation; thus, level-1 representations have the form b [1] X, with X also of this form; level-2 representations have the form b [2] X [1] Y, with X , Y also of this form; level-3 representations have the form b [3] X [2] Y [1] Z, with X , Y , Z also of this form; level-4 representations have the form b [4] X [3] Y [2] Z [1] W, with X , Y , Z , W also of this form; and so on.

In this type of base- b hereditary representation, the base itself appears in the expressions, as well as "digits" from the set {0, 1, ..., b − 1}. This compares to ordinary base-2 representation when the latter is written out in terms of the base b ; e.g., in ordinary base-2 notation, 6 = (110) 2 = 2 [3] 2 [2] 1 [1] 2 [3] 1 [2] 1 [1] 2 [3] 0 [2] 0, whereas the level-3 base-2 hereditary representation is 6 = 2 [3] (2 [3] 1 [2] 1 [1] 0) [2] 1 [1] (2 [3] 1 [2] 1 [1] 0). The hereditary representations can be abbreviated by omitting any instances of [1] 0, [2] 1, [3] 1, [4] 1, etc.;  for example, the above level-3 base-2 representation of 6 abbreviates to 2 [3] 2 [1] 2.

Examples:
The unique base-2 representations of the number 266 , at levels 1, 2, 3, 4, and 5 are as follows: Level 1: 266 = 2 [1] 2 [1] 2 [1] ... [1] 2 (with 133 2s) Level 2: 266 = 2 [2] (2 [2] (2 [2] (2 [2] 2 [2] 2 [2] 2 [2] 2 [1] 1)) [1] 1) Level 3: 266 = 2 [3] 2 [3] (2 [1] 1) [1] 2 [3] (2 [1] 1) [1] 2 Level 4: 266 = 2 [4] (2 [1] 1) [3] 2 [1] 2 [4] 2 [2] 2 [1] 2 Level 5: 266 = 2 [5] 2 [4] 2 [1] 2 [5] 2 [2] 2 [1] 2 See also [ edit ] Wikifunctions has a hyperoperation function .

Large numbers Fast-growing hierarchy Notes [ edit ] ^ Sequences similar to the hyperoperation sequence have historically been referred to by many names, including: the Ackermann function [ 1 ] (3-argument), the Ackermann hierarchy , [ 2 ] the Grzegorczyk hierarchy [ 3 ] [ 4 ] (which is more general), Goodstein's version of the Ackermann function , [ 5 ] operation of the nth grade , [ 6 ] z-fold iterated exponentiation of x with y , [ 7 ] arrow operations , [ 8 ] reihenalgebra [ 9 ] and hyper-n .

[ 1 ] [ 9 ] [ 10 ] [ 11 ] [ 12 ] ^ a b c This implements the leftmost-innermost (one-step) strategy .

^ a b c For more details, see Powers of zero .

^ a b c For more details, see Zero to the power of zero .

^ a b c Let x = a [ n ](−1). By the recursive formula, a [ n ]0 = a [ n − 1]( a [ n ](−1)) ⇒ 1 = a [ n − 1] x . One solution is x = 0, because a [ n − 1]0 = 1 by definition when n ≥ 4. This solution is unique because a [ n − 1] b > 1 for all a > 1, b > 0 (proof by recursion).

^ a b Ordinal addition is not commutative; see ordinal arithmetic for more information References [ edit ] ^ a b c Geisler 2003 .

^ Friedman 2001 .

^ Campagnola, Moore & Félix Costa 2002 .

^ Wirz 1999 .

^ a b c d e Goodstein 1947 .

^ a b c d Bennett 1915 .

^ a b Black 2009 .

^ Littlewood 1948 .

^ a b c Müller 1993 .

^ Munafo 1999a .

^ a b Robbins 2005 .

^ a b Galidakis 2003 .

^ Rubtsov & Romerio 2005 .

^ Townsend 2016 .

^ Romerio 2008 .

^ Bezem, Klop & De Vrijer 2003 .

^ In each step the underlined redex is rewritten.

^ The maximum depth of recursion refers to the number of levels of activation of a procedure which exist during the deepest call of the procedure.

Cornelius & Kirby (1975) ^ LOOP n TIMES DO H.

^ a b Ackermann 1928 .

^ a b c Munafo 1999b .

^ Cowles & Bailey 1988 .

^ Knuth 1976 .

^ Zwillinger 2002 .

^ Weisstein 2003 .

^ Hilbert 1926 .

^ Nambiar 1995 .

^ a b Doner & Tarski 1969 .

^ Clenshaw & Olver 1984 .

^ Holmes 1997 .

^ Zimmermann 1997 .

^ Pinkiewicz, Holmes & Jamil 2000 .

^ Doner & Tarski 1969 , Definition 1.

^ Doner & Tarski 1969 , Theorem 3(iii).

Bibliography [ edit ] Ackermann, Wilhelm (1928).

"Zum Hilbertschen Aufbau der reellen Zahlen" .

Mathematische Annalen .

99 : 118– 133.

doi : 10.1007/BF01459088 .

S2CID 123431274 .

Bennett, Albert A. (December 1915). "Note on an Operation of the Third Grade".

Annals of Mathematics . Second Series.

17 (2): 74– 75.

doi : 10.2307/2007124 .

JSTOR 2007124 .

Bezem, Marc; Klop, Jan Willem; De Vrijer, Roel (2003). "First-order term rewriting systems".

Term Rewriting Systems by "Terese" . Cambridge University Press. pp.

38– 39.

ISBN 0-521-39115-6 .

Black, Paul E. (16 March 2009).

"Ackermann's function" .

Dictionary of Algorithms and Data Structures . U.S. National Institute of Standards and Technology (NIST) . Retrieved 29 August 2021 .

Campagnola, Manuel Lameiras; Moore, Cristopher ; Félix Costa, José (December 2002).

"Transfinite Ordinals in Recursive Number Theory" .

Journal of Complexity .

18 (4): 977– 1000.

doi : 10.1006/jcom.2002.0655 .

Clenshaw, C.W.; Olver, F.W.J. (April 1984).

"Beyond floating point" .

Journal of the ACM .

31 (2): 319– 328.

doi : 10.1145/62.322429 .

S2CID 5132225 .

Cornelius, B.J.; Kirby, G.H. (1975). "Depth of recursion and the ackermann function".

BIT Numerical Mathematics .

15 (2): 144– 150.

doi : 10.1007/BF01932687 .

S2CID 120532578 .

Cowles, J.; Bailey, T. (30 September 1988).

"Several Versions of Ackermann's Function" . Dept. of Computer Science, University of Wyoming, Laramie, WY . Retrieved 29 August 2021 .

Doner, John; Tarski, Alfred (1969).

"An extended arithmetic of ordinal numbers" .

Fundamenta Mathematicae .

65 : 95– 127.

doi : 10.4064/fm-65-1-95-127 .

Friedman, Harvey M. (July 2001).

"Long Finite Sequences" .

Journal of Combinatorial Theory . Series A.

95 (1): 102– 144.

doi : 10.1006/jcta.2000.3154 .

Galidakis, I. N. (2003).

"Mathematics" . Archived from the original on 20 April 2009 . Retrieved 17 April 2009 .

Geisler, Daniel (2003).

"What lies beyond exponentiation?" . Retrieved 17 April 2009 .

Goodstein, Reuben Louis (December 1947).

"Transfinite Ordinals in Recursive Number Theory" (PDF) .

Journal of Symbolic Logic .

12 (4): 123– 129.

doi : 10.2307/2266486 .

JSTOR 2266486 .

S2CID 1318943 .

Hilbert, David (1926). "Über das Unendliche".

Mathematische Annalen .

95 : 161– 190.

doi : 10.1007/BF01206605 .

S2CID 121888793 .

Holmes, W. N. (March 1997).

"Composite Arithmetic: Proposal for a New Standard" .

Computer .

30 (3): 65– 73.

doi : 10.1109/2.573666 . Retrieved 21 April 2009 .

Knuth, Donald Ervin (December 1976).

"Mathematics and Computer Science: Coping with Finiteness" .

Science .

194 (4271): 1235– 1242.

Bibcode : 1976Sci...194.1235K .

doi : 10.1126/science.194.4271.1235 .

PMID 17797067 .

S2CID 1690489 . Retrieved 21 April 2009 .

Littlewood, J. E. (July 1948). "Large Numbers".

Mathematical Gazette .

32 (300): 163– 171.

doi : 10.2307/3609933 .

JSTOR 3609933 .

S2CID 250442130 .

Meyer, Albert R.

; Ritchie, Dennis MacAlistair (1967).

The complexity of loop programs . ACM '67: Proceedings of the 1967 22nd national conference.

doi : 10.1145/800196.806014 .

Müller, Markus (1993).

"Reihenalgebra" (PDF) . Archived from the original (PDF) on 2 December 2013 . Retrieved 6 November 2021 .

Munafo, Robert (1999a).

"Versions of Ackermann's Function" .

Large Numbers at MROB . Retrieved 28 August 2021 .

Munafo, Robert (1999b).

"Inventing New Operators and Functions" .

Large Numbers at MROB . Retrieved 28 August 2021 .

Nambiar, K. K. (1995).

"Ackermann Functions and Transfinite Ordinals" .

Applied Mathematics Letters .

8 (6): 51– 53.

doi : 10.1016/0893-9659(95)00084-4 .

Perstein, Millard H. (1 June 1962).

"Algorithm 93: General order arithmetic" .

Communications of the ACM .

5 (6).

New York City : Association for Computing Machinery : 344.

doi : 10.1145/367766.368160 .

ISSN 0001-0782 .

Pinkiewicz, T.; Holmes, N.; Jamil, T. (2000). "Design of a composite arithmetic unit for rational numbers".

Proceedings of the IEEE Southeast Con 2000. 'Preparing for the New Millennium' (Cat. No.00CH37105) . Proceedings of the IEEE. pp.

245– 252.

doi : 10.1109/SECON.2000.845571 .

ISBN 0-7803-6312-4 .

S2CID 7738926 .

Robbins, A. J. (November 2005).

"Home of Tetration" .

Archived from the original on 13 June 2015 . Retrieved 17 April 2009 .

Romerio, G. F. (21 January 2008).

"Hyperoperations Terminology" . Tetration Forum . Retrieved 21 April 2009 .

Rubtsov, C. A.; Romerio, G. F. (December 2005).

"Ackermann's Function and New Arithmetical Operation" . Retrieved 17 April 2009 .

Townsend, Adam (12 May 2016).

"Names for large numbers" .

Chalkdust magazine .

Weisstein, Eric W. (2003).

CRC concise encyclopedia of mathematics, 2nd Edition . CRC Press. pp.

127– 128.

ISBN 1-58488-347-2 .

Wirz, Marc (1999).

"Characterizing the Grzegorczyk hierarchy by safe recursion" (PDF) . Bern: Institut für Informatik und angewandte Mathematik.

CiteSeerX 10.1.1.42.3374 .

S2CID 117417812 .

Zimmermann, R. (1997).

"Computer Arithmetic: Principles, Architectures, and VLSI Design" (PDF) . Lecture notes, Integrated Systems Laboratory, ETH Zürich. Archived from the original (PDF) on 17 August 2013 . Retrieved 17 April 2009 .

Zwillinger, Daniel (2002).

CRC standard mathematical tables and formulae, 31st Edition . CRC Press. p. 4.

ISBN 1-58488-291-3 .

v t e Hyperoperations Primary Successor (0) Addition (1) Multiplication (2) Exponentiation (3) Tetration (4) Pentation (5) Hexation (6) Inverse for left argument Predecessor (0) Subtraction (1) Division (2) Root extraction (3) Super-root (4) Inverse for right argument Predecessor (0) Subtraction (1) Division (2) Logarithm (3) Super-logarithm (4) Related articles Ackermann function Conway chained arrow notation Grzegorczyk hierarchy Knuth's up-arrow notation Steinhaus–Moser notation v t e Large numbers Examples in numerical order Hundred Thousand Ten thousand Hundred thousand Million Billion Trillion Quadrillion Quintillion Sextillion Septillion Octillion Nonillion Decillion Eddington number Googol Shannon number Googolplex Skewes's number Moser's number Graham's number TREE(3) SSCG(3) BH(3) Rayo's number Expression methods Notations Scientific notation Knuth's up-arrow notation Conway chained arrow notation Steinhaus–Moser notation Operators Hyperoperation Tetration Pentation Ackermann function Grzegorczyk hierarchy Fast-growing hierarchy Related articles (alphabetical order) Busy beaver Extended real number line Indefinite and fictitious numbers Infinitesimal Largest known prime number List of numbers Long and short scales Number systems Number names Orders of magnitude Power of two Power of three Power of 10 Sagan Unit Names History NewPP limit report
Parsed by mw‐web.codfw.main‐6cc77c66b8‐q775k
Cached time: 20250812020932
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.964 seconds
Real time usage: 1.191 seconds
Preprocessor visited node count: 6871/1000000
Revision size: 44380/2097152 bytes
Post‐expand include size: 104108/2097152 bytes
Template argument size: 6450/2097152 bytes
Highest expansion depth: 13/100
Expensive parser function count: 5/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 124455/5000000 bytes
Lua time usage: 0.533/10.000 seconds
Lua memory usage: 7856003/52428800 bytes
Number of Wikibase entities loaded: 0/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  808.529      1 -total
 20.56%  166.234     14 Template:Cite_journal
 17.90%  144.759     49 Template:Sfn
 10.83%   87.558      1 Template:Short_description
 10.30%   83.244      3 Template:Navbox
  9.86%   79.760      1 Template:Hyperoperations
  9.14%   73.923     13 Template:Cite_web
  8.94%   72.275      1 Template:Refn
  7.58%   61.278      2 Template:Pagetype
  4.41%   35.654      4 Template:Cite_book Saved in parser cache with key enwiki:pcache:33731923:|#|:idhash:canonical and timestamp 20250812020932 and revision id 1304190428. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Hyperoperation&oldid=1304190428 " Categories : Operations on numbers Large numbers 1914 introductions Hidden categories: Articles with short description Short description matches Wikidata Use dmy dates from October 2024 All articles that may contain original research Articles that may contain original research from January 2015 This page was last edited on 4 August 2025, at 14:46 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Hyperoperation 18 languages Add topic

