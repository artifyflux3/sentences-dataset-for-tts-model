Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Motivation 2 Discussion Toggle Discussion subsection 2.1 Choosing λ 3 Recursive algorithm 4 RLS algorithm summary 5 Lattice recursive least squares filter (LRLS) Toggle Lattice recursive least squares filter (LRLS) subsection 5.1 Parameter summary 5.2 LRLS algorithm summary 6 Normalized lattice recursive least squares filter (NLRLS) Toggle Normalized lattice recursive least squares filter (NLRLS) subsection 6.1 NLRLS algorithm summary 7 See also 8 References 9 Notes Toggle the table of contents Recursive least squares filter 8 languages Català Deutsch Español Français Polski Русский Српски / srpski 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Adaptive filter algorithm for digital signal processing Recursive least squares ( RLS ) is an adaptive filter algorithm that recursively finds the coefficients that minimize a weighted linear least squares cost function relating to the input signals. This approach is in contrast to other algorithms such as the least mean squares (LMS) that aim to reduce the mean square error . In the derivation of the RLS, the input signals are considered deterministic , while for the LMS and similar algorithms they are considered stochastic . Compared to most of its competitors, the RLS exhibits extremely fast convergence. However, this benefit comes at the cost of high computational complexity.

Motivation [ edit ] RLS was discovered by Gauss but lay unused or ignored until 1950 when Plackett rediscovered the original work of Gauss from 1821.  In general, the RLS can be used to solve any problem that can be solved by adaptive filters . For example, suppose that a signal d ( n ) {\displaystyle d(n)} is transmitted over an echoey, noisy channel that causes it to be received as x ( n ) = ∑ ∑ k = 0 q b n ( k ) d ( n − − k ) + v ( n ) {\displaystyle x(n)=\sum _{k=0}^{q}b_{n}(k)d(n-k)+v(n)} where v ( n ) {\displaystyle v(n)} represents additive noise .  The intent of the RLS filter is to recover the desired signal d ( n ) {\displaystyle d(n)} by use of a p + 1 {\displaystyle p+1} -tap FIR filter, w {\displaystyle \mathbf {w} } : d ( n ) ≈ ≈ ∑ ∑ k = 0 p w ( k ) x ( n − − k ) = w T x n {\displaystyle d(n)\approx \sum _{k=0}^{p}w(k)x(n-k)=\mathbf {w} ^{\mathit {T}}\mathbf {x} _{n}} where x n = [ x ( n ) x ( n − − 1 ) … … x ( n − − p ) ] T {\displaystyle \mathbf {x} _{n}=[x(n)\quad x(n-1)\quad \ldots \quad x(n-p)]^{T}} is the column vector containing the p + 1 {\displaystyle p+1} most recent samples of x ( n ) {\displaystyle x(n)} .  The estimate of the recovered desired signal is d ^ ^ ( n ) = ∑ ∑ k = 0 p w n ( k ) x ( n − − k ) = w n T x n {\displaystyle {\hat {d}}(n)=\sum _{k=0}^{p}w_{n}(k)x(n-k)=\mathbf {w} _{n}^{\mathit {T}}\mathbf {x} _{n}} The goal is to estimate the parameters of the filter w {\displaystyle \mathbf {w} } , and at each time n {\displaystyle n} we refer to the current estimate as w n {\displaystyle \mathbf {w} _{n}} and the adapted least-squares estimate by w n + 1 {\displaystyle \mathbf {w} _{n+1}} .

w n {\displaystyle \mathbf {w} _{n}} is also a column vector, as shown below, and the transpose , w n T {\displaystyle \mathbf {w} _{n}^{\mathit {T}}} , is a row vector .  The matrix product w n T x n {\displaystyle \mathbf {w} _{n}^{\mathit {T}}\mathbf {x} _{n}} (which is the dot product of w n {\displaystyle \mathbf {w} _{n}} and x n {\displaystyle \mathbf {x} _{n}} ) is d ^ ^ ( n ) {\displaystyle {\hat {d}}(n)} , a scalar.  The estimate is "good" if d ^ ^ ( n ) − − d ( n ) {\displaystyle {\hat {d}}(n)-d(n)} is small in magnitude in some least squares sense.

As time evolves, it is desired to avoid completely redoing the least squares algorithm to find the new estimate for w n + 1 {\displaystyle \mathbf {w} _{n+1}} , in terms of w n {\displaystyle \mathbf {w} _{n}} .

The benefit of the RLS algorithm is that there is no need to invert matrices, thereby saving computational cost.  Another advantage is that it provides intuition behind such results as the Kalman filter .

Discussion [ edit ] The idea behind RLS filters is to minimize a cost function C {\displaystyle C} by appropriately selecting the filter coefficients w n {\displaystyle \mathbf {w} _{n}} , updating the filter as new data arrives. The error signal e ( n ) {\displaystyle e(n)} and desired signal d ( n ) {\displaystyle d(n)} are defined in the negative feedback diagram below: The error implicitly depends on the filter coefficients through the estimate d ^ ^ ( n ) {\displaystyle {\hat {d}}(n)} : e ( n ) = d ( n ) − − d ^ ^ ( n ) {\displaystyle e(n)=d(n)-{\hat {d}}(n)} The weighted least squares error function C {\displaystyle C} —the cost function we desire to minimize—being a function of e ( n ) {\displaystyle e(n)} is therefore also dependent on the filter coefficients: C ( w n ) = ∑ ∑ i = 0 n λ λ n − − i e 2 ( i ) {\displaystyle C(\mathbf {w} _{n})=\sum _{i=0}^{n}\lambda ^{n-i}e^{2}(i)} where 0 < λ λ ≤ ≤ 1 {\displaystyle 0<\lambda \leq 1} is the "forgetting factor" which gives exponentially less weight to older error samples.

The cost function is minimized by taking the partial derivatives for all entries k {\displaystyle k} of the coefficient vector w n {\displaystyle \mathbf {w} _{n}} and setting the results to zero ∂ ∂ C ( w n ) ∂ ∂ w n ( k ) = ∑ ∑ i = 0 n 2 λ λ n − − i e ( i ) ⋅ ⋅ ∂ ∂ e ( i ) ∂ ∂ w n ( k ) = − − ∑ ∑ i = 0 n 2 λ λ n − − i e ( i ) x ( i − − k ) = 0 k = 0 , 1 , … … , p {\displaystyle {\frac {\partial C(\mathbf {w} _{n})}{\partial w_{n}(k)}}=\sum _{i=0}^{n}2\lambda ^{n-i}e(i)\cdot {\frac {\partial e(i)}{\partial w_{n}(k)}}=-\sum _{i=0}^{n}2\lambda ^{n-i}e(i)\,x(i-k)=0\qquad k=0,1,\ldots ,p} Next, replace e ( n ) {\displaystyle e(n)} with the definition of the error signal ∑ ∑ i = 0 n λ λ n − − i [ d ( i ) − − ∑ ∑ ℓ ℓ = 0 p w n ( ℓ ℓ ) x ( i − − ℓ ℓ ) ] x ( i − − k ) = 0 k = 0 , 1 , … … , p {\displaystyle \sum _{i=0}^{n}\lambda ^{n-i}\left[d(i)-\sum _{\ell =0}^{p}w_{n}(\ell )x(i-\ell )\right]x(i-k)=0\qquad k=0,1,\ldots ,p} Rearranging the equation yields ∑ ∑ ℓ ℓ = 0 p w n ( ℓ ℓ ) [ ∑ ∑ i = 0 n λ λ n − − i x ( i − − ℓ ℓ ) x ( i − − k ) ] = ∑ ∑ i = 0 n λ λ n − − i d ( i ) x ( i − − k ) k = 0 , 1 , … … , p {\displaystyle \sum _{\ell =0}^{p}w_{n}(\ell )\left[\sum _{i=0}^{n}\lambda ^{n-i}\,x(i-\ell )x(i-k)\right]=\sum _{i=0}^{n}\lambda ^{n-i}d(i)x(i-k)\qquad k=0,1,\ldots ,p} This form can be expressed in terms of matrices R x ( n ) w n = r d x ( n ) {\displaystyle \mathbf {R} _{x}(n)\,\mathbf {w} _{n}=\mathbf {r} _{dx}(n)} where R x ( n ) {\displaystyle \mathbf {R} _{x}(n)} is the weighted sample covariance matrix for x ( n ) {\displaystyle x(n)} , and r d x ( n ) {\displaystyle \mathbf {r} _{dx}(n)} is the equivalent estimate for the cross-covariance between d ( n ) {\displaystyle d(n)} and x ( n ) {\displaystyle x(n)} . Based on this expression we find the coefficients which minimize the cost function as w n = R x − − 1 ( n ) r d x ( n ) {\displaystyle \mathbf {w} _{n}=\mathbf {R} _{x}^{-1}(n)\,\mathbf {r} _{dx}(n)} This is the main result of the discussion.

Choosing λ [ edit ] The smaller λ λ {\displaystyle \lambda } is, the smaller is the contribution of previous samples to the covariance matrix . This makes the filter more sensitive to recent samples, which means more fluctuations in the filter co-efficients. The λ λ = 1 {\displaystyle \lambda =1} case is referred to as the growing window RLS algorithm . In practice, λ λ {\displaystyle \lambda } is usually chosen between 0.98 and 1.

[ 1 ] By using type-II maximum likelihood estimation the optimal λ λ {\displaystyle \lambda } can be estimated from a set of data.

[ 2 ] Recursive algorithm [ edit ] The discussion resulted in a single equation to determine a coefficient vector which minimizes the cost function. In this section we want to derive a recursive solution of the form w n = w n − − 1 + Δ Δ w n − − 1 {\displaystyle \mathbf {w} _{n}=\mathbf {w} _{n-1}+\Delta \mathbf {w} _{n-1}} where Δ Δ w n − − 1 {\displaystyle \Delta \mathbf {w} _{n-1}} is a correction factor at time n − − 1 {\displaystyle {n-1}} . We start the derivation of the recursive algorithm by expressing the cross covariance r d x ( n ) {\displaystyle \mathbf {r} _{dx}(n)} in terms of r d x ( n − − 1 ) {\displaystyle \mathbf {r} _{dx}(n-1)} r d x ( n ) {\displaystyle \mathbf {r} _{dx}(n)} = ∑ ∑ i = 0 n λ λ n − − i d ( i ) x ( i ) {\displaystyle =\sum _{i=0}^{n}\lambda ^{n-i}d(i)\mathbf {x} (i)} = ∑ ∑ i = 0 n − − 1 λ λ n − − i d ( i ) x ( i ) + λ λ 0 d ( n ) x ( n ) {\displaystyle =\sum _{i=0}^{n-1}\lambda ^{n-i}d(i)\mathbf {x} (i)+\lambda ^{0}d(n)\mathbf {x} (n)} = λ λ r d x ( n − − 1 ) + d ( n ) x ( n ) {\displaystyle =\lambda \mathbf {r} _{dx}(n-1)+d(n)\mathbf {x} (n)} where x ( i ) {\displaystyle \mathbf {x} (i)} is the p + 1 {\displaystyle {p+1}} dimensional data vector x ( i ) = [ x ( i ) , x ( i − − 1 ) , … … , x ( i − − p ) ] T {\displaystyle \mathbf {x} (i)=[x(i),x(i-1),\dots ,x(i-p)]^{T}} Similarly we express R x ( n ) {\displaystyle \mathbf {R} _{x}(n)} in terms of R x ( n − − 1 ) {\displaystyle \mathbf {R} _{x}(n-1)} by R x ( n ) {\displaystyle \mathbf {R} _{x}(n)} = ∑ ∑ i = 0 n λ λ n − − i x ( i ) x T ( i ) {\displaystyle =\sum _{i=0}^{n}\lambda ^{n-i}\mathbf {x} (i)\mathbf {x} ^{T}(i)} = λ λ R x ( n − − 1 ) + x ( n ) x T ( n ) {\displaystyle =\lambda \mathbf {R} _{x}(n-1)+\mathbf {x} (n)\mathbf {x} ^{T}(n)} In order to generate the coefficient vector we are interested in the inverse of the deterministic auto-covariance matrix. For that task the Woodbury matrix identity comes in handy. With A {\displaystyle A} = λ λ R x ( n − − 1 ) {\displaystyle =\lambda \mathbf {R} _{x}(n-1)} is ( p + 1 ) {\displaystyle (p+1)} -by- ( p + 1 ) {\displaystyle (p+1)} U {\displaystyle U} = x ( n ) {\displaystyle =\mathbf {x} (n)} is ( p + 1 ) {\displaystyle (p+1)} -by-1 (column vector) V {\displaystyle V} = x T ( n ) {\displaystyle =\mathbf {x} ^{T}(n)} is 1-by- ( p + 1 ) {\displaystyle (p+1)} (row vector) C {\displaystyle C} = I 1 {\displaystyle =\mathbf {I} _{1}} is the 1-by-1 identity matrix The Woodbury matrix identity follows R x − − 1 ( n ) {\displaystyle \mathbf {R} _{x}^{-1}(n)} = {\displaystyle =} [ λ λ R x ( n − − 1 ) + x ( n ) x T ( n ) ] − − 1 {\displaystyle \left[\lambda \mathbf {R} _{x}(n-1)+\mathbf {x} (n)\mathbf {x} ^{T}(n)\right]^{-1}} = {\displaystyle =} 1 λ λ { R x − − 1 ( n − − 1 ) − − R x − − 1 ( n − − 1 ) x ( n ) x T ( n ) R x − − 1 ( n − − 1 ) λ λ + x T ( n ) R x − − 1 ( n − − 1 ) x ( n ) } {\displaystyle {\dfrac {1}{\lambda }}\left\lbrace \mathbf {R} _{x}^{-1}(n-1)-{\dfrac {\mathbf {R} _{x}^{-1}(n-1)\mathbf {x} (n)\mathbf {x} ^{T}(n)\mathbf {R} _{x}^{-1}(n-1)}{\lambda +\mathbf {x} ^{T}(n)\mathbf {R} _{x}^{-1}(n-1)\mathbf {x} (n)}}\right\rbrace } {\displaystyle } To come in line with the standard literature, we define P ( n ) {\displaystyle \mathbf {P} (n)} = R x − − 1 ( n ) {\displaystyle =\mathbf {R} _{x}^{-1}(n)} = λ λ − − 1 P ( n − − 1 ) − − g ( n ) x T ( n ) λ λ − − 1 P ( n − − 1 ) {\displaystyle =\lambda ^{-1}\mathbf {P} (n-1)-\mathbf {g} (n)\mathbf {x} ^{T}(n)\lambda ^{-1}\mathbf {P} (n-1)} where the gain vector g ( n ) {\displaystyle g(n)} is g ( n ) {\displaystyle \mathbf {g} (n)} = λ λ − − 1 P ( n − − 1 ) x ( n ) { 1 + x T ( n ) λ λ − − 1 P ( n − − 1 ) x ( n ) } − − 1 {\displaystyle =\lambda ^{-1}\mathbf {P} (n-1)\mathbf {x} (n)\left\{1+\mathbf {x} ^{T}(n)\lambda ^{-1}\mathbf {P} (n-1)\mathbf {x} (n)\right\}^{-1}} = P ( n − − 1 ) x ( n ) { λ λ + x T ( n ) P ( n − − 1 ) x ( n ) } − − 1 {\displaystyle =\mathbf {P} (n-1)\mathbf {x} (n)\left\{\lambda +\mathbf {x} ^{T}(n)\mathbf {P} (n-1)\mathbf {x} (n)\right\}^{-1}} Before we move on, it is necessary to bring g ( n ) {\displaystyle \mathbf {g} (n)} into another form g ( n ) { 1 + x T ( n ) λ λ − − 1 P ( n − − 1 ) x ( n ) } {\displaystyle \mathbf {g} (n)\left\{1+\mathbf {x} ^{T}(n)\lambda ^{-1}\mathbf {P} (n-1)\mathbf {x} (n)\right\}} = λ λ − − 1 P ( n − − 1 ) x ( n ) {\displaystyle =\lambda ^{-1}\mathbf {P} (n-1)\mathbf {x} (n)} g ( n ) + g ( n ) x T ( n ) λ λ − − 1 P ( n − − 1 ) x ( n ) {\displaystyle \mathbf {g} (n)+\mathbf {g} (n)\mathbf {x} ^{T}(n)\lambda ^{-1}\mathbf {P} (n-1)\mathbf {x} (n)} = λ λ − − 1 P ( n − − 1 ) x ( n ) {\displaystyle =\lambda ^{-1}\mathbf {P} (n-1)\mathbf {x} (n)} Subtracting the second term on the left side yields g ( n ) {\displaystyle \mathbf {g} (n)} = λ λ − − 1 P ( n − − 1 ) x ( n ) − − g ( n ) x T ( n ) λ λ − − 1 P ( n − − 1 ) x ( n ) {\displaystyle =\lambda ^{-1}\mathbf {P} (n-1)\mathbf {x} (n)-\mathbf {g} (n)\mathbf {x} ^{T}(n)\lambda ^{-1}\mathbf {P} (n-1)\mathbf {x} (n)} = λ λ − − 1 [ P ( n − − 1 ) − − g ( n ) x T ( n ) P ( n − − 1 ) ] x ( n ) {\displaystyle =\lambda ^{-1}\left[\mathbf {P} (n-1)-\mathbf {g} (n)\mathbf {x} ^{T}(n)\mathbf {P} (n-1)\right]\mathbf {x} (n)} With the recursive definition of P ( n ) {\displaystyle \mathbf {P} (n)} the desired form follows g ( n ) = P ( n ) x ( n ) {\displaystyle \mathbf {g} (n)=\mathbf {P} (n)\mathbf {x} (n)} Now we are ready to complete the recursion. As discussed w n {\displaystyle \mathbf {w} _{n}} = P ( n ) r d x ( n ) {\displaystyle =\mathbf {P} (n)\,\mathbf {r} _{dx}(n)} = λ λ P ( n ) r d x ( n − − 1 ) + d ( n ) P ( n ) x ( n ) {\displaystyle =\lambda \mathbf {P} (n)\,\mathbf {r} _{dx}(n-1)+d(n)\mathbf {P} (n)\,\mathbf {x} (n)} The second step follows from the recursive definition of r d x ( n ) {\displaystyle \mathbf {r} _{dx}(n)} . Next we incorporate the recursive definition of P ( n ) {\displaystyle \mathbf {P} (n)} together with the alternate form of g ( n ) {\displaystyle \mathbf {g} (n)} and get w n {\displaystyle \mathbf {w} _{n}} = λ λ [ λ λ − − 1 P ( n − − 1 ) − − g ( n ) x T ( n ) λ λ − − 1 P ( n − − 1 ) ] r d x ( n − − 1 ) + d ( n ) g ( n ) {\displaystyle =\lambda \left[\lambda ^{-1}\mathbf {P} (n-1)-\mathbf {g} (n)\mathbf {x} ^{T}(n)\lambda ^{-1}\mathbf {P} (n-1)\right]\mathbf {r} _{dx}(n-1)+d(n)\mathbf {g} (n)} = P ( n − − 1 ) r d x ( n − − 1 ) − − g ( n ) x T ( n ) P ( n − − 1 ) r d x ( n − − 1 ) + d ( n ) g ( n ) {\displaystyle =\mathbf {P} (n-1)\mathbf {r} _{dx}(n-1)-\mathbf {g} (n)\mathbf {x} ^{T}(n)\mathbf {P} (n-1)\mathbf {r} _{dx}(n-1)+d(n)\mathbf {g} (n)} = P ( n − − 1 ) r d x ( n − − 1 ) + g ( n ) [ d ( n ) − − x T ( n ) P ( n − − 1 ) r d x ( n − − 1 ) ] {\displaystyle =\mathbf {P} (n-1)\mathbf {r} _{dx}(n-1)+\mathbf {g} (n)\left[d(n)-\mathbf {x} ^{T}(n)\mathbf {P} (n-1)\mathbf {r} _{dx}(n-1)\right]} With w n − − 1 = P ( n − − 1 ) r d x ( n − − 1 ) {\displaystyle \mathbf {w} _{n-1}=\mathbf {P} (n-1)\mathbf {r} _{dx}(n-1)} we arrive at the update equation w n {\displaystyle \mathbf {w} _{n}} = w n − − 1 + g ( n ) [ d ( n ) − − x T ( n ) w n − − 1 ] {\displaystyle =\mathbf {w} _{n-1}+\mathbf {g} (n)\left[d(n)-\mathbf {x} ^{T}(n)\mathbf {w} _{n-1}\right]} = w n − − 1 + g ( n ) α α ( n ) {\displaystyle =\mathbf {w} _{n-1}+\mathbf {g} (n)\alpha (n)} where α α ( n ) = d ( n ) − − x T ( n ) w n − − 1 {\displaystyle \alpha (n)=d(n)-\mathbf {x} ^{T}(n)\mathbf {w} _{n-1}} is the a priori error. Compare this with the a posteriori error; the error calculated after the filter is updated: e ( n ) = d ( n ) − − x T ( n ) w n {\displaystyle e(n)=d(n)-\mathbf {x} ^{T}(n)\mathbf {w} _{n}} That means we found the correction factor Δ Δ w n − − 1 = g ( n ) α α ( n ) {\displaystyle \Delta \mathbf {w} _{n-1}=\mathbf {g} (n)\alpha (n)} This intuitively satisfying result indicates that the correction factor is directly proportional to both the error and the gain vector, which controls how much sensitivity is desired, through the weighting factor, λ λ {\displaystyle \lambda } .

RLS algorithm summary [ edit ] The RLS algorithm for a p -th order RLS filter can be summarized as Parameters: p = {\displaystyle p=} filter order λ λ = {\displaystyle \lambda =} forgetting factor δ δ = {\displaystyle \delta =} value to initialize P ( 0 ) {\displaystyle \mathbf {P} (0)} Initialization: w ( 0 ) = 0 {\displaystyle \mathbf {w} (0)=0} , x ( k ) = 0 , k = − − p , … … , − − 1 {\displaystyle x(k)=0,k=-p,\dots ,-1} , d ( k ) = 0 , k = − − p , … … , − − 1 {\displaystyle d(k)=0,k=-p,\dots ,-1} P ( 0 ) = δ δ I {\displaystyle \mathbf {P} (0)=\delta I} where I {\displaystyle I} is the identity matrix of rank p + 1 {\displaystyle p+1} Computation: For n = 1 , 2 , … … {\displaystyle n=1,2,\dots } x ( n ) = [ x ( n ) x ( n − − 1 ) ⋮ ⋮ x ( n − − p ) ] {\displaystyle \mathbf {x} (n)=\left[{\begin{matrix}x(n)\\x(n-1)\\\vdots \\x(n-p)\end{matrix}}\right]} α α ( n ) = d ( n ) − − x T ( n ) w ( n − − 1 ) {\displaystyle \alpha (n)=d(n)-\mathbf {x} ^{T}(n)\mathbf {w} (n-1)} g ( n ) = P ( n − − 1 ) x ( n ) { λ λ + x T ( n ) P ( n − − 1 ) x ( n ) } − − 1 {\displaystyle \mathbf {g} (n)=\mathbf {P} (n-1)\mathbf {x} (n)\left\{\lambda +\mathbf {x} ^{T}(n)\mathbf {P} (n-1)\mathbf {x} (n)\right\}^{-1}} P ( n ) = λ λ − − 1 P ( n − − 1 ) − − g ( n ) x T ( n ) λ λ − − 1 P ( n − − 1 ) {\displaystyle \mathbf {P} (n)=\lambda ^{-1}\mathbf {P} (n-1)-\mathbf {g} (n)\mathbf {x} ^{T}(n)\lambda ^{-1}\mathbf {P} (n-1)} w ( n ) = w ( n − − 1 ) + α α ( n ) g ( n ) {\displaystyle \mathbf {w} (n)=\mathbf {w} (n-1)+\,\alpha (n)\mathbf {g} (n)} .

The recursion for P {\displaystyle P} follows an algebraic Riccati equation and thus draws parallels to the Kalman filter .

[ 3 ] Lattice recursive least squares filter (LRLS) [ edit ] The lattice recursive least squares adaptive filter is related to the standard RLS except that it requires fewer arithmetic operations (order N ).

[ 4 ] It offers additional advantages over conventional LMS algorithms such as faster convergence rates, modular structure, and insensitivity to variations in eigenvalue spread of the input correlation matrix. The LRLS algorithm described is based on a posteriori errors and includes the normalized form. The derivation is similar to the standard RLS algorithm and is based on the definition of d ( k ) {\displaystyle d(k)\,\!} . In the forward prediction case, we have d ( k ) = x ( k ) {\displaystyle d(k)=x(k)\,\!} with the input signal x ( k − − 1 ) {\displaystyle x(k-1)\,\!} as the most up to date sample. The backward prediction case is d ( k ) = x ( k − − i − − 1 ) {\displaystyle d(k)=x(k-i-1)\,\!} , where i is the index of the sample in the past we want to predict, and the input signal x ( k ) {\displaystyle x(k)\,\!} is the most recent sample.

[ 5 ] Parameter summary [ edit ] κ κ f ( k , i ) {\displaystyle \kappa _{f}(k,i)\,\!} is the forward reflection coefficient κ κ b ( k , i ) {\displaystyle \kappa _{b}(k,i)\,\!} is the backward reflection coefficient e f ( k , i ) {\displaystyle e_{f}(k,i)\,\!} represents the instantaneous a posteriori forward prediction error e b ( k , i ) {\displaystyle e_{b}(k,i)\,\!} represents the instantaneous a posteriori backward prediction error ξ ξ b min d ( k , i ) {\displaystyle \xi _{b_{\min }}^{d}(k,i)\,\!} is the minimum least-squares backward prediction error ξ ξ f min d ( k , i ) {\displaystyle \xi _{f_{\min }}^{d}(k,i)\,\!} is the minimum least-squares forward prediction error γ γ ( k , i ) {\displaystyle \gamma (k,i)\,\!} is a conversion factor between a priori and a posteriori errors v i ( k ) {\displaystyle v_{i}(k)\,\!} are the feedforward multiplier coefficients.

ε ε {\displaystyle \varepsilon \,\!} is a small positive constant that can be 0.01 LRLS algorithm summary [ edit ] The algorithm for a LRLS filter can be summarized as Initialization: For i = 0 , 1 , … … , N {\textstyle i=0,1,\ldots ,N} δ δ ( − − 1 , i ) = δ δ D ( − − 1 , i ) = 0 {\displaystyle \delta (-1,i)=\delta _{D}(-1,i)=0\,\!} (if x ( k ) = 0 {\textstyle x(k)=0} for k < 0 {\textstyle k<0} ) ξ ξ b min d ( − − 1 , i ) = ξ ξ f min d ( − − 1 , i ) = ε ε {\displaystyle \xi _{b_{\min }}^{d}(-1,i)=\xi _{f_{\min }}^{d}(-1,i)=\varepsilon } γ γ ( − − 1 , i ) = 1 {\displaystyle \gamma (-1,i)=1\,\!} e b ( − − 1 , i ) = 0 {\displaystyle e_{b}(-1,i)=0\,\!} End Computation: For k ≥ ≥ 0 {\textstyle k\geq 0} γ γ ( k , 0 ) = 1 {\displaystyle \gamma (k,0)=1\,\!} e b ( k , 0 ) = e f ( k , 0 ) = x ( k ) {\displaystyle e_{b}(k,0)=e_{f}(k,0)=x(k)\,\!} ξ ξ b min d ( k , 0 ) = ξ ξ f min d ( k , 0 ) = x 2 ( k ) + λ λ ξ ξ f min d ( k − − 1 , 0 ) {\displaystyle \xi _{b_{\min }}^{d}(k,0)=\xi _{f_{\min }}^{d}(k,0)=x^{2}(k)+\lambda \xi _{f_{\min }}^{d}(k-1,0)\,\!} e ( k , 0 ) = d ( k ) {\displaystyle e(k,0)=d(k)\,\!} For i = 0 , 1 , … … , N {\textstyle i=0,1,\ldots ,N} δ δ ( k , i ) = λ λ δ δ ( k − − 1 , i ) + e b ( k − − 1 , i ) e f ( k , i ) γ γ ( k − − 1 , i ) {\displaystyle \delta (k,i)=\lambda \delta (k-1,i)+{\frac {e_{b}(k-1,i)e_{f}(k,i)}{\gamma (k-1,i)}}} γ γ ( k , i + 1 ) = γ γ ( k , i ) − − e b 2 ( k , i ) ξ ξ b min d ( k , i ) {\displaystyle \gamma (k,i+1)=\gamma (k,i)-{\frac {e_{b}^{2}(k,i)}{\xi _{b_{\min }}^{d}(k,i)}}} κ κ b ( k , i ) = δ δ ( k , i ) ξ ξ f min d ( k , i ) {\displaystyle \kappa _{b}(k,i)={\frac {\delta (k,i)}{\xi _{f_{\min }}^{d}(k,i)}}} κ κ f ( k , i ) = δ δ ( k , i ) ξ ξ b min d ( k − − 1 , i ) {\displaystyle \kappa _{f}(k,i)={\frac {\delta (k,i)}{\xi _{b_{\min }}^{d}(k-1,i)}}} e b ( k , i + 1 ) = e b ( k − − 1 , i ) − − κ κ b ( k , i ) e f ( k , i ) {\displaystyle e_{b}(k,i+1)=e_{b}(k-1,i)-\kappa _{b}(k,i)e_{f}(k,i)\,\!} e f ( k , i + 1 ) = e f ( k , i ) − − κ κ f ( k , i ) e b ( k − − 1 , i ) {\displaystyle e_{f}(k,i+1)=e_{f}(k,i)-\kappa _{f}(k,i)e_{b}(k-1,i)\,\!} ξ ξ b min d ( k , i + 1 ) = ξ ξ b min d ( k − − 1 , i ) − − δ δ ( k , i ) κ κ b ( k , i ) {\displaystyle \xi _{b_{\min }}^{d}(k,i+1)=\xi _{b_{\min }}^{d}(k-1,i)-\delta (k,i)\kappa _{b}(k,i)} ξ ξ f min d ( k , i + 1 ) = ξ ξ f min d ( k , i ) − − δ δ ( k , i ) κ κ f ( k , i ) {\displaystyle \xi _{f_{\min }}^{d}(k,i+1)=\xi _{f_{\min }}^{d}(k,i)-\delta (k,i)\kappa _{f}(k,i)} Feedforward filtering δ δ D ( k , i ) = λ λ δ δ D ( k − − 1 , i ) + e ( k , i ) e b ( k , i ) γ γ ( k , i ) {\displaystyle \delta _{D}(k,i)=\lambda \delta _{D}(k-1,i)+{\frac {e(k,i)e_{b}(k,i)}{\gamma (k,i)}}} v i ( k ) = δ δ D ( k , i ) ξ ξ b min d ( k , i ) {\displaystyle v_{i}(k)={\frac {\delta _{D}(k,i)}{\xi _{b_{\min }}^{d}(k,i)}}} e ( k , i + 1 ) = e ( k , i ) − − v i ( k ) e b ( k , i ) {\displaystyle e(k,i+1)=e(k,i)-v_{i}(k)e_{b}(k,i)\,\!} End End Normalized lattice recursive least squares filter (NLRLS) [ edit ] The normalized form of the LRLS has fewer recursions and variables. It can be calculated by applying a normalization to the internal variables of the algorithm which will keep their magnitude bounded by one. This is generally not used in real-time applications because of the number of division and square-root operations which comes with a high computational load.

NLRLS algorithm summary [ edit ] The algorithm for a NLRLS filter can be summarized as Initialization: For i = 0 , 1 , … … , N .

{\textstyle i=0,1,\ldots ,N.} δ δ ¯ ¯ ( − − 1 , i ) = 0 {\displaystyle {\overline {\delta }}(-1,i)=0\,\!} (if x ( k ) = d ( k ) = 0 {\textstyle x(k)=d(k)=0} for k < 0 {\textstyle k<0} ) δ δ ¯ ¯ D ( − − 1 , i ) = 0 {\displaystyle {\overline {\delta }}_{D}(-1,i)=0\,\!} e ¯ ¯ b ( − − 1 , i ) = 0 {\displaystyle {\overline {e}}_{b}(-1,i)=0\,\!} End σ σ x 2 ( − − 1 ) = λ λ σ σ d 2 ( − − 1 ) = ε ε {\displaystyle \sigma _{x}^{2}(-1)=\lambda \sigma _{d}^{2}(-1)=\varepsilon \,\!} Computation: For k ≥ ≥ 0 {\textstyle k\geq 0} σ σ x 2 ( k ) = λ λ σ σ x 2 ( k − − 1 ) + x 2 ( k ) {\displaystyle \sigma _{x}^{2}(k)=\lambda \sigma _{x}^{2}(k-1)+x^{2}(k)\,\!} (Input signal energy) σ σ d 2 ( k ) = λ λ σ σ d 2 ( k − − 1 ) + d 2 ( k ) {\displaystyle \sigma _{d}^{2}(k)=\lambda \sigma _{d}^{2}(k-1)+d^{2}(k)\,\!} (Reference signal energy) e ¯ ¯ b ( k , 0 ) = e ¯ ¯ f ( k , 0 ) = x ( k ) σ σ x ( k ) {\displaystyle {\overline {e}}_{b}(k,0)={\overline {e}}_{f}(k,0)={\frac {x(k)}{\sigma _{x}(k)}}\,\!} e ¯ ¯ ( k , 0 ) = d ( k ) σ σ d ( k ) {\displaystyle {\overline {e}}(k,0)={\frac {d(k)}{\sigma _{d}(k)}}\,\!} For i = 0 , 1 , … … , N {\textstyle i=0,1,\ldots ,N} δ δ ¯ ¯ ( k , i ) = δ δ ( k − − 1 , i ) ( 1 − − e ¯ ¯ b 2 ( k − − 1 , i ) ) ( 1 − − e ¯ ¯ f 2 ( k , i ) ) + e ¯ ¯ b ( k − − 1 , i ) e ¯ ¯ f ( k , i ) {\displaystyle {\overline {\delta }}(k,i)=\delta (k-1,i){\sqrt {(1-{\overline {e}}_{b}^{2}(k-1,i))(1-{\overline {e}}_{f}^{2}(k,i))}}+{\overline {e}}_{b}(k-1,i){\overline {e}}_{f}(k,i)} e ¯ ¯ b ( k , i + 1 ) = e ¯ ¯ b ( k − − 1 , i ) − − δ δ ¯ ¯ ( k , i ) e ¯ ¯ f ( k , i ) ( 1 − − δ δ ¯ ¯ 2 ( k , i ) ) ( 1 − − e ¯ ¯ f 2 ( k , i ) ) {\displaystyle {\overline {e}}_{b}(k,i+1)={\frac {{\overline {e}}_{b}(k-1,i)-{\overline {\delta }}(k,i){\overline {e}}_{f}(k,i)}{\sqrt {(1-{\overline {\delta }}^{2}(k,i))(1-{\overline {e}}_{f}^{2}(k,i))}}}} e ¯ ¯ f ( k , i + 1 ) = e ¯ ¯ f ( k , i ) − − δ δ ¯ ¯ ( k , i ) e ¯ ¯ b ( k − − 1 , i ) ( 1 − − δ δ ¯ ¯ 2 ( k , i ) ) ( 1 − − e ¯ ¯ b 2 ( k − − 1 , i ) ) {\displaystyle {\overline {e}}_{f}(k,i+1)={\frac {{\overline {e}}_{f}(k,i)-{\overline {\delta }}(k,i){\overline {e}}_{b}(k-1,i)}{\sqrt {(1-{\overline {\delta }}^{2}(k,i))(1-{\overline {e}}_{b}^{2}(k-1,i))}}}} Feedforward filter δ δ ¯ ¯ D ( k , i ) = δ δ ¯ ¯ D ( k − − 1 , i ) ( 1 − − e ¯ ¯ b 2 ( k , i ) ) ( 1 − − e ¯ ¯ 2 ( k , i ) ) + e ¯ ¯ ( k , i ) e ¯ ¯ b ( k , i ) {\displaystyle {\overline {\delta }}_{D}(k,i)={\overline {\delta }}_{D}(k-1,i){\sqrt {(1-{\overline {e}}_{b}^{2}(k,i))(1-{\overline {e}}^{2}(k,i))}}+{\overline {e}}(k,i){\overline {e}}_{b}(k,i)} e ¯ ¯ ( k , i + 1 ) = 1 ( 1 − − e ¯ ¯ b 2 ( k , i ) ) ( 1 − − δ δ ¯ ¯ D 2 ( k , i ) ) [ e ¯ ¯ ( k , i ) − − δ δ ¯ ¯ D ( k , i ) e ¯ ¯ b ( k , i ) ] {\displaystyle {\overline {e}}(k,i+1)={\frac {1}{\sqrt {(1-{\overline {e}}_{b}^{2}(k,i))(1-{\overline {\delta }}_{D}^{2}(k,i))}}}[{\overline {e}}(k,i)-{\overline {\delta }}_{D}(k,i){\overline {e}}_{b}(k,i)]} End End See also [ edit ] Adaptive filter Kernel adaptive filter Least mean squares filter Zero-forcing equalizer References [ edit ] Hayes, Monson H. (1996). "9.4: Recursive Least Squares".

Statistical Digital Signal Processing and Modeling . Wiley. p. 541.

ISBN 0-471-59431-8 .

Simon Haykin, Adaptive Filter Theory , Prentice Hall, 2002, ISBN 0-13-048434-2 M.H.A Davis, R.B. Vinter, Stochastic Modelling and Control , Springer, 1985, ISBN 0-412-16200-8 Weifeng Liu, Jose Principe and Simon Haykin, Kernel Adaptive Filtering: A Comprehensive Introduction , John Wiley, 2010, ISBN 0-470-44753-2 R.L.Plackett, Some Theorems in Least Squares , Biometrika, 1950, 37, 149–157, ISSN 0006-3444 C.F.Gauss, Theoria combinationis observationum erroribus minimis obnoxiae , 1821, Werke, 4. Gottinge Notes [ edit ] ^ Emannual C. Ifeacor, Barrie W. Jervis. Digital signal processing: a practical approach, second edition. Indianapolis: Pearson Education Limited, 2002, p. 718 ^ Steven Van Vaerenbergh, Ignacio Santamaría, Miguel Lázaro-Gredilla "Estimation of the forgetting factor in kernel recursive least squares" , 2012 IEEE International Workshop on Machine Learning for Signal Processing, 2012, accessed June 23, 2016.

^ Welch, Greg and Bishop, Gary "An Introduction to the Kalman Filter" , Department of Computer Science, University of North Carolina at Chapel Hill, September 17, 1997, accessed July 19, 2011.

^ Diniz, Paulo S.R., "Adaptive Filtering: Algorithms  and Practical Implementation", Springer Nature Switzerland AG 2020, Chapter 7: Adaptive Lattice-Based RLS Algorithms.

https://doi.org/10.1007/978-3-030-29057-3_7 ^ Albu, Kadlec, Softley, Matousek, Hermanek, Coleman, Fagan "Implementation of (Normalised) RLS Lattice on Virtex" Archived 2016-03-04 at the Wayback Machine , Digital Signal Processing, 2001, accessed December 24, 2011.

Retrieved from " https://en.wikipedia.org/w/index.php?title=Recursive_least_squares_filter&oldid=1306542668 " Categories : Digital signal processing Filter theory Statistical signal processing Hidden categories: Webarchive template wayback links Articles with short description Short description matches Wikidata This page was last edited on 18 August 2025, at 09:19 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Recursive least squares filter 8 languages Add topic

