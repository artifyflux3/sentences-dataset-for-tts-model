Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Description Toggle Description subsection 1.1 An analogy for understanding gradient descent 1.2 Choosing the step size and descent direction 2 Solution of a linear system Toggle Solution of a linear system subsection 2.1 Geometric behavior and residual orthogonality 3 Solution of a non-linear system 4 Comments 5 Modifications Toggle Modifications subsection 5.1 Fast gradient methods 5.2 Momentum or heavy ball method 6 Extensions 7 Theoretical properties 8 See also 9 References 10 Further reading 11 External links Toggle the table of contents Gradient descent 26 languages العربية Български Català Čeština Deutsch Español فارسی Français 한국어 Bahasa Indonesia Italiano עברית Lietuvių മലയാളം 日本語 Polski Português Русский Српски / srpski Svenska ไทย Українська Tiếng Việt 吴语 粵語 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Optimization algorithm For the analytical method called "steepest descent", see Method of steepest descent .

Part of a series on Machine learning and data mining Paradigms Supervised learning Unsupervised learning Semi-supervised learning Self-supervised learning Reinforcement learning Meta-learning Online learning Batch learning Curriculum learning Rule-based learning Neuro-symbolic AI Neuromorphic engineering Quantum machine learning Problems Classification Generative modeling Regression Clustering Dimensionality reduction Density estimation Anomaly detection Data cleaning AutoML Association rules Semantic analysis Structured prediction Feature engineering Feature learning Learning to rank Grammar induction Ontology learning Multimodal learning Supervised learning ( classification • regression ) Apprenticeship learning Decision trees Ensembles Bagging Boosting Random forest k -NN Linear regression Naive Bayes Artificial neural networks Logistic regression Perceptron Relevance vector machine (RVM) Support vector machine (SVM) Clustering BIRCH CURE Hierarchical k -means Fuzzy Expectation–maximization (EM) DBSCAN OPTICS Mean shift Dimensionality reduction Factor analysis CCA ICA LDA NMF PCA PGD t-SNE SDL Structured prediction Graphical models Bayes net Conditional random field Hidden Markov Anomaly detection RANSAC k -NN Local outlier factor Isolation forest Neural networks Autoencoder Deep learning Feedforward neural network Recurrent neural network LSTM GRU ESN reservoir computing Boltzmann machine Restricted GAN Diffusion model SOM Convolutional neural network U-Net LeNet AlexNet DeepDream Neural field Neural radiance field Physics-informed neural networks Transformer Vision Mamba Spiking neural network Memtransistor Electrochemical RAM (ECRAM) Reinforcement learning Q-learning Policy gradient SARSA Temporal difference (TD) Multi-agent Self-play Learning with humans Active learning Crowdsourcing Human-in-the-loop Mechanistic interpretability RLHF Model diagnostics Coefficient of determination Confusion matrix Learning curve ROC curve Mathematical foundations Kernel machines Bias–variance tradeoff Computational learning theory Empirical risk minimization Occam learning PAC learning Statistical learning VC theory Topological deep learning Journals and conferences AAAI ECML PKDD NeurIPS ICML ICLR IJCAI ML JMLR Related articles Glossary of artificial intelligence List of datasets for machine-learning research List of datasets in computer vision and image processing Outline of machine learning v t e Gradient Descent in 2D Gradient descent is a method for unconstrained mathematical optimization . It is a first-order iterative algorithm for minimizing a differentiable multivariate function .

The idea is to take repeated steps in the opposite direction of the gradient (or approximate gradient) of the function at the current point, because this is the direction of steepest descent. Conversely, stepping in the direction of the gradient will lead to a trajectory that maximizes that function; the procedure is then known as gradient ascent .
It is particularly useful in machine learning for minimizing the cost or loss function.

[ 1 ] Gradient descent should not be confused with local search algorithms, although both are iterative methods for optimization .

Gradient descent is generally attributed to Augustin-Louis Cauchy , who first suggested it in 1847.

[ 2 ] Jacques Hadamard independently proposed a similar method in 1907.

[ 3 ] [ 4 ] Its convergence properties for non-linear optimization problems were first studied by Haskell Curry in 1944, [ 5 ] with the method becoming increasingly well-studied and used in the following decades.

[ 6 ] [ 7 ] A simple extension of gradient descent, stochastic gradient descent , serves as the most basic algorithm used for training most deep networks today.

Description [ edit ] Illustration of gradient descent on a series of level sets Gradient descent is based on the observation that if the multi-variable function f ( x ) {\displaystyle f(\mathbf {x} )} is defined and differentiable in a neighborhood of a point a {\displaystyle \mathbf {a} } , then f ( x ) {\displaystyle f(\mathbf {x} )} decreases fastest if one goes from a {\displaystyle \mathbf {a} } in the direction of the negative gradient of f {\displaystyle f} at a , − − ∇ ∇ f ( a ) {\displaystyle \mathbf {a} ,-\nabla f(\mathbf {a} )} . It follows that, if a n + 1 = a n − − η η ∇ ∇ f ( a n ) {\displaystyle \mathbf {a} _{n+1}=\mathbf {a} _{n}-\eta \nabla f(\mathbf {a} _{n})} for a small enough step size or learning rate η η ∈ ∈ R + {\displaystyle \eta \in \mathbb {R} _{+}} , then f ( a n ) ≥ ≥ f ( a n + 1 ) {\displaystyle f(\mathbf {a_{n}} )\geq f(\mathbf {a_{n+1}} )} . In other words, the term η η ∇ ∇ f ( a ) {\displaystyle \eta \nabla f(\mathbf {a} )} is subtracted from a {\displaystyle \mathbf {a} } because we want to move against the gradient, toward the local minimum. With this observation in mind, one starts with a guess x 0 {\displaystyle \mathbf {x} _{0}} for a local minimum of f {\displaystyle f} , and considers the sequence x 0 , x 1 , x 2 , … … {\displaystyle \mathbf {x} _{0},\mathbf {x} _{1},\mathbf {x} _{2},\ldots } such that x n + 1 = x n − − η η n ∇ ∇ f ( x n ) , n ≥ ≥ 0.

{\displaystyle \mathbf {x} _{n+1}=\mathbf {x} _{n}-\eta _{n}\nabla f(\mathbf {x} _{n}),\ n\geq 0.} We have a monotonic sequence f ( x 0 ) ≥ ≥ f ( x 1 ) ≥ ≥ f ( x 2 ) ≥ ≥ ⋯ ⋯ , {\displaystyle f(\mathbf {x} _{0})\geq f(\mathbf {x} _{1})\geq f(\mathbf {x} _{2})\geq \cdots ,} so the sequence ( x n ) {\displaystyle (\mathbf {x} _{n})} converges to the desired local minimum. Note that the value of the step size η η {\displaystyle \eta } is allowed to change at every iteration.

It is possible to guarantee the convergence to a local minimum under certain assumptions on the function f {\displaystyle f} (for example, f {\displaystyle f} convex and ∇ ∇ f {\displaystyle \nabla f} Lipschitz ) and particular choices of η η {\displaystyle \eta } . Those include the sequence η η n = | ( x n − − x n − − 1 ) ⊤ ⊤ [ ∇ ∇ f ( x n ) − − ∇ ∇ f ( x n − − 1 ) ] | ‖ ∇ ∇ f ( x n ) − − ∇ ∇ f ( x n − − 1 ) ‖ 2 {\displaystyle \eta _{n}={\frac {\left|\left(\mathbf {x} _{n}-\mathbf {x} _{n-1}\right)^{\top }\left[\nabla f(\mathbf {x} _{n})-\nabla f(\mathbf {x} _{n-1})\right]\right|}{\left\|\nabla f(\mathbf {x} _{n})-\nabla f(\mathbf {x} _{n-1})\right\|^{2}}}} as in the Barzilai-Borwein method , [ 8 ] [ 9 ] or a sequence η η n {\displaystyle \eta _{n}} satisfying the Wolfe conditions (which can be found by using line search ). When the function f {\displaystyle f} is convex , all local minima are also global minima, so in this case gradient descent can converge to the global solution.

This process is illustrated in the adjacent picture. Here, f {\displaystyle f} is assumed to be defined on the plane, and that its graph has a bowl shape.  The blue curves are the contour lines , that is, the regions on which the value of f {\displaystyle f} is constant. A red arrow originating at a point shows the direction of the negative gradient at that point. Note that the (negative) gradient at a point is orthogonal to the contour line going through that point. We see that gradient descent leads us to the bottom of the bowl, that is, to the point where the value of the function f {\displaystyle f} is minimal.

An analogy for understanding gradient descent [ edit ] Fog in the mountains The basic intuition behind gradient descent can be illustrated by a hypothetical scenario. People are stuck in the mountains and are trying to get down (i.e., trying to find the global minimum). There is heavy fog such that visibility is extremely low. Therefore, the path down the mountain is not visible, so they must use local information to find the minimum. They can use the method of gradient descent, which involves looking at the steepness of the hill at their current position, then proceeding in the direction with the steepest descent (i.e., downhill). If they were trying to find the top of the mountain (i.e., the maximum), then they would proceed in the direction of steepest ascent (i.e., uphill). Using this method, they would eventually find their way down the mountain or possibly get stuck in some hole (i.e., local minimum or saddle point ), like a mountain lake. However, assume also that the steepness of the hill is not immediately obvious with simple observation, but rather it requires a sophisticated instrument to measure, which the persons happen to have at the moment. It takes quite some time to measure the steepness of the hill with the instrument, thus they should minimize their use of the instrument if they wanted to get down the mountain before sunset. The difficulty then is choosing the frequency at which they should measure the steepness of the hill so not to go off track.

In this analogy, the persons represent the algorithm, and the path taken down the mountain represents the sequence of parameter settings that the algorithm will explore. The steepness of the hill represents the slope of the function at that point. The instrument used to measure steepness is differentiation . The direction they choose to travel in aligns with the gradient of the function at that point. The amount of time they travel before taking another measurement is the step size.

Choosing the step size and descent direction [ edit ] Since using a step size η η {\displaystyle \eta } that is too small would slow convergence, and a η η {\displaystyle \eta } too large would lead to overshoot and divergence, finding a good setting of η η {\displaystyle \eta } is an important practical problem.

Philip Wolfe also advocated using "clever choices of the [descent] direction" in practice.

[ 10 ] While using a direction that deviates from the steepest descent direction may seem counter-intuitive, the idea is that the smaller slope may be compensated for by being sustained over a much longer distance.

To reason about this mathematically, consider a direction p n {\displaystyle \mathbf {p} _{n}} and step size η η n {\displaystyle \eta _{n}} and consider the more general update: a n + 1 = a n − − η η n p n {\displaystyle \mathbf {a} _{n+1}=\mathbf {a} _{n}-\eta _{n}\,\mathbf {p} _{n}} .

Finding good settings of p n {\displaystyle \mathbf {p} _{n}} and η η n {\displaystyle \eta _{n}} requires some thought. First of all, we would like the update direction to point downhill. Mathematically, letting θ θ n {\displaystyle \theta _{n}} denote the angle between − − ∇ ∇ f ( a n ) {\displaystyle -\nabla f(\mathbf {a_{n}} )} and p n {\displaystyle \mathbf {p} _{n}} , this requires that cos ⁡ ⁡ θ θ n > 0.

{\displaystyle \cos \theta _{n}>0.} To say more, we need more information about the objective function that we are optimising. Under the fairly weak assumption that f {\displaystyle f} is continuously differentiable, we may prove that: [ 11 ] f ( a n + 1 ) ≤ ≤ f ( a n ) − − η η n ‖ ‖ ∇ ∇ f ( a n ) ‖ ‖ 2 ‖ ‖ p n ‖ ‖ 2 ( cos ⁡ ⁡ θ θ n − − max t ∈ ∈ [ 0 , 1 ] ‖ ‖ ∇ ∇ f ( a n − − t η η n p n ) − − ∇ ∇ f ( a n ) ‖ ‖ 2 ‖ ‖ ∇ ∇ f ( a n ) ‖ ‖ 2 ) {\displaystyle f(\mathbf {a} _{n+1})\leq f(\mathbf {a} _{n})-\eta _{n}\|\nabla f(\mathbf {a} _{n})\|_{2}\|\mathbf {p} _{n}\|_{2}\left(\cos \theta _{n}-\max _{t\in [0,1]}{\frac {\|\nabla f(\mathbf {a} _{n}-t\eta _{n}\mathbf {p} _{n})-\nabla f(\mathbf {a} _{n})\|_{2}}{\|\nabla f(\mathbf {a} _{n})\|_{2}}}\right)} 1 This inequality implies that the amount by which we can be sure the function f {\displaystyle f} is decreased depends on a trade off between the two terms in square brackets. The first term in square brackets measures the angle between the descent direction and the negative gradient. The second term measures how quickly the gradient changes along the descent direction.

In principle inequality ( 1 ) could be optimized over p n {\displaystyle \mathbf {p} _{n}} and η η n {\displaystyle \eta _{n}} to choose an optimal step size and direction. The problem is that evaluating the second term in square brackets requires evaluating ∇ ∇ f ( a n − − t η η n p n ) {\displaystyle \nabla f(\mathbf {a} _{n}-t\eta _{n}\mathbf {p} _{n})} , and extra gradient evaluations are generally expensive and undesirable. Some ways around this problem are: Forgo the benefits of a clever descent direction by setting p n = ∇ ∇ f ( a n ) {\displaystyle \mathbf {p} _{n}=\nabla f(\mathbf {a_{n}} )} , and use line search to find a suitable step-size γ γ n {\displaystyle \gamma _{n}} , such as one that satisfies the Wolfe conditions . A more economic way of choosing learning rates is backtracking line search , a method that has both good theoretical guarantees and experimental results. Note that one does not need to choose p n {\displaystyle \mathbf {p} _{n}} to be the gradient; any direction that has positive inner product with the gradient will result in a reduction of the function value (for a sufficiently small value of η η n {\displaystyle \eta _{n}} ).

Assuming that f {\displaystyle f} is twice-differentiable, use its Hessian ∇ ∇ 2 f {\displaystyle \nabla ^{2}f} to estimate ‖ ‖ ∇ ∇ f ( a n − − t η η n p n ) − − ∇ ∇ f ( a n ) ‖ ‖ 2 ≈ ≈ ‖ ‖ t η η n ∇ ∇ 2 f ( a n ) p n ‖ ‖ .

{\displaystyle \|\nabla f(\mathbf {a} _{n}-t\eta _{n}\mathbf {p} _{n})-\nabla f(\mathbf {a} _{n})\|_{2}\approx \|t\eta _{n}\nabla ^{2}f(\mathbf {a} _{n})\mathbf {p} _{n}\|.} Then choose p n {\displaystyle \mathbf {p} _{n}} and η η n {\displaystyle \eta _{n}} by optimising inequality ( 1 ).

Assuming that ∇ ∇ f {\displaystyle \nabla f} is Lipschitz , use its Lipschitz constant L {\displaystyle L} to bound ‖ ‖ ∇ ∇ f ( a n − − t η η n p n ) − − ∇ ∇ f ( a n ) ‖ ‖ 2 ≤ ≤ L t η η n ‖ ‖ p n ‖ ‖ .

{\displaystyle \|\nabla f(\mathbf {a} _{n}-t\eta _{n}\mathbf {p} _{n})-\nabla f(\mathbf {a} _{n})\|_{2}\leq Lt\eta _{n}\|\mathbf {p} _{n}\|.} Then choose p n {\displaystyle \mathbf {p} _{n}} and η η n {\displaystyle \eta _{n}} by optimising inequality ( 1 ).

Build a custom model of max t ∈ ∈ [ 0 , 1 ] ‖ ‖ ∇ ∇ f ( a n − − t η η n p n ) − − ∇ ∇ f ( a n ) ‖ ‖ 2 ‖ ‖ ∇ ∇ f ( a n ) ‖ ‖ 2 {\displaystyle \max _{t\in [0,1]}{\frac {\|\nabla f(\mathbf {a} _{n}-t\eta _{n}\mathbf {p} _{n})-\nabla f(\mathbf {a} _{n})\|_{2}}{\|\nabla f(\mathbf {a} _{n})\|_{2}}}} for f {\displaystyle f} . Then choose p n {\displaystyle \mathbf {p} _{n}} and η η n {\displaystyle \eta _{n}} by optimising inequality ( 1 ).

Under stronger assumptions on the function f {\displaystyle f} such as convexity , more advanced techniques may be possible.

Usually by following one of the recipes above, convergence to a local minimum can be guaranteed. When the function f {\displaystyle f} is convex , all local minima are also global minima, so in this case gradient descent can converge to the global solution.

Solution of a linear system [ edit ] The steepest descent algorithm applied to the Wiener filter [ 12 ] Gradient descent can be used to solve a system of linear equations A x − − b = 0 {\displaystyle \mathbf {A} \mathbf {x} -\mathbf {b} =0} reformulated as a quadratic minimization problem.
If the system matrix A {\displaystyle \mathbf {A} } is real symmetric and positive-definite , an objective function is defined as the quadratic function, with minimization of f ( x ) = x ⊤ ⊤ A x − − 2 x ⊤ ⊤ b , {\displaystyle f(\mathbf {x} )=\mathbf {x} ^{\top }\mathbf {A} \mathbf {x} -2\mathbf {x} ^{\top }\mathbf {b} ,} so that ∇ ∇ f ( x ) = 2 ( A x − − b ) .

{\displaystyle \nabla f(\mathbf {x} )=2(\mathbf {A} \mathbf {x} -\mathbf {b} ).} For a general real matrix A {\displaystyle \mathbf {A} } , linear least squares define f ( x ) = ‖ A x − − b ‖ 2 .

{\displaystyle f(\mathbf {x} )=\left\|\mathbf {A} \mathbf {x} -\mathbf {b} \right\|^{2}.} In traditional linear least squares for real A {\displaystyle \mathbf {A} } and b {\displaystyle \mathbf {b} } the Euclidean norm is used, in which case ∇ ∇ f ( x ) = 2 A ⊤ ⊤ ( A x − − b ) .

{\displaystyle \nabla f(\mathbf {x} )=2\mathbf {A} ^{\top }(\mathbf {A} \mathbf {x} -\mathbf {b} ).} The line search minimization, finding the locally optimal step size η η {\displaystyle \eta } on every iteration, can be performed analytically for quadratic functions, and explicit formulas for the locally optimal η η {\displaystyle \eta } are known.

[ 6 ] [ 13 ] For example, for real symmetric and positive-definite matrix A {\displaystyle \mathbf {A} } , a simple algorithm can be as follows, [ 6 ] repeat in the loop: r := b − − A x η η := r ⊤ ⊤ r / r ⊤ ⊤ A r x := x + η η r if r ⊤ ⊤ r is sufficiently small, then exit loop end repeat loop return x as the result {\displaystyle {\begin{aligned}&{\text{repeat in the loop:}}\\&\qquad \mathbf {r} :=\mathbf {b} -\mathbf {Ax} \\&\qquad \eta :={\mathbf {r} ^{\top }\mathbf {r} }/{\mathbf {r} ^{\top }\mathbf {Ar} }\\&\qquad \mathbf {x} :=\mathbf {x} +\eta \mathbf {r} \\&\qquad {\hbox{if }}\mathbf {r} ^{\top }\mathbf {r} {\text{ is sufficiently small, then exit loop}}\\&{\text{end repeat loop}}\\&{\text{return }}\mathbf {x} {\text{ as the result}}\end{aligned}}} To avoid multiplying by A {\displaystyle \mathbf {A} } twice per iteration,
we note that x := x + η η r {\displaystyle \mathbf {x} :=\mathbf {x} +\eta \mathbf {r} } implies r := r − − η η A r {\displaystyle \mathbf {r} :=\mathbf {r} -\eta \mathbf {Ar} } , which gives the traditional algorithm, [ 14 ] r := b − − A x repeat in the loop: η η := r ⊤ ⊤ r / r ⊤ ⊤ A r x := x + η η r if r ⊤ ⊤ r is sufficiently small, then exit loop r := r − − η η A r end repeat loop return x as the result {\displaystyle {\begin{aligned}&\mathbf {r} :=\mathbf {b} -\mathbf {Ax} \\&{\text{repeat in the loop:}}\\&\qquad \eta :={\mathbf {r} ^{\top }\mathbf {r} }/{\mathbf {r} ^{\top }\mathbf {Ar} }\\&\qquad \mathbf {x} :=\mathbf {x} +\eta \mathbf {r} \\&\qquad {\hbox{if }}\mathbf {r} ^{\top }\mathbf {r} {\text{ is sufficiently small, then exit loop}}\\&\qquad \mathbf {r} :=\mathbf {r} -\eta \mathbf {Ar} \\&{\text{end repeat loop}}\\&{\text{return }}\mathbf {x} {\text{ as the result}}\end{aligned}}} The method is rarely used for solving linear equations, with the conjugate gradient method being one of the most popular alternatives. The number of gradient descent iterations is commonly proportional to the spectral condition number κ κ ( A ) {\displaystyle \kappa (\mathbf {A} )} of the system matrix A {\displaystyle \mathbf {A} } (the ratio of the maximum to minimum eigenvalues of A ⊤ ⊤ A {\displaystyle \mathbf {A} ^{\top }\mathbf {A} } ) , while the convergence of conjugate gradient method is typically determined by a square root of the condition number, i.e., is much faster. Both methods can benefit from preconditioning , where gradient descent may require less assumptions on the preconditioner.

[ 14 ] Geometric behavior and residual orthogonality [ edit ] In steepest descent applied to solving A x = b {\displaystyle \mathbf {Ax} =\mathbf {b} } , where A {\displaystyle \mathbf {A} } is symmetric positive-definite, the residual vectors r k = b − − A x k {\displaystyle \mathbf {r} _{k}=\mathbf {b} -\mathbf {A} \mathbf {x} _{k}} are orthogonal across iterations: ⟨ ⟨ r k + 1 , r k ⟩ ⟩ = 0.

{\displaystyle \langle \mathbf {r} _{k+1},\mathbf {r} _{k}\rangle =0.} Because each step is taken in the steepest direction, steepest-descent steps alternate between directions aligned with the extreme axes of the elongated level sets.  When κ κ ( A ) {\displaystyle \kappa (\mathbf {A} )} is large, this produces a characteristic zig–zag path. The poor conditioning of A {\displaystyle \mathbf {A} } is the primary cause of the slow convergence, and orthogonality of successive residuals reinforces this alternation.

Convergence path of steepest descent method for A = [[2, 2], [2, 3]] As shown in the image on the right, steepest descent converges slowly due to the high condition number of A {\displaystyle \mathbf {A} } , and the orthogonality of residuals forces each new direction to undo the overshoot from the previous step. The result is a path that zigzags toward the solution. This inefficiency is one reason conjugate gradient or preconditioning methods are preferred.

[ 15 ] Solution of a non-linear system [ edit ] Gradient descent can also be used to solve a system of nonlinear equations . Below is an example that shows how to use the gradient descent to solve for three unknown variables, x 1 , x 2 , and x 3 . This example shows one iteration of the gradient descent.

Consider the nonlinear system of equations { 3 x 1 − − cos ⁡ ⁡ ( x 2 x 3 ) − − 3 2 = 0 4 x 1 2 − − 625 x 2 2 + 2 x 2 − − 1 = 0 exp ⁡ ⁡ ( − − x 1 x 2 ) + 20 x 3 + 10 π π − − 3 3 = 0 {\displaystyle {\begin{cases}3x_{1}-\cos(x_{2}x_{3})-{\tfrac {3}{2}}=0\\4x_{1}^{2}-625x_{2}^{2}+2x_{2}-1=0\\\exp(-x_{1}x_{2})+20x_{3}+{\tfrac {10\pi -3}{3}}=0\end{cases}}} Let us introduce the associated function G ( x ) = [ 3 x 1 − − cos ⁡ ⁡ ( x 2 x 3 ) − − 3 2 4 x 1 2 − − 625 x 2 2 + 2 x 2 − − 1 exp ⁡ ⁡ ( − − x 1 x 2 ) + 20 x 3 + 10 π π − − 3 3 ] , {\displaystyle G(\mathbf {x} )={\begin{bmatrix}3x_{1}-\cos(x_{2}x_{3})-{\tfrac {3}{2}}\\4x_{1}^{2}-625x_{2}^{2}+2x_{2}-1\\\exp(-x_{1}x_{2})+20x_{3}+{\tfrac {10\pi -3}{3}}\\\end{bmatrix}},} where x = [ x 1 x 2 x 3 ] .

{\displaystyle \mathbf {x} ={\begin{bmatrix}x_{1}\\x_{2}\\x_{3}\\\end{bmatrix}}.} One might now define the objective function f ( x ) = 1 2 G ⊤ ⊤ ( x ) G ( x ) = 1 2 [ ( 3 x 1 − − cos ⁡ ⁡ ( x 2 x 3 ) − − 3 2 ) 2 + ( 4 x 1 2 − − 625 x 2 2 + 2 x 2 − − 1 ) 2 + ( exp ⁡ ⁡ ( − − x 1 x 2 ) + 20 x 3 + 10 π π − − 3 3 ) 2 ] , {\displaystyle {\begin{aligned}f(\mathbf {x} )&={\frac {1}{2}}G^{\top }(\mathbf {x} )G(\mathbf {x} )\\&={\frac {1}{2}}\left[\left(3x_{1}-\cos(x_{2}x_{3})-{\frac {3}{2}}\right)^{2}+\left(4x_{1}^{2}-625x_{2}^{2}+2x_{2}-1\right)^{2}+\right.\\&{}\qquad \left.\left(\exp(-x_{1}x_{2})+20x_{3}+{\frac {10\pi -3}{3}}\right)^{2}\right],\end{aligned}}} which we will attempt to minimize. As an initial guess, let us use x ( 0 ) = 0 = [ 0 0 0 ] .

{\displaystyle \mathbf {x} ^{(0)}=\mathbf {0} ={\begin{bmatrix}0\\0\\0\\\end{bmatrix}}.} We know that x ( 1 ) = 0 − − η η 0 ∇ ∇ f ( 0 ) = 0 − − η η 0 J G ( 0 ) ⊤ ⊤ G ( 0 ) , {\displaystyle \mathbf {x} ^{(1)}=\mathbf {0} -\eta _{0}\nabla f(\mathbf {0} )=\mathbf {0} -\eta _{0}J_{G}(\mathbf {0} )^{\top }G(\mathbf {0} ),} where the Jacobian matrix J G {\displaystyle J_{G}} is given by J G ( x ) = [ 3 sin ⁡ ⁡ ( x 2 x 3 ) x 3 sin ⁡ ⁡ ( x 2 x 3 ) x 2 8 x 1 − − 1250 x 2 + 2 0 − − x 2 exp ⁡ ⁡ ( − − x 1 x 2 ) − − x 1 exp ⁡ ⁡ ( − − x 1 x 2 ) 20 ] .

{\displaystyle J_{G}(\mathbf {x} )={\begin{bmatrix}3&\sin(x_{2}x_{3})x_{3}&\sin(x_{2}x_{3})x_{2}\\8x_{1}&-1250x_{2}+2&0\\-x_{2}\exp {(-x_{1}x_{2})}&-x_{1}\exp(-x_{1}x_{2})&20\\\end{bmatrix}}.} We calculate: J G ( 0 ) = [ 3 0 0 0 2 0 0 0 20 ] , G ( 0 ) = [ − − 2.5 − − 1 10.472 ] .

{\displaystyle J_{G}(\mathbf {0} )={\begin{bmatrix}3&0&0\\0&2&0\\0&0&20\end{bmatrix}},\qquad G(\mathbf {0} )={\begin{bmatrix}-2.5\\-1\\10.472\end{bmatrix}}.} Thus x ( 1 ) = 0 − − η η 0 [ − − 7.5 − − 2 209.44 ] , {\displaystyle \mathbf {x} ^{(1)}=\mathbf {0} -\eta _{0}{\begin{bmatrix}-7.5\\-2\\209.44\end{bmatrix}},} and f ( 0 ) = 0.5 ( ( − − 2.5 ) 2 + ( − − 1 ) 2 + ( 10.472 ) 2 ) = 58.456.

{\displaystyle f(\mathbf {0} )=0.5\left((-2.5)^{2}+(-1)^{2}+(10.472)^{2}\right)=58.456.} An animation showing the first 83 iterations of gradient descent applied to this example. Surfaces are isosurfaces of f ( x ( n ) ) {\displaystyle f(\mathbf {x} ^{(n)})} at current guess x ( n ) {\displaystyle \mathbf {x} ^{(n)}} , and arrows show the direction of descent. Due to a small and constant step size, the convergence is slow.

Now, a suitable η η 0 {\displaystyle \eta _{0}} must be found such that f ( x ( 1 ) ) ≤ ≤ f ( x ( 0 ) ) = f ( 0 ) .

{\displaystyle f\left(\mathbf {x} ^{(1)}\right)\leq f\left(\mathbf {x} ^{(0)}\right)=f(\mathbf {0} ).} This can be done with any of a variety of line search algorithms. One might also simply guess η η 0 = 0.001 , {\displaystyle \eta _{0}=0.001,} which gives x ( 1 ) = [ 0.0075 0.002 − − 0.20944 ] .

{\displaystyle \mathbf {x} ^{(1)}={\begin{bmatrix}0.0075\\0.002\\-0.20944\\\end{bmatrix}}.} Evaluating the objective function at this value, yields f ( x ( 1 ) ) = 0.5 ( ( − − 2.48 ) 2 + ( − − 1.00 ) 2 + ( 6.28 ) 2 ) = 23.306.

{\displaystyle f\left(\mathbf {x} ^{(1)}\right)=0.5\left((-2.48)^{2}+(-1.00)^{2}+(6.28)^{2}\right)=23.306.} The decrease from f ( 0 ) = 58.456 {\displaystyle f(\mathbf {0} )=58.456} to the next step's value of f ( x ( 1 ) ) = 23.306 {\displaystyle f\left(\mathbf {x} ^{(1)}\right)=23.306} is a sizable decrease in the objective function. Further steps would reduce its value further until an approximate solution to the system was found.

Comments [ edit ] Gradient descent works in spaces of any number of dimensions, even in infinite-dimensional ones. In the latter case, the search space is typically a function space , and one calculates the Fréchet derivative of the functional to be minimized to determine the descent direction.

[ 7 ] That gradient descent works in any number of dimensions (finite number at least) can be seen as a consequence of the Cauchy–Schwarz inequality , i.e. the magnitude of the inner (dot) product of two vectors of any dimension is maximized when they are colinear . In the case of gradient descent, that would be when the vector of independent variable adjustments is proportional to the gradient vector of partial derivatives.

The gradient descent can take many iterations to compute a local minimum with a required accuracy , if the curvature in different directions is very different for the given function. For such functions, preconditioning , which changes the geometry of the space to shape the function level sets like concentric circles , cures the slow convergence. Constructing and applying preconditioning can be computationally expensive, however.

The gradient descent can be modified via momentums [ 16 ] ( Nesterov , Polyak, [ 17 ] and Frank–Wolfe [ 18 ] ) and heavy-ball parameters (exponential moving averages [ 19 ] and positive-negative momentum [ 20 ] ). The main examples of such optimizers are Adam, DiffGrad, Yogi, AdaBelief, etc.

Methods based on Newton's method and inversion of the Hessian using conjugate gradient techniques can be better alternatives.

[ 21 ] [ 22 ] Generally, such methods converge in fewer iterations, but the cost of each iteration is higher. An example is the BFGS method which consists in calculating on every step a matrix by which the gradient vector is multiplied to go into a "better" direction, combined with a more sophisticated line search algorithm, to find the "best" value of η η .

{\displaystyle \eta .} For extremely large problems, where the computer-memory issues dominate, a limited-memory method such as L-BFGS should be used instead of BFGS or the steepest descent.

While it is sometimes possible to substitute gradient descent for a local search algorithm, gradient descent is not in the same family: although it is an iterative method for local optimization , it relies on an objective function’s gradient rather than an explicit exploration of a solution space .

Gradient descent can be viewed as applying Euler's method for solving ordinary differential equations x ′ ( t ) = − − ∇ ∇ f ( x ( t ) ) {\displaystyle x'(t)=-\nabla f(x(t))} to a gradient flow .  In turn, this equation may be derived as an optimal controller [ 23 ] for the control system x ′ ( t ) = u ( t ) {\displaystyle x'(t)=u(t)} with u ( t ) {\displaystyle u(t)} given in feedback form u ( t ) = − − ∇ ∇ f ( x ( t ) ) {\displaystyle u(t)=-\nabla f(x(t))} .

Modifications [ edit ] Gradient descent can converge to a local minimum and slow down in a neighborhood of a saddle point . Even for unconstrained quadratic minimization, gradient descent develops a zig–zag pattern of subsequent iterates as iterations progress, resulting in slow convergence. Multiple modifications of gradient descent have been proposed to address these deficiencies.

Fast gradient methods [ edit ] Yurii Nesterov has proposed [ 24 ] a simple modification that enables faster convergence for convex problems and has been since further generalized. For unconstrained smooth problems, the method is called the fast gradient method (FGM) or the accelerated gradient method (AGM). Specifically, if the differentiable function f {\displaystyle f} is convex and ∇ ∇ f {\displaystyle \nabla f} is Lipschitz , and it is not assumed that f {\displaystyle f} is strongly convex , then the error in the objective value generated at each step k {\displaystyle k} by the gradient descent method will be bounded by O ( k − − 1 ) {\textstyle {\mathcal {O}}\left({k^{-1}}\right)} . Using the Nesterov acceleration technique, the error decreases at O ( k − − 2 ) {\textstyle {\mathcal {O}}\left({k^{-2}}\right)} .

[ 25 ] [ 26 ] It is known that the rate O ( k − − 2 ) {\displaystyle {\mathcal {O}}\left({k^{-2}}\right)} for the decrease of the cost function is optimal for first-order optimization methods. Nevertheless, there is the opportunity to improve the algorithm by reducing the constant factor. The optimized gradient method (OGM) [ 27 ] reduces that constant by a factor of two and is an optimal first-order method for large-scale problems.

[ 28 ] For constrained or non-smooth problems, Nesterov's FGM is called the fast proximal gradient method (FPGM), an acceleration of the proximal gradient method .

Momentum or heavy ball method [ edit ] Trying to break the zig-zag pattern of gradient descent, the momentum or heavy ball method uses a momentum term in analogy to a heavy ball sliding on the surface of values of the function being minimized, [ 6 ] or to mass movement in Newtonian dynamics through a viscous medium in a conservative force field.

[ 29 ] Gradient descent with momentum remembers the solution update at each iteration, and determines the next update as a linear combination of the gradient and the previous update. For unconstrained quadratic minimization, a theoretical convergence rate bound of the heavy ball method is asymptotically the same as that for the optimal conjugate gradient method .

[ 6 ] This technique is used in stochastic gradient descent and as an extension to the backpropagation algorithms used to train artificial neural networks .

[ 30 ] [ 31 ] In the direction of updating, stochastic gradient descent adds a stochastic property. The weights can be used to calculate the derivatives.

Extensions [ edit ] Gradient descent can be extended to handle constraints by including a projection onto the set of constraints. This method is only feasible when the projection is efficiently computable on a computer. Under suitable assumptions, this method converges.  This method is a specific case of the forward–backward algorithm for monotone inclusions (which includes convex programming and variational inequalities ).

[ 32 ] Gradient descent is a special case of mirror descent using the squared Euclidean distance as the given Bregman divergence .

[ 33 ] Theoretical properties [ edit ] The properties of gradient descent depend on the properties of the objective function and the variant of gradient descent used (for example, if a line search step is used). The assumptions made affect the convergence rate, and other properties, that can be proven for gradient descent.

[ 34 ] For example, if the objective is assumed to be strongly convex and lipschitz smooth , then gradient descent converges linearly with a fixed step size.

[ 1 ] Looser assumptions lead to either weaker convergence guarantees or require a more sophisticated step size selection.

[ 34 ] See also [ edit ] Backtracking line search Conjugate gradient method Stochastic gradient descent Rprop Delta rule Wolfe conditions Preconditioning Broyden–Fletcher–Goldfarb–Shanno algorithm Davidon–Fletcher–Powell formula Nelder–Mead method Gauss–Newton algorithm Hill climbing Quantum annealing CLS (continuous local search) Neuroevolution References [ edit ] ^ a b Boyd, Stephen; Vandenberghe, Lieven (2004-03-08).

Convex Optimization . Cambridge University Press.

doi : 10.1017/cbo9780511804441 .

ISBN 978-0-521-83378-3 .

^ Lemaréchal, C. (1 January 2012).

"Cauchy and the gradient method" (PDF) . In Grötschel, M. (ed.).

Optimization Stories . Documenta Mathematica Series. Vol. 6 (1st ed.). EMS Press. pp.

251– 254.

doi : 10.4171/dms/6/27 .

ISBN 978-3-936609-58-5 . Archived from the original (PDF) on 2018-12-29 . Retrieved 2020-01-26 .

^ Hadamard, Jacques (1908). "Mémoire sur le problème d'analyse relatif à l'équilibre des plaques élastiques encastrées".

Mémoires présentés par divers savants éstrangers à l'Académie des Sciences de l'Institut de France .

33 .

^ Courant, R. (1943).

"Variational methods for the solution of problems of equilibrium and vibrations" .

Bulletin of the American Mathematical Society .

49 (1): 1– 23.

doi : 10.1090/S0002-9904-1943-07818-4 .

^ Curry, Haskell B. (1944).

"The Method of Steepest Descent for Non-linear Minimization Problems" .

Quart. Appl. Math .

2 (3): 258– 261.

doi : 10.1090/qam/10667 .

^ a b c d e Polyak, Boris (1987).

Introduction to Optimization .

^ a b Akilov, G. P.; Kantorovich, L. V.

(1982).

Functional Analysis (2nd ed.). Pergamon Press.

ISBN 0-08-023036-9 .

^ Barzilai, Jonathan; Borwein, Jonathan M. (1988). "Two-Point Step Size Gradient Methods".

IMA Journal of Numerical Analysis .

8 (1): 141– 148.

doi : 10.1093/imanum/8.1.141 .

^ Fletcher, R. (2005). "On the Barzilai–Borwein Method". In Qi, L.; Teo, K.; Yang, X. (eds.).

Optimization and Control with Applications . Applied Optimization. Vol. 96. Boston: Springer. pp.

235– 256.

ISBN 0-387-24254-6 .

^ Wolfe, Philip (April 1969). "Convergence Conditions for Ascent Methods".

SIAM Review .

11 (2): 226– 235.

doi : 10.1137/1011036 .

^ Bernstein, Jeremy; Vahdat, Arash; Yue, Yisong; Liu, Ming-Yu (2020-06-12). "On the distance between two neural networks and the stability of learning".

arXiv : 2002.03432 [ cs.LG ].

^ Haykin, Simon S. Adaptive filter theory. Pearson Education India, 2008. - p. 108-142, 217-242 ^ Saad, Yousef (2003).

Iterative methods for sparse linear systems (2nd ed.). Philadelphia, Pa.: Society for Industrial and Applied Mathematics. pp.

195 .

ISBN 978-0-89871-534-7 .

^ a b Bouwmeester, Henricus; Dougherty, Andrew; Knyazev, Andrew V. (2015).

"Nonsymmetric Preconditioning for Conjugate Gradient and Steepest Descent Methods" .

Procedia Computer Science .

51 : 276– 285.

arXiv : 1212.6680 .

doi : 10.1016/j.procs.2015.05.241 .

^ Holmes, M. (2023).

Introduction to Scientific Computing and Data Analysis, 2nd Ed . Springer.

ISBN 978-3-031-22429-4 .

^ Abdulkadirov, Ruslan; Lyakhov, Pavel; Nagornov, Nikolay (January 2023).

"Survey of Optimization Algorithms in Modern Neural Networks" .

Mathematics .

11 (11): 2466.

doi : 10.3390/math11112466 .

ISSN 2227-7390 .

^ Diakonikolas, Jelena; Jordan, Michael I. (January 2021).

"Generalized Momentum-Based Methods: A Hamiltonian Perspective" .

SIAM Journal on Optimization .

31 (1): 915– 944.

arXiv : 1906.00436 .

doi : 10.1137/20M1322716 .

ISSN 1052-6234 .

^ Meyer, Gerard G. L. (November 1974).

"Accelerated Frank–Wolfe Algorithms" .

SIAM Journal on Control .

12 (4): 655– 663.

doi : 10.1137/0312050 .

ISSN 0036-1402 .

^ Kingma, Diederik P.; Ba, Jimmy (2017-01-29), Adam: A Method for Stochastic Optimization , arXiv : 1412.6980 ^ Xie, Zeke; Yuan, Li; Zhu, Zhanxing; Sugiyama, Masashi (2021-07-01).

"Positive-Negative Momentum: Manipulating Stochastic Gradient Noise to Improve Generalization" .

Proceedings of the 38th International Conference on Machine Learning . PMLR: 11448– 11458.

arXiv : 2103.17182 .

^ Press, W. H.

; Teukolsky, S. A.

; Vetterling, W. T.; Flannery, B. P.

(1992).

Numerical Recipes in C: The Art of Scientific Computing (2nd ed.). New York: Cambridge University Press .

ISBN 0-521-43108-5 .

^ Strutz, T. (2016).

Data Fitting and Uncertainty: A Practical Introduction to Weighted Least Squares and Beyond (2nd ed.). Springer Vieweg.

ISBN 978-3-658-11455-8 .

^ Ross, I.M. (July 2019).

"An optimal control theory for nonlinear optimization" .

Journal of Computational and Applied Mathematics .

354 : 39– 51.

doi : 10.1016/j.cam.2018.12.044 .

S2CID 127649426 .

^ Nesterov, Yurii (2004).

Introductory Lectures on Convex Optimization : A Basic Course . Springer.

ISBN 1-4020-7553-7 .

^ Vandenberghe, Lieven (2019).

"Fast Gradient Methods" (PDF) .

Lecture notes for EE236C at UCLA .

^ Walkington, Noel J. (2023).

"Nesterov's Method for Convex Optimization" .

SIAM Review .

65 (2): 539– 562.

doi : 10.1137/21M1390037 .

ISSN 0036-1445 .

^ Kim, D.; Fessler, J. A. (2016).

"Optimized First-order Methods for Smooth Convex Minimization" .

Mathematical Programming .

151 ( 1– 2): 81– 107.

arXiv : 1406.5468 .

doi : 10.1007/s10107-015-0949-3 .

PMC 5067109 .

PMID 27765996 .

S2CID 207055414 .

^ Drori, Yoel (2017). "The Exact Information-based Complexity of Smooth Convex Minimization".

Journal of Complexity .

39 : 1– 16.

arXiv : 1606.01424 .

doi : 10.1016/j.jco.2016.11.001 .

S2CID 205861966 .

^ Qian, Ning (January 1999). "On the momentum term in gradient descent learning algorithms".

Neural Networks .

12 (1): 145– 151.

CiteSeerX 10.1.1.57.5612 .

doi : 10.1016/S0893-6080(98)00116-6 .

PMID 12662723 .

S2CID 2783597 .

^ "Momentum and Learning Rate Adaptation" .

Willamette University . Retrieved 17 October 2014 .

^ Geoffrey Hinton ; Nitish Srivastava; Kevin Swersky.

"The momentum method" .

Coursera . Retrieved 2 October 2018 .

Part of a lecture series for the Coursera online course Neural Networks for Machine Learning Archived 2016-12-31 at the Wayback Machine .

^ Combettes, P. L.; Pesquet, J.-C. (2011). "Proximal splitting methods in signal processing". In Bauschke, H. H.; Burachik, R. S.

; Combettes, P. L.; Elser, V.; Luke, D. R.; Wolkowicz, H. (eds.).

Fixed-Point Algorithms for Inverse Problems in Science and Engineering . New York: Springer. pp.

185– 212.

arXiv : 0912.3522 .

ISBN 978-1-4419-9568-1 .

^ "Mirror descent algorithm" .

^ a b Bubeck, Sébastien (2015). "Convex Optimization: Algorithms and Complexity".

arXiv : 1405.4980 [ math.OC ].

Further reading [ edit ] Boyd, Stephen ; Vandenberghe, Lieven (2004).

"Unconstrained Minimization" (PDF) .

Convex Optimization . New York: Cambridge University Press. pp.

457– 520.

ISBN 0-521-83378-7 .

Chong, Edwin K. P.; Żak, Stanislaw H. (2013).

"Gradient Methods" .

An Introduction to Optimization (Fourth ed.). Hoboken: Wiley. pp.

131– 160.

ISBN 978-1-118-27901-4 .

Himmelblau, David M. (1972). "Unconstrained Minimization Procedures Using Derivatives".

Applied Nonlinear Programming . New York: McGraw-Hill. pp.

63– 132.

ISBN 0-07-028921-2 .

External links [ edit ] Wikimedia Commons has media related to Gradient descent .

Using gradient descent in C++, Boost, Ublas for linear regression Series of Khan Academy videos discusses gradient ascent Online book teaching gradient descent in deep neural network context Archived at Ghostarchive and the Wayback Machine : "Gradient Descent, How Neural Networks Learn" .

3Blue1Brown . October 16, 2017 – via YouTube .

Garrigos, Guillaume; Gower, Robert M. (2023). "Handbook of Convergence Theorems for (Stochastic) Gradient Methods".

arXiv : 2301.11235 [ math.OC ].

v t e Artificial intelligence (AI) History timeline Companies Projects Concepts Parameter Hyperparameter Loss functions Regression Bias–variance tradeoff Double descent Overfitting Clustering Gradient descent SGD Quasi-Newton method Conjugate gradient method Backpropagation Attention Convolution Normalization Batchnorm Activation Softmax Sigmoid Rectifier Gating Weight initialization Regularization Datasets Augmentation Prompt engineering Reinforcement learning Q-learning SARSA Imitation Policy gradient Diffusion Latent diffusion model Autoregression Adversary RAG Uncanny valley RLHF Self-supervised learning Reflection Recursive self-improvement Hallucination Word embedding Vibe coding Applications Machine learning In-context learning Artificial neural network Deep learning Language model Large language model NMT Reasoning language model Model Context Protocol Intelligent agent Artificial human companion Humanity's Last Exam Artificial general intelligence (AGI) Implementations Audio–visual AlexNet WaveNet Human image synthesis HWR OCR Computer vision Speech synthesis 15.ai ElevenLabs Speech recognition Whisper Facial recognition AlphaFold Text-to-image models Aurora DALL-E Firefly Flux Ideogram Imagen Midjourney Recraft Stable Diffusion Text-to-video models Dream Machine Runway Gen Hailuo AI Kling Sora Veo Music generation Riffusion Suno AI Udio Text Word2vec Seq2seq GloVe BERT T5 Llama Chinchilla AI PaLM GPT 1 2 3 J ChatGPT 4 4o o1 o3 4.5 4.1 o4-mini 5 Claude Gemini chatbot Grok LaMDA BLOOM DBRX Project Debater IBM Watson IBM Watsonx Granite PanGu-Σ DeepSeek Qwen Decisional AlphaGo AlphaZero OpenAI Five Self-driving car MuZero Action selection AutoGPT Robot control People Alan Turing Warren Sturgis McCulloch Walter Pitts John von Neumann Claude Shannon Shun'ichi Amari Kunihiko Fukushima Takeo Kanade Marvin Minsky John McCarthy Nathaniel Rochester Allen Newell Cliff Shaw Herbert A. Simon Oliver Selfridge Frank Rosenblatt Bernard Widrow Joseph Weizenbaum Seymour Papert Seppo Linnainmaa Paul Werbos Geoffrey Hinton John Hopfield Jürgen Schmidhuber Yann LeCun Yoshua Bengio Lotfi A. Zadeh Stephen Grossberg Alex Graves James Goodnight Andrew Ng Fei-Fei Li Alex Krizhevsky Ilya Sutskever Oriol Vinyals Quoc V. Le Ian Goodfellow Demis Hassabis David Silver Andrej Karpathy Ashish Vaswani Noam Shazeer Aidan Gomez John Schulman Mustafa Suleyman Jan Leike Daniel Kokotajlo François Chollet Architectures Neural Turing machine Differentiable neural computer Transformer Vision transformer (ViT) Recurrent neural network (RNN) Long short-term memory (LSTM) Gated recurrent unit (GRU) Echo state network Multilayer perceptron (MLP) Convolutional neural network (CNN) Residual neural network (RNN) Highway network Mamba Autoencoder Variational autoencoder (VAE) Generative adversarial network (GAN) Graph neural network (GNN) Category v t e Optimization : Algorithms , methods , and heuristics Unconstrained nonlinear Functions Golden-section search Powell's method Line search Nelder–Mead method Successive parabolic interpolation Gradients Convergence Trust region Wolfe conditions Quasi–Newton Berndt–Hall–Hall–Hausman Broyden–Fletcher–Goldfarb–Shanno and L-BFGS Davidon–Fletcher–Powell Symmetric rank-one (SR1) Other methods Conjugate gradient Gauss–Newton Gradient Mirror Levenberg–Marquardt Powell's dog leg method Truncated Newton Hessians Newton's method Optimization computes maxima and minima.

Constrained nonlinear General Barrier methods Penalty methods Differentiable Augmented Lagrangian methods Sequential quadratic programming Successive linear programming Convex optimization Convex minimization Cutting-plane method Reduced gradient (Frank–Wolfe) Subgradient method Linear and quadratic Interior point Affine scaling Ellipsoid algorithm of Khachiyan Projective algorithm of Karmarkar Basis- exchange Simplex algorithm of Dantzig Revised simplex algorithm Criss-cross algorithm Principal pivoting algorithm of Lemke Active-set method Combinatorial Paradigms Approximation algorithm Dynamic programming Greedy algorithm Integer programming Branch and bound / cut Graph algorithms Minimum spanning tree Borůvka Prim Kruskal Shortest path Bellman–Ford SPFA Dijkstra Floyd–Warshall Network flows Dinic Edmonds–Karp Ford–Fulkerson Push–relabel maximum flow Metaheuristics Evolutionary algorithm Hill climbing Local search Parallel metaheuristics Simulated annealing Spiral optimization algorithm Tabu search Software Retrieved from " https://en.wikipedia.org/w/index.php?title=Gradient_descent&oldid=1300672032 " Categories : Mathematical optimization First order methods Optimization algorithms and methods Gradient methods Hidden categories: CS1:Vancouver names with accept markup Webarchive template wayback links Articles with short description Short description matches Wikidata Commons category link is on Wikidata This page was last edited on 15 July 2025, at 19:08 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Gradient descent 26 languages Add topic

