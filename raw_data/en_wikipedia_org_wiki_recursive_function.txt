Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Definition 2 Examples 3 Total recursive function 4 Equivalence with other models of computability 5 Normal form theorem 6 Symbolism 7 Examples 8 See also 9 References 10 External links Toggle the table of contents General recursive function 20 languages Català Čeština Deutsch Eesti Ελληνικά Español فارسی Français 한국어 Italiano עברית Nederlands 日本語 Polski Português Русский Српски / srpski Українська 粵語 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia (Redirected from Μ-recursive function ) One of several equivalent definitions of a computable function In mathematical logic and computer science , a general recursive function , partial recursive function , or μ-recursive function is a partial function from natural numbers to natural numbers that is "computable" in an intuitive sense – as well as in a formal one . If the function is total , it is also called a total recursive function (sometimes shortened to recursive function ).

[ 1 ] In computability theory , it is shown that the μ-recursive functions are precisely the functions that can be computed by Turing machines [ 2 ] [ 4 ] (this is one of the theorems that supports the Church–Turing thesis ).  The μ-recursive functions are closely related to primitive recursive functions , and their inductive definition (below) builds upon that of the primitive recursive functions. However, not every total recursive function is a primitive recursive function—the most famous example is the Ackermann function .

Other equivalent classes of functions are the functions of lambda calculus and the functions that can be computed by Markov algorithms .

The subset of all total recursive functions with values in {0,1} is known in computational complexity theory as the complexity class R .

Definition [ edit ] The μ-recursive functions (or general recursive functions ) are partial functions that take finite tuples of natural numbers and return a single natural number.  They are the smallest class of partial functions that includes the initial functions and is closed under composition, primitive recursion, and the minimization operator μ .

The smallest class of functions including the initial functions and closed under composition and primitive recursion (i.e. without minimisation) is the class of primitive recursive functions .  While all primitive recursive functions are total, this is not true of partial recursive functions; for example, the minimisation of the successor function is undefined. The primitive recursive functions are a subset of the total recursive functions, which are a subset of the partial recursive functions. For example, the Ackermann function can be proven to be total recursive, and to be non-primitive.

Primitive or "basic" functions: Constant functions C k n : For each natural number n and every k C n k ( x 1 , … … , x k ) = d e f n {\displaystyle C_{n}^{k}(x_{1},\ldots ,x_{k})\ {\stackrel {\mathrm {def} }{=}}\ n} Alternative definitions use instead a zero function as a primitive function that always returns zero, and build the constant functions from the zero function, the successor function and the composition operator.

Successor function S: S ( x ) = d e f x + 1 {\displaystyle S(x)\ {\stackrel {\mathrm {def} }{=}}\ x+1\,} Projection function P i k {\displaystyle P_{i}^{k}} (also called the Identity function ): For all natural numbers i , k {\displaystyle i,k} such that 1 ≤ ≤ i ≤ ≤ k {\displaystyle 1\leq i\leq k} : P i k ( x 1 , … … , x k ) = d e f x i .

{\displaystyle P_{i}^{k}(x_{1},\ldots ,x_{k})\ {\stackrel {\mathrm {def} }{=}}\ x_{i}\,.} Operators (the domain of a function defined by an operator is the set of the values of the arguments such that every function application that must be done during the computation provides a well-defined result): Composition operator ∘ ∘ {\displaystyle \circ \,} (also called the substitution operator ): Given an m-ary function h ( x 1 , … … , x m ) {\displaystyle h(x_{1},\ldots ,x_{m})\,} and m k-ary functions g 1 ( x 1 , … … , x k ) , … … , g m ( x 1 , … … , x k ) {\displaystyle g_{1}(x_{1},\ldots ,x_{k}),\ldots ,g_{m}(x_{1},\ldots ,x_{k})} : h ∘ ∘ ( g 1 , … … , g m ) = d e f f , where f ( x 1 , … … , x k ) = h ( g 1 ( x 1 , … … , x k ) , … … , g m ( x 1 , … … , x k ) ) .

{\displaystyle h\circ (g_{1},\ldots ,g_{m})\ {\stackrel {\mathrm {def} }{=}}\ f,\quad {\text{where}}\quad f(x_{1},\ldots ,x_{k})=h(g_{1}(x_{1},\ldots ,x_{k}),\ldots ,g_{m}(x_{1},\ldots ,x_{k})).} This means that f ( x 1 , … … , x k ) {\displaystyle f(x_{1},\ldots ,x_{k})} is defined only if g 1 ( x 1 , … … , x k ) , … … , g m ( x 1 , … … , x k ) , {\displaystyle g_{1}(x_{1},\ldots ,x_{k}),\ldots ,g_{m}(x_{1},\ldots ,x_{k}),} and h ( g 1 ( x 1 , … … , x k ) , … … , g m ( x 1 , … … , x k ) ) {\displaystyle h(g_{1}(x_{1},\ldots ,x_{k}),\ldots ,g_{m}(x_{1},\ldots ,x_{k}))} are all defined.

Primitive recursion operator ρ : Given the k -ary function g ( x 1 , … … , x k ) {\displaystyle g(x_{1},\ldots ,x_{k})\,} and k +2 -ary function h ( y , z , x 1 , … … , x k ) {\displaystyle h(y,z,x_{1},\ldots ,x_{k})\,} : ρ ρ ( g , h ) = d e f f where the k+1 -ary function f is defined by f ( 0 , x 1 , … … , x k ) = g ( x 1 , … … , x k ) f ( S ( y ) , x 1 , … … , x k ) = h ( y , f ( y , x 1 , … … , x k ) , x 1 , … … , x k ) .

{\displaystyle {\begin{aligned}\rho (g,h)&\ {\stackrel {\mathrm {def} }{=}}\ f\quad {\text{where the k+1 -ary function }}f{\text{ is defined by}}\\f(0,x_{1},\ldots ,x_{k})&=g(x_{1},\ldots ,x_{k})\\f(S(y),x_{1},\ldots ,x_{k})&=h(y,f(y,x_{1},\ldots ,x_{k}),x_{1},\ldots ,x_{k})\,.\end{aligned}}} This means that f ( y , x 1 , … … , x k ) {\displaystyle f(y,x_{1},\ldots ,x_{k})} is defined only if g ( x 1 , … … , x k ) {\displaystyle g(x_{1},\ldots ,x_{k})} and h ( z , f ( z , x 1 , … … , x k ) , x 1 , … … , x k ) {\displaystyle h(z,f(z,x_{1},\ldots ,x_{k}),x_{1},\ldots ,x_{k})} are defined for all z < y .

{\displaystyle z<y.} Minimization operator μ : Given a ( k +1)-ary function f ( y , x 1 , … … , x k ) {\displaystyle f(y,x_{1},\ldots ,x_{k})\,} , the k -ary function μ μ ( f ) {\displaystyle \mu (f)} is defined by: μ μ ( f ) ( x 1 , … … , x k ) = z ⟺ ⟺ d e f f ( i , x 1 , … … , x k ) > 0 for i = 0 , … … , z − − 1 and f ( z , x 1 , … … , x k ) = 0 {\displaystyle {\begin{aligned}\mu (f)(x_{1},\ldots ,x_{k})=z{\stackrel {\mathrm {def} }{\iff }}\ f(i,x_{1},\ldots ,x_{k})&>0\quad {\text{for}}\quad i=0,\ldots ,z-1\quad {\text{and}}\\f(z,x_{1},\ldots ,x_{k})&=0\quad \end{aligned}}} Intuitively, minimisation seeks—beginning the search from 0 and proceeding upwards—the smallest argument that causes the function to return zero; if there is no such argument, or if one encounters an argument for which f is not defined, then the search never terminates, and μ μ ( f ) {\displaystyle \mu (f)} is not defined for the argument ( x 1 , … … , x k ) .

{\displaystyle (x_{1},\ldots ,x_{k}).} While some textbooks use the μ-operator as defined here, [ 5 ] [ 6 ] others [ 7 ] [ 8 ] demand that the μ-operator is applied to total functions f only. Although this restricts the μ-operator as compared to the definition given here, the class of μ-recursive functions remains the same, which follows from Kleene's Normal Form Theorem (see below ).

[ 5 ] [ 6 ] The only difference is, that it becomes undecidable whether a specific function definition defines a μ-recursive function, as it is undecidable whether a computable (i.e. μ-recursive) function is total.

[ 7 ] The strong equality relation ≃ ≃ {\displaystyle \simeq } can be used to compare partial μ-recursive functions.  This is defined for all partial functions f and g so that f ( x 1 , … … , x k ) ≃ ≃ g ( x 1 , … … , x l ) {\displaystyle f(x_{1},\ldots ,x_{k})\simeq g(x_{1},\ldots ,x_{l})} holds if and only if for any choice of arguments either both functions are defined and their values are equal or both functions are undefined.

Examples [ edit ] Examples not involving the minimization operator can be found at Primitive recursive function#Examples .

The following examples are intended just to demonstrate the use of the minimization operator;  they could also be defined without it, albeit in a more complicated way, since they are all primitive recursive.

The integer square root of x can be defined as the least z such that ( z + 1 ) 2 > x {\displaystyle (z+1)^{2}>x} . Using the minimization operator, a general recursive definition is Isqrt = μ μ ( Not ∘ ∘ Gt ∘ ∘ ( Mul ∘ ∘ ( S ∘ ∘ P 1 2 , S ∘ ∘ P 1 2 ) , P 2 2 ) ) {\displaystyle \operatorname {Isqrt} =\mu (\operatorname {Not} \circ \operatorname {Gt} \circ (\operatorname {Mul} \circ (S\circ P_{1}^{2},S\circ P_{1}^{2}),P_{2}^{2}))} , where Not , Gt , and Mul are logical negation , greater-than, and multiplication, [ 9 ] respectively. In fact, ( Not ∘ ∘ Gt ∘ ∘ ( Mul ∘ ∘ ( S ∘ ∘ P 1 2 , S ∘ ∘ P 1 2 ) , P 2 2 ) ) ( z , x ) = ( ¬ ¬ S ( z ) ∗ ∗ S ( z ) > x ) {\displaystyle (\operatorname {Not} \circ \operatorname {Gt} \circ (\operatorname {Mul} \circ (S\circ P_{1}^{2},S\circ P_{1}^{2}),P_{2}^{2}))\;(z,x)=(\lnot S(z)*S(z)>x)} is 0 if, and only if, S ( z ) ∗ ∗ S ( z ) > x {\displaystyle S(z)*S(z)>x} holds. Hence Isqrt ⁡ ⁡ ( x ) {\displaystyle \operatorname {Isqrt} (x)} is the least z such that S ( z ) ∗ ∗ S ( z ) > x {\displaystyle S(z)*S(z)>x} holds. The negation junctor Not is needed since Gt encodes truth by 1 , while μ seeks for 0 .

The following examples define general recursive functions that are not primitive recursive; hence they cannot avoid using the minimization operator.

[ example needed ] Total recursive function [ edit ] A general recursive function is called total recursive function if it is defined for every input, or, equivalently, if it can be computed by a total Turing machine . There is no way to computably tell if a given general recursive function is total - see Halting problem .

Equivalence with other models of computability [ edit ] This section needs expansion . You can help by adding to it .

( February 2010 ) In the equivalence of models of computability , a parallel is drawn between Turing machines that do not terminate for certain inputs and an undefined result for that input in the corresponding partial recursive function.
The unbounded search operator is not definable by the rules of primitive recursion as those do not provide a mechanism for "infinite loops" (undefined values).

Normal form theorem [ edit ] A normal form theorem due to Kleene says that for each k there are primitive recursive functions U ( y ) {\displaystyle U(y)\!} and T ( y , e , x 1 , … … , x k ) {\displaystyle T(y,e,x_{1},\ldots ,x_{k})\!} such that for any μ-recursive function f ( x 1 , … … , x k ) {\displaystyle f(x_{1},\ldots ,x_{k})\!} with k free variables there is an e such that f ( x 1 , … … , x k ) ≃ ≃ U ( μ μ ( T ) ( e , x 1 , … … , x k ) ) {\displaystyle f(x_{1},\ldots ,x_{k})\simeq U(\mu (T)(e,x_{1},\ldots ,x_{k}))} .

The number e is called an index or Gödel number for the function f .

[ 10 ] : 52–53 A consequence of this result is that any μ-recursive function can be defined using a single instance of the μ operator applied to a (total) primitive recursive function.

Minsky observes the U {\displaystyle U} defined above is in essence the μ-recursive equivalent of the universal Turing machine : To construct U is to write down the definition of a general-recursive function U(n, x) that correctly interprets the number n and computes the appropriate function of x. to construct U directly would involve essentially the same amount of effort, and essentially the same ideas , as we have invested in constructing the universal Turing machine [ 11 ] Symbolism [ edit ] A number of different symbolisms are used in the literature. An advantage to using the symbolism is a derivation of a function by "nesting" of the operators one inside the other is easier to write in a compact form. In the following the string of parameters x 1 , ..., x n is abbreviated as x : Constant function : Kleene uses " C n q ( x ) = q " and Boolos-Burgess-Jeffrey (2002) (B-B-J) use the abbreviation " const n ( x ) = n ": e.g. C 7 13 ( r, s, t, u, v, w, x ) = 13 e.g. const 13 ( r, s, t, u, v, w, x ) = 13 Successor function : Kleene uses x' and S for "Successor". As "successor" is considered to be primitive, most texts use the apostrophe as follows: S(a) = a +1 = def a', where 1 = def 0', 2 = def 0 ' ', etc.

Identity function : Kleene (1952) uses " U n i " to indicate the identity function over the variables x i ; B-B-J use the identity function id n i over the variables x 1 to x n : U n i ( x ) = id n i ( x ) = x i e.g. U 7 3 = id 7 3 ( r, s, t, u, v, w, x ) = t Composition (Substitution) operator : Kleene uses a bold-face S m n (not to be confused with his S for "successor" !

). The superscript "m" refers to the m th of function "f m ", whereas the subscript "n" refers to the n th variable "x n ": If we are given h( x )= g( f 1 ( x ), ... , f m ( x ) ) h( x ) = S n m (g, f 1 , ... , f m ) In a similar manner, but without the sub- and superscripts, B-B-J write: h( x' )= Cn[g, f 1 ,..., f m ]( x ) Primitive Recursion : Kleene uses the symbol " R n (base step, induction step) " where n indicates the number of variables, B-B-J use " Pr(base step, induction step)( x )". Given: base step: h( 0, x )= f( x ), and induction step: h( y+1, x ) = g( y, h(y, x ), x ) Example: primitive recursion definition of a + b: base step: f( 0, a ) = a = U 1 1 (a) induction step: f( b' , a ) = ( f ( b, a ) )' = g( b, f( b, a), a ) = g( b, c, a ) = c' = S(U 3 2 ( b, c, a )) R 2 { U 1 1 (a), S [ (U 3 2 ( b, c, a ) ] } Pr{ U 1 1 (a), S[ (U 3 2 ( b, c, a ) ] } Example : Kleene gives an example of how to perform the recursive derivation of f(b, a) = b + a (notice reversal of variables a and b). He starts with 3 initial functions S(a) = a' U 1 1 (a) = a U 3 2 ( b, c, a ) = c g(b, c, a) = S(U 3 2 ( b, c, a )) = c' base step: h( 0, a ) = U 1 1 (a) induction step: h( b', a ) = g( b, h( b, a ), a ) He arrives at: a+b = R 2 [ U 1 1 , S 3 1 (S, U 3 2 ) ] Examples [ edit ] Fibonacci number McCarthy 91 function See also [ edit ] Recursion theory Recursion Recursion (computer science) References [ edit ] ^ "Recursive Functions" .

The Stanford Encyclopedia of Philosophy . Metaphysics Research Lab, Stanford University. 2021.

^ Stanford Encyclopedia of Philosophy , Entry Recursive Functions , Sect.1.7: "[The class of μ-recursive functions] turns out to coincide with the class of the Turing-computable functions introduced by Alan Turing as well as with the class of the λ-definable functions introduced by Alonzo Church.

" ^ Kleene, Stephen C.

(1936).

"λ-definability and recursiveness" .

Duke Mathematical Journal .

2 (2): 340– 352.

doi : 10.1215/s0012-7094-36-00227-2 .

^ Turing, Alan Mathison (Dec 1937). "Computability and λ-Definability".

Journal of Symbolic Logic .

2 (4): 153– 163.

doi : 10.2307/2268280 .

JSTOR 2268280 .

S2CID 2317046 .

Proof outline on p.153: λ λ -definable {\displaystyle \lambda {\mbox{-definable}}} ⟹ ⟹ t r i v {\displaystyle {\stackrel {triv}{\implies }}} λ λ - K -definable {\displaystyle \lambda {\mbox{-}}K{\mbox{-definable}}} ⟹ ⟹ 160 {\displaystyle {\stackrel {160}{\implies }}} Turing computable {\displaystyle {\mbox{Turing computable}}} ⟹ ⟹ 161 {\displaystyle {\stackrel {161}{\implies }}} μ μ -recursive {\displaystyle \mu {\mbox{-recursive}}} ⟹ ⟹ K l e e n e {\displaystyle {\stackrel {Kleene}{\implies }}} [ 3 ] λ λ -definable {\displaystyle \lambda {\mbox{-definable}}} ^ a b Enderton, H. B., A Mathematical Introduction to Logic, Academic Press, 1972 ^ a b Boolos, G. S., Burgess, J. P., Jeffrey, R. C., Computability and Logic, Cambridge University Press, 2007 ^ a b Jones, N. D., Computability and Complexity: From a Programming Perspective, The MIT Press, Cambridge, Massachusetts, London, England, 1997 ^ Kfoury, A. J., R. N. Moll, and M. A. Arbib, A Programming Approach to Computability, 2nd ed., Springer-Verlag, Berlin, Heidelberg, New York, 1982 ^ defined in Primitive recursive function#Junctors , Primitive recursive function#Equality predicate , and Primitive recursive function#Multiplication ^ Stephen Cole Kleene (Jan 1943).

"Recursive predicates and quantifiers" (PDF) .

Transactions of the American Mathematical Society .

53 (1): 41– 73.

doi : 10.1090/S0002-9947-1943-0007371-8 .

^ Minsky 1972 , pp. 189.

Kleene, Stephen (1991) [1952].

Introduction to Metamathematics . Walters-Noordhoff & North-Holland.

ISBN 0-7204-2103-9 .

Soare, R. (1999) [1987].

Recursively enumerable sets and degrees: A Study of Computable Functions and Computably Generated Sets . Springer-Verlag.

ISBN 9783540152996 .

Minsky, Marvin L.

(1972) [1967].

Computation: Finite and Infinite Machines . Prentice-Hall. pp.

210– 5.

ISBN 9780131654495 .

On pages 210-215 Minsky shows how to create the μ-operator using the register machine model, thus demonstrating its equivalence to the general recursive functions.

Boolos, George ; Burgess, John ; Jeffrey, Richard (2002).

"6.2 Minimization" .

Computability and Logic (4th ed.). Cambridge University Press. pp.

70– 71.

ISBN 9780521007580 .

External links [ edit ] Stanford Encyclopedia of Philosophy entry A compiler for transforming a recursive function into an equivalent Turing machine Authority control databases National United States France BnF data Latvia Israel Other Yale LUX Retrieved from " https://en.wikipedia.org/w/index.php?title=General_recursive_function&oldid=1303228064 " Categories : Computability theory Theory of computation Hidden categories: Articles with short description Short description matches Wikidata All articles needing examples Articles needing examples from November 2021 Articles to be expanded from February 2010 All articles to be expanded This page was last edited on 29 July 2025, at 19:37 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents General recursive function 20 languages Add topic

