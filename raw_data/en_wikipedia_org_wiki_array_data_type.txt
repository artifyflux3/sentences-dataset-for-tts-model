Title: Array (data type)

URL Source: https://en.wikipedia.org/wiki/Array_data_type

Published Time: 2009-05-16T00:29:25Z

Markdown Content:
This article is about the abstract data type. For the byte-level structure, see [Array data structure](https://en.wikipedia.org/wiki/Array_data_structure "Array data structure"). For other types of arrays, see [Array](https://en.wikipedia.org/wiki/Array "Array").

In [computer science](https://en.wikipedia.org/wiki/Computer_science "Computer science"), **array** is a [data type](https://en.wikipedia.org/wiki/Data_type "Data type") that represents a collection of _elements_ ([values](https://en.wikipedia.org/wiki/Value_(computer_science) "Value (computer science)") or [variables](https://en.wikipedia.org/wiki/Variable_(computer_science) "Variable (computer science)")), each selected by one or more indices (identifying keys) that can be computed at [run time](https://en.wikipedia.org/wiki/Run_time_(program_lifecycle_phase) "Run time (program lifecycle phase)") during program execution. Such a collection is usually called an **array variable** or **array value**.[[1]](https://en.wikipedia.org/wiki/Array_data_type#cite_note-sebesta-1) By analogy with the mathematical concepts [vector](https://en.wikipedia.org/wiki/Vector_(mathematics_and_physics) "Vector (mathematics and physics)") and [matrix](https://en.wikipedia.org/wiki/Matrix_(mathematics) "Matrix (mathematics)"), array types with one and two indices are often called **vector type** and **matrix type**, respectively. More generally, a multidimensional array type can be called a **tensor type**, by analogy with the mathematical concept, [tensor](https://en.wikipedia.org/wiki/Tensor "Tensor").[[2]](https://en.wikipedia.org/wiki/Array_data_type#cite_note-tensorflow-2)

Language support for array types may include certain [built-in](https://en.wikipedia.org/wiki/Built-in_type "Built-in type") array data types, some syntactic constructions (_array type constructors_) that the [programmer](https://en.wikipedia.org/wiki/Programmer "Programmer") may use to define such types and declare array variables, and special notation for indexing array elements.[[1]](https://en.wikipedia.org/wiki/Array_data_type#cite_note-sebesta-1) For example, in the [Pascal programming language](https://en.wikipedia.org/wiki/Pascal_programming_language "Pascal programming language"), the declaration `type MyTable = array [1..4,1..2] of integer`, defines a new array data type called `MyTable`. The declaration `var A: MyTable` then defines a variable `A` of that type, which is an aggregate of eight elements, each being an integer variable identified by two indices. In the Pascal program, those elements are denoted `A[1,1]`, `A[1,2]`, `A[2,1]`, …, `A[4,2]`.[[3]](https://en.wikipedia.org/wiki/Array_data_type#cite_note-pascal-3) Special array types are often defined by the language's standard [libraries](https://en.wikipedia.org/wiki/Library_(computer_science) "Library (computer science)").

[Dynamic lists](https://en.wikipedia.org/wiki/Dynamic_list "Dynamic list") are also more common and easier to implement[_[dubious](https://en.wikipedia.org/wiki/Wikipedia:Accuracy\_dispute#Disputed\_statement "Wikipedia:Accuracy dispute") – [discuss](https://en.wikipedia.org/wiki/Talk:Array\_(data\_type)#Dubious "Talk:Array (data type)")_] than [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array "Dynamic array"). Array types are distinguished from [record](https://en.wikipedia.org/wiki/Record_(computer_science) "Record (computer science)") types mainly because they allow the element indices to be computed at [run time](https://en.wikipedia.org/wiki/Run_time_(program_lifecycle_phase) "Run time (program lifecycle phase)"), as in the Pascal [assignment](https://en.wikipedia.org/wiki/Assignment_statement "Assignment statement")`A[I,J] := A[N-I,2*J]`. Among other things, this feature allows a single iterative [statement](https://en.wikipedia.org/wiki/Statement_(computer_science) "Statement (computer science)") to process arbitrarily many elements of an array variable.

In more theoretical contexts, especially in [type theory](https://en.wikipedia.org/wiki/Type_theory "Type theory") and in the description of abstract [algorithms](https://en.wikipedia.org/wiki/Algorithm "Algorithm"), the terms "array" and "array type" sometimes refer to an [abstract data type](https://en.wikipedia.org/wiki/Abstract_data_type "Abstract data type") (ADT) also called _abstract array_ or may refer to an _[associative array](https://en.wikipedia.org/wiki/Associative\_array "Associative array")_, a [mathematical](https://en.wikipedia.org/wiki/Mathematics "Mathematics") model with the basic operations and behavior of a typical array type in most languages– basically, a collection of elements that are selected by indices computed at run-time.

Depending on the language, array types may overlap (or be identified with) other data types that describe aggregates of values, such as [lists](https://en.wikipedia.org/wiki/List_(computing) "List (computing)") and [strings](https://en.wikipedia.org/wiki/String_(computer_science) "String (computer science)"). Array types are often implemented by [array data structures](https://en.wikipedia.org/wiki/Array_data_structure "Array data structure"), but sometimes by other means, such as [hash tables](https://en.wikipedia.org/wiki/Hash_table "Hash table"), [linked lists](https://en.wikipedia.org/wiki/Linked_list "Linked list"), or [search trees](https://en.wikipedia.org/wiki/Search_tree "Search tree").

[Heinz Rutishauser](https://en.wikipedia.org/wiki/Heinz_Rutishauser "Heinz Rutishauser")'s programming language Superplan (1949–1951) included multi-dimensional arrays. However, although Rutishauser described how a compiler for his language should be built, did not implement one.

Assembly languages and low-level languages like BCPL[[4]](https://en.wikipedia.org/wiki/Array_data_type#cite_note-4) generally have no syntactic support for arrays.

Because of the importance of array structures for efficient computation, the earliest high-level programming languages, including [FORTRAN](https://en.wikipedia.org/wiki/FORTRAN "FORTRAN") (1957), [COBOL](https://en.wikipedia.org/wiki/COBOL "COBOL") (1960), and [Algol 60](https://en.wikipedia.org/wiki/Algol_60 "Algol 60") (1960), provided support for multi-dimensional arrays.

An array data structure can be mathematically modeled as an [abstract data structure](https://en.wikipedia.org/wiki/Abstract_data_structure "Abstract data structure") (an _abstract array_) with two operations

_get_(_A_, _I_): the data stored in the element of the array _A_ whose indices are the integer [tuple](https://en.wikipedia.org/wiki/Tuple "Tuple")_I_._set_(_A_, _I_, _V_): the array that results by setting the value of that element to _V_.
These operations are required to satisfy the [axioms](https://en.wikipedia.org/wiki/Axiom "Axiom")[[5]](https://en.wikipedia.org/wiki/Array_data_type#cite_note-5)

_get_(_set_(_A_, _I_, _V_), _I_) = _V_ _get_(_set_(_A_, _I_, _V_), _J_) = _get_(_A_, _J_) if _I_ ≠ _J_
for any array state _A_, any value _V_, and any tuples _I_, _J_ for which the operations are defined.

The first axiom means that each element behaves like a variable. The second axiom means that elements with distinct indices behave as [disjoint](https://en.wikipedia.org/wiki/Aliasing_(computing) "Aliasing (computing)") variables, so that storing a value in one element does not affect the value of any other element.

These axioms do not place any constraints on the set of valid index tuples _I_, therefore this abstract model can be used for [triangular matrices](https://en.wikipedia.org/wiki/Triangular_array "Triangular array") and other oddly-shaped arrays.

In order to effectively implement variables of such types as [array structures](https://en.wikipedia.org/wiki/Array_data_structure "Array data structure") (with indexing done by [pointer arithmetic](https://en.wikipedia.org/wiki/Pointer_arithmetic "Pointer arithmetic")), many languages restrict the indices to [integer](https://en.wikipedia.org/wiki/Integer_(computer_science) "Integer (computer science)") data types[[6]](https://en.wikipedia.org/wiki/Array_data_type#cite_note-6)[[7]](https://en.wikipedia.org/wiki/Array_data_type#cite_note-7) (or other types that can be interpreted as integers, such as [bytes](https://en.wikipedia.org/wiki/Byte "Byte") and [enumerated types](https://en.wikipedia.org/wiki/Enumerated_type "Enumerated type")), and require that all elements have the same data type and storage size. Most of those languages also restrict each index to a finite [interval](https://en.wikipedia.org/wiki/Interval_(mathematics) "Interval (mathematics)") of integers, that remains fixed throughout the lifetime of the array variable. In some [compiled](https://en.wikipedia.org/wiki/Compiler "Compiler") languages, in fact, the index ranges may have to be known at [compile time](https://en.wikipedia.org/wiki/Compile_time "Compile time").

On the other hand, some programming languages provide more liberal array types, that allow indexing by arbitrary values, such as [floating-point numbers](https://en.wikipedia.org/wiki/Floating_point "Floating point"), [strings](https://en.wikipedia.org/wiki/String_(computer_science) "String (computer science)"), [objects](https://en.wikipedia.org/wiki/Object-oriented_programming "Object-oriented programming"), [references](https://en.wikipedia.org/wiki/Reference_(computer_science) "Reference (computer science)"), etc.. Such index values cannot be restricted to an interval, much less a fixed interval. So, these languages usually allow arbitrary new elements to be created at any time. This choice precludes the implementation of array types as array data structures. That is, those languages use array-like syntax to implement a more general [associative array](https://en.wikipedia.org/wiki/Associative_array "Associative array") semantics, and must therefore be implemented by a [hash table](https://en.wikipedia.org/wiki/Hash_table "Hash table") or some other [search data structure](https://en.wikipedia.org/wiki/Search_data_structure "Search data structure").

### Multi-dimensional arrays

[[edit](https://en.wikipedia.org/w/index.php?title=Array_(data_type)&action=edit&section=5 "Edit section: Multi-dimensional arrays")]

The number of indices needed to specify an element is called the _dimension_, _dimensionality_, or [rank](https://en.wikipedia.org/wiki/Rank_(computer_programming) "Rank (computer programming)") of the array type. (This nomenclature conflicts with the concept of dimension in linear algebra, which expresses the [shape of a matrix](https://en.wikipedia.org/wiki/Matrix_(mathematics)#Definition "Matrix (mathematics)"). Thus, an array of numbers with 5 rows and 4 columns, hence 20 elements, is said to have dimension 2 in computing contexts, but represents a matrix that is said to be 4×5-dimensional. Also, the computer science meaning of "rank" conflicts with the notion of [tensor rank](https://en.wikipedia.org/wiki/Tensor_rank "Tensor rank"), which is a generalization of the linear algebra concept of [rank of a matrix](https://en.wikipedia.org/wiki/Matrix_rank "Matrix rank").)

[![Image 1: A two-dimensional array stored as a one-dimensional array of one-dimensional arrays (rows)](https://upload.wikimedia.org/wikipedia/commons/thumb/0/01/Array_of_array_storage.svg/120px-Array_of_array_storage.svg.png)](https://en.wikipedia.org/wiki/File:Array_of_array_storage.svg "A two-dimensional array stored as a one-dimensional array of one-dimensional arrays (rows)")

A two-dimensional array stored as a one-dimensional array of one-dimensional arrays (rows)

Many languages support only one-dimensional arrays. In those languages, a multi-dimensional array is typically represented by an [Iliffe vector](https://en.wikipedia.org/wiki/Iliffe_vector "Iliffe vector"), a one-dimensional array of [references](https://en.wikipedia.org/wiki/Reference_(computer_science) "Reference (computer science)") to arrays of one dimension less. A two-dimensional array, in particular, would be implemented as a vector of pointers to its rows.[[8]](https://en.wikipedia.org/wiki/Array_data_type#cite_note-8) Thus an element in row _i_ and column _j_ of an array _A_ would be accessed by double indexing (`A[i][j]` in typical notation). This way of emulating multi-dimensional arrays allows the creation of [jagged arrays](https://en.wikipedia.org/wiki/Jagged_array "Jagged array"), where each row may have a different size– or, in general, where the valid range of each index depends on the values of all preceding indices.

This representation for multi-dimensional arrays is quite prevalent in C and C++ software. However, C and C++ will use a linear indexing formula for multi-dimensional arrays that are declared with compile time constant size, e.g. by `int A[10][20]` or `int A[m][n]`, instead of the traditional `int **A`.[[9]](https://en.wikipedia.org/wiki/Array_data_type#cite_note-9)

The C99 standard introduced Variable Length Array types that let define array types with dimensions computed in run time. The dynamic 4D array can be constructed using a pointer to 4d array, e.g. `int (*arr)[t][u][v][w] = malloc(sizeof *arr);`. The individual elements are accessed by first de-referencing an array pointer followed by indexing, e.g. `(*arr)[i][j][k][l]`. Alternatively, n-d arrays can be declared as pointers to its first element which is a (n-1) dimensional array, e.g. `int (*arr)[u][v][w] = malloc(t * sizeof *arr);` and accessed using more idiomatic syntax, e.g. `arr[i][j][k][l]`.

Most programming languages that support arrays support the _store_ and _select_ operations, and have special syntax for indexing. Early languages used parentheses, e.g. `A(i,j)`, as in FORTRAN; others choose square brackets, e.g. `A[i,j]` or `A[i][j]`, as in Algol 60 and Pascal (to distinguish from the use of parentheses for [function calls](https://en.wikipedia.org/wiki/Function_call "Function call")).

Array data types are most often implemented as array structures: with the indices restricted to integer (or totally ordered) values, index ranges fixed at array creation time, and multilinear element addressing. This was the case in most ["third generation"](https://en.wikipedia.org/wiki/Third-generation_programming_language "Third-generation programming language") languages, and is still the case of most [systems programming languages](https://en.wikipedia.org/wiki/Systems_programming_language "Systems programming language") such as [Ada](https://en.wikipedia.org/wiki/Ada_(programming_language) "Ada (programming language)"), [C](https://en.wikipedia.org/wiki/C_programming_language "C programming language"), and [C++](https://en.wikipedia.org/wiki/C%2B%2B "C++"). In some languages, however, array data types have the semantics of associative arrays, with indices of arbitrary type and dynamic element creation. This is the case in some [scripting languages](https://en.wikipedia.org/wiki/Scripting_languages "Scripting languages") such as [Awk](https://en.wikipedia.org/wiki/Awk_programming_language "Awk programming language") and [Lua](https://en.wikipedia.org/wiki/Lua_(programming_language) "Lua (programming language)"), and of some array types provided by standard [C++](https://en.wikipedia.org/wiki/C%2B%2B "C++") libraries.

Some languages (like Pascal and Modula) perform [bounds checking](https://en.wikipedia.org/wiki/Bounds_checking "Bounds checking") on every access, raising an [exception](https://en.wikipedia.org/wiki/Exception_(computer_science) "Exception (computer science)") or aborting the program when any index is out of its valid range. Compilers may allow these checks to be turned off to trade safety for speed. Other languages (like FORTRAN and C) trust the programmer and perform no checks. Good compilers may also analyze the program to determine the range of possible values that the index may have, and this analysis may lead to [bounds-checking elimination](https://en.wikipedia.org/wiki/Bounds-checking_elimination "Bounds-checking elimination").

Some languages, such as C, provide only [zero-based](https://en.wikipedia.org/wiki/Zero-based_numbering "Zero-based numbering") array types, for which the minimum valid value for any index is 0.[[10]](https://en.wikipedia.org/wiki/Array_data_type#cite_note-10) This choice is convenient for array implementation and address computations. With a language such as C, a pointer to the interior of any array can be defined that will symbolically act as a pseudo-array that accommodates negative indices. This works only because C does not check an index against bounds when used.

Other languages provide only _one-based_ array types, where each index starts at 1; this is the traditional convention in mathematics for matrices and mathematical [sequences](https://en.wikipedia.org/wiki/Sequence "Sequence"). A few languages, such as Pascal and Lua, support _n-based_ array types, whose minimum legal indices are chosen by the programmer. The relative merits of each choice have been the subject of heated debate. Zero-based indexing can avoid [off-by-one](https://en.wikipedia.org/wiki/Off-by-one_error "Off-by-one error") or [fencepost errors](https://en.wikipedia.org/wiki/Fencepost_error "Fencepost error").[[11]](https://en.wikipedia.org/wiki/Array_data_type#cite_note-11)

The relation between numbers appearing in an array declaration and the index of that array's last element also varies by language. In many languages (such as C), one should specify the number of elements contained in the array; whereas in others (such as Pascal and [Visual Basic .NET](https://en.wikipedia.org/wiki/Visual_Basic_.NET "Visual Basic .NET")) one should specify the numeric value of the index of the last element. This distinction is not present in languages where the indices start at 1, such as [Lua](https://en.wikipedia.org/wiki/Lua_(programming_language) "Lua (programming language)").

Some programming languages support [array programming](https://en.wikipedia.org/wiki/Array_programming "Array programming"), where operations and functions defined for certain data types are implicitly extended to arrays of elements of those types. Thus one can write _A_+_B_ to add corresponding elements of two arrays _A_ and _B_. Usually these languages provide both the [element-by-element multiplication](https://en.wikipedia.org/wiki/Hadamard_product_(matrices) "Hadamard product (matrices)") and the standard [matrix product](https://en.wikipedia.org/wiki/Dot_product "Dot product") of [linear algebra](https://en.wikipedia.org/wiki/Linear_algebra "Linear algebra"), and which of these is represented by the _*_ operator varies by language.

Languages providing array programming capabilities have proliferated since the innovations in this area of [APL](https://en.wikipedia.org/wiki/APL_programming_language "APL programming language"). These are core capabilities of [domain-specific languages](https://en.wikipedia.org/wiki/Domain-specific_language "Domain-specific language") such as [GAUSS](https://en.wikipedia.org/wiki/GAUSS_(programming_language) "GAUSS (programming language)"), [IDL](https://en.wikipedia.org/wiki/Interactive_Data_Language "Interactive Data Language"), [Matlab](https://en.wikipedia.org/wiki/Matlab "Matlab"), and [Mathematica](https://en.wikipedia.org/wiki/Mathematica "Mathematica"). They are a core facility in newer languages, such as [Julia](https://en.wikipedia.org/wiki/Julia_(programming_language) "Julia (programming language)") and recent versions of [Fortran](https://en.wikipedia.org/wiki/Fortran "Fortran"). These capabilities are also provided via standard extension libraries for other general purpose programming languages (such as the widely used [NumPy](https://en.wikipedia.org/wiki/NumPy "NumPy") library for [Python](https://en.wikipedia.org/wiki/Python_(programming_language) "Python (programming language)")).

### String types and arrays

[[edit](https://en.wikipedia.org/w/index.php?title=Array_(data_type)&action=edit&section=12 "Edit section: String types and arrays")]

Many languages provide a built-in [string](https://en.wikipedia.org/wiki/String_(computer_science) "String (computer science)") data type, with specialized notation ("[string literals](https://en.wikipedia.org/wiki/String_literal "String literal")") to build values of that type. In some languages (such as C), a string is just an array of characters, or is handled in much the same way. Other languages, like [Pascal](https://en.wikipedia.org/wiki/Pascal_programming_language "Pascal programming language"), may provide vastly different operations for strings and arrays.

### Array index range queries

[[edit](https://en.wikipedia.org/w/index.php?title=Array_(data_type)&action=edit&section=13 "Edit section: Array index range queries")]

Some programming languages provide operations that return the size (number of elements) of a vector, or, more generally, range of each index of an array. In [C](https://en.wikipedia.org/wiki/C_(programming_language) "C (programming language)") and [C++](https://en.wikipedia.org/wiki/C%2B%2B "C++") arrays do not support the _size_ function, so programmers often have to declare separate variable to hold the size, and pass it to procedures as a separate parameter.

Elements of a newly created array may have undefined values (as in C), or may be defined to have a specific "default" value such as 0 or a [null pointer](https://en.wikipedia.org/wiki/Null_pointer "Null pointer") (as in Java).

In [C++](https://en.wikipedia.org/wiki/C%2B%2B "C++") a std::vector object supports the _store_, _select_, and _append_ operations with the performance characteristics discussed above. Vectors can be queried for their size and can be resized. Slower operations like inserting an element in the middle are also supported.

An [array slicing](https://en.wikipedia.org/wiki/Array_slicing "Array slicing") operation takes a subset of the elements of an array-typed entity (value or variable) and then assembles them as another array-typed entity, possibly with other indices. If array types are implemented as array structures, many useful slicing operations (such as selecting a sub-array, swapping indices, or reversing the direction of the indices) can be performed very efficiently by manipulating the [dope vector](https://en.wikipedia.org/wiki/Dope_vector "Dope vector") of the structure. The possible slicings depend on the implementation details: for example, [Fortran](https://en.wikipedia.org/wiki/Fortran "Fortran") allows slicing off one column of a matrix variable, but not a row, and treat it as a vector.

On the other hand, other slicing operations are possible when array types are implemented in other ways.

Some languages allow [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array "Dynamic array") (also called resizable, growable, or extensible): array variables whose index ranges may be expanded at any time after creation, without changing the values of its current elements.

For one-dimensional arrays, this facility may be provided as an operation `append(A,x)` that increases the size of the array _A_ by one and then sets the value of the last element to _x_. Other array types (such as Pascal strings) provide a concatenation operator, which can be used together with slicing to achieve that effect and more. In some languages, assigning a value to an element of an array automatically extends the array, if necessary, to include that element. In other array types, a slice can be replaced by an array of different size, with subsequent elements being renumbered accordingly– as in Python's list assignment `A[5:5] = [10,20,30]`, that inserts three new elements (10, 20, and 30) before element "_A_[5]". Resizable arrays are conceptually similar to [lists](https://en.wikipedia.org/wiki/List_(computer_science) "List (computer science)"), and the two concepts are synonymous in some languages.

An extensible array can be implemented as a fixed-size array, with a counter that records how many elements are actually in use. The `append` operation merely increments the counter; until the whole array is used, when the `append` operation may be defined to fail. This is an implementation of a [dynamic array](https://en.wikipedia.org/wiki/Dynamic_array "Dynamic array") with a fixed capacity, as in the `string` type of Pascal. Alternatively, the `append` operation may re-allocate the underlying array with a larger size, and copy the old elements to the new area.

*   [Array access analysis](https://en.wikipedia.org/wiki/Array_access_analysis "Array access analysis")
*   [Array database management system](https://en.wikipedia.org/wiki/Array_database_management_system "Array database management system")
*   [Bounds-checking elimination](https://en.wikipedia.org/wiki/Bounds-checking_elimination "Bounds-checking elimination")
*   [Delimiter-separated values](https://en.wikipedia.org/wiki/Delimiter-separated_values "Delimiter-separated values")
*   [Index checking](https://en.wikipedia.org/wiki/Index_checking "Index checking")
*   [Parallel array](https://en.wikipedia.org/wiki/Parallel_array "Parallel array")
*   [Sparse array](https://en.wikipedia.org/wiki/Sparse_array "Sparse array")
*   [Variable-length array](https://en.wikipedia.org/wiki/Variable-length_array "Variable-length array")

1.   ^ [Jump up to: _**a**_](https://en.wikipedia.org/wiki/Array_data_type#cite_ref-sebesta_1-0)[_**b**_](https://en.wikipedia.org/wiki/Array_data_type#cite_ref-sebesta_1-1)Robert W. Sebesta (2001) _Concepts of Programming Languages_. Addison-Wesley. 4th edition (1998), 5th edition (2001), [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[9780201385960](https://en.wikipedia.org/wiki/Special:BookSources/9780201385960 "Special:BookSources/9780201385960")
2.   **[^](https://en.wikipedia.org/wiki/Array_data_type#cite_ref-tensorflow_2-0 "Jump up")**["Introduction to Tensors | TensorFlow Core"](https://www.tensorflow.org/guide/tensor). _TensorFlow_.
3.   **[^](https://en.wikipedia.org/wiki/Array_data_type#cite_ref-pascal_3-0 "Jump up")**K. Jensen and Niklaus Wirth, _PASCAL User Manual and Report_. Springer. Paperback edition (2007) 184 pages, [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-3540069508](https://en.wikipedia.org/wiki/Special:BookSources/978-3540069508 "Special:BookSources/978-3540069508")
4.   **[^](https://en.wikipedia.org/wiki/Array_data_type#cite_ref-4 "Jump up")**John Mitchell, _Concepts of Programming Languages_. Cambridge University Press.
5.   **[^](https://en.wikipedia.org/wiki/Array_data_type#cite_ref-5 "Jump up")**Lukham, Suzuki (1979), "Verification of array, record, and pointer operations in Pascal". _ACM Transactions on Programming Languages and Systems_**1** (2), 226–244.
6.   **[^](https://en.wikipedia.org/wiki/Array_data_type#cite_ref-6 "Jump up")**Deitel, Harvey M.; Deitel, Paul J. (2005). [_C# for Programmers_](https://books.google.com/books?id=euV7e2f-RzsC&dq=array+index+must+be+an+integer&pg=PA303). Prentice Hall Professional. p.303. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-13-246591-5](https://en.wikipedia.org/wiki/Special:BookSources/978-0-13-246591-5 "Special:BookSources/978-0-13-246591-5"). Retrieved 22 May 2024.
7.   **[^](https://en.wikipedia.org/wiki/Array_data_type#cite_ref-7 "Jump up")**Friesen, Jeff (5 March 2014). [_Learn Java for Android Development: Java 8 and Android 5 Edition_](https://books.google.com/books?id=Up8QAwAAQBAJ&dq=array+index+must+be+an+integer&pg=PA56). Apress. p.56. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-1-4302-6455-2](https://en.wikipedia.org/wiki/Special:BookSources/978-1-4302-6455-2 "Special:BookSources/978-1-4302-6455-2"). Retrieved 22 May 2024.
8.   **[^](https://en.wikipedia.org/wiki/Array_data_type#cite_ref-8 "Jump up")**Van der Linden, Peter (1994). _Expert C Programming: Deep C Secrets_. Englewood Cliffs, NJ: SunSoft Press. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-13-177429-2](https://en.wikipedia.org/wiki/Special:BookSources/978-0-13-177429-2 "Special:BookSources/978-0-13-177429-2").
9.   **[^](https://en.wikipedia.org/wiki/Array_data_type#cite_ref-9 "Jump up")**Brian W. Kernighan and Dennis M. Ritchie (1988), _The C programming Language_. Prentice-Hall, p. 81.
10.   **[^](https://en.wikipedia.org/wiki/Array_data_type#cite_ref-10 "Jump up")**Kernighan, Brian W.; Ritchie, Dennis M. (1988). _The C programming language_ (2nd ed.). Englewood Cliffs, N.J: Prentice Hall. p.24. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-13-110370-2](https://en.wikipedia.org/wiki/Special:BookSources/978-0-13-110370-2 "Special:BookSources/978-0-13-110370-2").
11.   **[^](https://en.wikipedia.org/wiki/Array_data_type#cite_ref-11 "Jump up")**[Edsger W. Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra "Edsger W. Dijkstra"), "[Why numbering should start at zero](http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html)"

[![Image 2](https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/Wiktionary-logo-en-v2.svg/40px-Wiktionary-logo-en-v2.svg.png)](https://en.wikipedia.org/wiki/File:Wiktionary-logo-en-v2.svg)

Look up _**[array](https://en.wiktionary.org/wiki/array "wiktionary:array")**_ in Wiktionary, the free dictionary.

*   [NIST's Dictionary of Algorithms and Data Structures: Array](https://xlinux.nist.gov/dads/HTML/array.html)
