Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 History 2 Words over an alphabet 3 Definition 4 Examples Toggle Examples subsection 4.1 Constructions 5 Language-specification formalisms 6 Operations on languages 7 Applications Toggle Applications subsection 7.1 Programming languages 7.2 Formal theories, systems, and proofs 7.2.1 Interpretations and models 8 See also 9 Notes 10 References Toggle References subsection 10.1 Citations 10.2 Sources 11 External links Toggle the table of contents Formal language 52 languages العربية Azərbaycanca Български Bosanski Català Čeština Dansk Deutsch Ελληνικά Español Esperanto فارسی Français 한국어 हिन्दी Hrvatski Ido Bahasa Indonesia Italiano עברית Kreyòl ayisyen Lietuvių Lombard Magyar Македонски Mirandés မြန်မာဘာသာ Nederlands 日本語 Norsk bokmål Norsk nynorsk Oʻzbekcha / ўзбекча Polski Português Română Русский Shqip Simple English سنڌي Slovenčina کوردی Српски / srpski Srpskohrvatski / српскохрватски Suomi Svenska ไทย Türkçe Українська Tiếng Việt 粵語 中文 ⵜⴰⵎⴰⵣⵉⵖⵜ ⵜⴰⵏⴰⵡⴰⵢⵜ Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Sequence of words formed by specific rules This article is about a technical term in mathematics and computer science. For any formal type of language usage, see Literary language . For studies about natural languages, see Formal semantics (natural language) .

This article needs additional citations for verification .

Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed.

Find sources: "Formal language" – news · newspapers · books · scholar · JSTOR ( March 2024 ) ( Learn how and when to remove this message ) Part of a series on Formal languages Key concepts Formal system Alphabet Syntax Formal semantics Semantics (programming languages) Formal grammar Formation rule Well-formed formula Automata theory Regular expression Production Ground expression Atomic formula Applications Formal methods Propositional calculus Predicate logic Mathematical notation Natural language processing Programming language theory Mathematical linguistics Computational linguistics Syntax analysis Formal verification Automated theorem proving v t e Structure of the syntactically well-formed, although thoroughly nonsensical, English sentence, "Colorless green ideas sleep furiously" ( historical example from Chomsky 1957) In logic , mathematics , computer science , and linguistics , a formal language is a set of strings whose symbols are taken from a set called " alphabet ".

The alphabet of a formal language consists of symbols that concatenate into strings (also called "words").

[ 1 ] Words that belong to a particular formal language are sometimes called well-formed words . A formal language is often defined by means of a formal grammar such as a regular grammar or context-free grammar .

In computer science, formal languages are used, among others, as the basis for defining the grammar of programming languages and formalized versions of subsets of natural languages, in which the words of the language represent concepts that are associated with meanings or semantics . In computational complexity theory , decision problems are typically defined as formal languages, and complexity classes are defined as the sets of the formal languages that can be parsed by machines with limited computational power. In logic and the foundations of mathematics , formal languages are used to represent the syntax of axiomatic systems , and mathematical formalism is the philosophy that all of mathematics can be reduced to the syntactic manipulation of formal languages in this way.

The field of formal language theory studies primarily the purely syntactic aspects of such languages—that is, their internal structural patterns. Formal language theory sprang out of linguistics, as a way of understanding the syntactic regularities of natural languages .

History [ edit ] This section needs expansion . You can help by adding to it .

( March 2021 ) In the 17th century, Gottfried Leibniz imagined and described the characteristica universalis , a universal and formal language which utilised pictographs . Later, Carl Friedrich Gauss investigated the problem of Gauss codes .

[ 2 ] Gottlob Frege attempted to realize Leibniz's ideas, through a notational system first outlined in Begriffsschrift (1879) and more fully developed in his 2-volume Grundgesetze der Arithmetik (1893/1903).

[ 3 ] This described a "formal language of pure language." [ 4 ] In the first half of the 20th century, several developments were made with relevance to formal languages.

Axel Thue published four papers relating to words and language between 1906 and 1914. The last of these introduced what Emil Post later termed 'Thue Systems', and gave an early example of an undecidable problem .

[ 5 ] Post would later use this paper as the basis for a 1947 proof "that the word problem for semigroups was recursively insoluble", [ 6 ] and later devised the canonical system for the creation of formal languages.

In 1907, Leonardo Torres Quevedo introduced a formal language for the description of mechanical drawings (mechanical devices), in Vienna . He published "Sobre un sistema de notaciones y símbolos destinados a facilitar la descripción de las máquinas" ("On a system of notations and symbols intended to facilitate the description of machines").

[ 7 ] Heinz Zemanek rated it as an equivalent to a programming language for the numerical control of machine tools.

[ 8 ] Noam Chomsky devised an abstract representation of formal and natural languages, known as the Chomsky hierarchy .

[ 9 ] In 1959 John Backus developed the Backus-Naur form to describe the syntax of a high level programming language, following his work in the creation of FORTRAN .

[ 10 ] Peter Naur was the secretary/editor for the ALGOL60 Report in which he used Backus–Naur form to describe the Formal part of ALGOL60.

Words over an alphabet [ edit ] Main article: Alphabet (formal languages) An alphabet , in the context of formal languages, can be any set ; its elements are called letters . An alphabet may contain an infinite number of elements; [ note 1 ] however, most definitions in formal language theory specify alphabets with a finite number of elements, and many results apply only to them. It often makes sense to use an alphabet in the usual sense of the word, or more generally any finite character encoding such as ASCII or Unicode .

A word over an alphabet can be any finite sequence (i.e., string ) of letters. The set of all words over an alphabet Σ is usually denoted by Σ * (using the Kleene star ). The length of a word is the number of letters it is composed of. For any alphabet, there is only one word of length 0, the empty word , which is often denoted by e, ε, λ or even Λ. By concatenation one can combine two words to form a new word, whose length is the sum of the lengths of the original words. The result of concatenating a word with the empty word is the original word.

In some applications, especially in logic , the alphabet is also known as the vocabulary and words are known as formulas or sentences ; this breaks the letter/word metaphor and replaces it by a word/sentence metaphor.

Definition [ edit ] Given a non-empty set Σ Σ {\displaystyle \Sigma } , a formal language L {\displaystyle L} over Σ Σ {\displaystyle \Sigma } is a subset of Σ Σ ∗ ∗ {\displaystyle \Sigma ^{*}} , which is the set of all possible finite-length words over Σ Σ {\displaystyle \Sigma } . We call the set Σ Σ {\displaystyle \Sigma } the alphabet of L {\displaystyle L} . On the other hand, given a formal language L {\displaystyle L} over Σ Σ {\displaystyle \Sigma } , a word w ∈ ∈ Σ Σ ∗ ∗ {\displaystyle w\in \Sigma ^{*}} is well-formed if w ∈ ∈ L {\displaystyle w\in L} . Similarly, an expression E ⊆ ⊆ Σ Σ ∗ ∗ {\displaystyle E\subseteq \Sigma ^{*}} is well-formed if E ⊆ ⊆ L {\displaystyle E\subseteq L} . Sometimes, a formal language L {\displaystyle L} over Σ Σ {\displaystyle \Sigma } has a set of clear rules and constraints for the creation of all possible well-formed words from Σ Σ ∗ ∗ {\displaystyle \Sigma ^{*}} .

In computer science and mathematics, which do not usually deal with natural languages , the adjective "formal" is often omitted as redundant. On the other hand, we can just say "a formal language L {\displaystyle L} " when its alphabet Σ Σ {\displaystyle \Sigma } is clear in the context.

While formal language theory usually concerns itself with formal languages that are described by some syntactic rules, the actual definition of the concept "formal language" is only as above: a (possibly infinite) set of finite-length strings composed from a given alphabet, no more and no less. In practice, there are many languages that can be described by rules, such as regular languages or context-free languages . The notion of a formal grammar may be closer to the intuitive concept of a "language", one described by syntactic rules. By an abuse of the definition, a particular formal language is often thought of as being accompanied with a formal grammar that describes it.

Examples [ edit ] The following rules describe a formal language L over the alphabet Σ = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, +, =}: Every nonempty string that does not contain "+" or "=" and does not start with "0" is in L .

The string "0" is in L .

A string containing "=" is in L if and only if there is exactly one "=", and it separates two valid strings of L .

A string containing "+" but not "=" is in L if and only if every "+" in the string separates two valid strings of L .

No string is in L other than those implied by the previous rules.

Under these rules, the string "23+4=555" is in L , but the string "=234=+" is not. This formal language expresses natural numbers , well-formed additions, and well-formed addition equalities, but it expresses only what they look like (their syntax ), not what they mean ( semantics ). For instance, nowhere in these rules is there any indication that "0" means the number zero, "+" means addition, "23+4=555" is false, etc.

Constructions [ edit ] For finite languages, one can explicitly enumerate all well-formed words. For example, we can describe a language L as just L = {a, b, ab, cba}. The degenerate case of this construction is the empty language , which contains no words at all ( L = ∅ ).

However, even over a finite (non-empty) alphabet such as Σ = {a, b} there are an infinite number of finite-length words that can potentially be expressed: "a", "abb", "ababba", "aaababbbbaab", .... Therefore, formal languages are typically infinite, and describing an infinite formal language is not as simple as writing L = {a, b, ab, cba}. Here are some examples of formal languages: L = Σ * , the set of all words over Σ; L = {a} * = {a n }, where n ranges over the natural numbers and "a n " means "a" repeated n times (this is the set of words consisting only of the symbol "a"); the set of syntactically correct programs in a given programming language (the syntax of which is usually defined by a context-free grammar ); the set of inputs upon which a certain Turing machine halts; or the set of maximal strings of alphanumeric ASCII characters on this line, i.e., the set {the, set, of, maximal, strings, alphanumeric, ASCII, characters, on, this, line, i, e}.

Language-specification formalisms [ edit ] Formal languages are used as tools in multiple disciplines. However, formal language theory rarely concerns itself with particular languages (except as examples), but is mainly concerned with the study of various types of formalisms to describe languages. For instance, a language can be given as those strings generated by some formal grammar ; those strings described or matched by a particular regular expression ; those strings accepted by some automaton , such as a Turing machine or finite-state automaton ; those strings for which some decision procedure (an algorithm that asks a sequence of related YES/NO questions) produces the answer YES.

Typical questions asked about such formalisms include: What is their expressive power? (Can formalism X describe every language that formalism Y can describe? Can it describe other languages?) What is their recognizability? (How difficult is it to decide whether a given word belongs to a language described by formalism X ?) What is their comparability? (How difficult is it to decide whether two languages, one described in formalism X and one in formalism Y , or in X again, are actually the same language?).

Surprisingly often, the answer to these decision problems is "it cannot be done at all", or "it is extremely expensive" (with a characterization of how expensive). Therefore, formal language theory is a major application area of computability theory and complexity theory . Formal languages may be classified in the Chomsky hierarchy based on the expressive power of their generative grammar as well as the complexity of their recognizing automaton .

Context-free grammars and regular grammars provide a good compromise between expressivity and ease of parsing , and are widely used in practical applications.

Operations on languages [ edit ] Certain operations on languages are common. This includes the standard set operations, such as union, intersection, and complement. Another class of operation is the element-wise application of string operations.

Examples: suppose L 1 {\displaystyle L_{1}} and L 2 {\displaystyle L_{2}} are languages over some common alphabet Σ Σ {\displaystyle \Sigma } .

The concatenation L 1 ⋅ ⋅ L 2 {\displaystyle L_{1}\cdot L_{2}} consists of all strings of the form v w {\displaystyle vw} where v {\displaystyle v} is a string from L 1 {\displaystyle L_{1}} and w {\displaystyle w} is a string from L 2 {\displaystyle L_{2}} .

The intersection L 1 ∩ ∩ L 2 {\displaystyle L_{1}\cap L_{2}} of L 1 {\displaystyle L_{1}} and L 2 {\displaystyle L_{2}} consists of all strings that are contained in both languages The complement ¬ ¬ L 1 {\displaystyle \neg L_{1}} of L 1 {\displaystyle L_{1}} with respect to Σ Σ {\displaystyle \Sigma } consists of all strings over Σ Σ {\displaystyle \Sigma } that are not in L 1 {\displaystyle L_{1}} .

The Kleene star : the language consisting of all words that are concatenations of zero or more words in the original language; Reversal : Let ε be the empty word, then ε ε R = ε ε {\displaystyle \varepsilon ^{R}=\varepsilon } , and for each non-empty word w = σ σ 1 ⋯ ⋯ σ σ n {\displaystyle w=\sigma _{1}\cdots \sigma _{n}} (where σ σ 1 , … … , σ σ n {\displaystyle \sigma _{1},\ldots ,\sigma _{n}} are elements of some alphabet), let w R = σ σ n ⋯ ⋯ σ σ 1 {\displaystyle w^{R}=\sigma _{n}\cdots \sigma _{1}} , then for a formal language L {\displaystyle L} , L R = { w R ∣ ∣ w ∈ ∈ L } {\displaystyle L^{R}=\{w^{R}\mid w\in L\}} .

String homomorphism Such string operations are used to investigate closure properties of classes of languages. A class of languages is closed under a particular operation when the operation, applied to languages in the class, always produces a language in the same class again. For instance, the context-free languages are known to be closed under union, concatenation, and intersection with regular languages , but not closed under intersection or complement. The theory of trios and abstract families of languages studies the most common closure properties of language families in their own right.

[ 11 ] Closure properties of language families ( L 1 {\displaystyle L_{1}} Op L 2 {\displaystyle L_{2}} where both L 1 {\displaystyle L_{1}} and L 2 {\displaystyle L_{2}} are in the language family given by the column). After Hopcroft and Ullman.

Operation Regular DCFL CFL IND CSL recursive RE Union L 1 ∪ ∪ L 2 = { w ∣ ∣ w ∈ ∈ L 1 ∨ ∨ w ∈ ∈ L 2 } {\displaystyle L_{1}\cup L_{2}=\{w\mid w\in L_{1}\lor w\in L_{2}\}} Yes No Yes Yes Yes Yes Yes Intersection L 1 ∩ ∩ L 2 = { w ∣ ∣ w ∈ ∈ L 1 ∧ ∧ w ∈ ∈ L 2 } {\displaystyle L_{1}\cap L_{2}=\{w\mid w\in L_{1}\land w\in L_{2}\}} Yes No No No Yes Yes Yes Complement ¬ ¬ L 1 = { w ∣ ∣ w ∉ L 1 } {\displaystyle \neg L_{1}=\{w\mid w\not \in L_{1}\}} Yes Yes No No Yes Yes No Concatenation L 1 ⋅ ⋅ L 2 = { w z ∣ ∣ w ∈ ∈ L 1 ∧ ∧ z ∈ ∈ L 2 } {\displaystyle L_{1}\cdot L_{2}=\{wz\mid w\in L_{1}\land z\in L_{2}\}} Yes No Yes Yes Yes Yes Yes Kleene star L 1 ∗ ∗ = { ε ε } ∪ ∪ { w z ∣ ∣ w ∈ ∈ L 1 ∧ ∧ z ∈ ∈ L 1 ∗ ∗ } {\displaystyle L_{1}^{*}=\{\varepsilon \}\cup \{wz\mid w\in L_{1}\land z\in L_{1}^{*}\}} Yes No Yes Yes Yes Yes Yes (String) homomorphism h {\displaystyle h} h ( L 1 ) = { h ( w ) ∣ ∣ w ∈ ∈ L 1 } {\displaystyle h(L_{1})=\{h(w)\mid w\in L_{1}\}} Yes No Yes Yes No No Yes ε-free (string) homomorphism h {\displaystyle h} h ( L 1 ) = { h ( w ) ∣ ∣ w ∈ ∈ L 1 } {\displaystyle h(L_{1})=\{h(w)\mid w\in L_{1}\}} Yes No Yes Yes Yes Yes Yes Substitution φ φ {\displaystyle \varphi } φ φ ( L 1 ) = ⋃ ⋃ σ σ 1 ⋯ ⋯ σ σ n ∈ ∈ L 1 φ φ ( σ σ 1 ) ⋅ ⋅ … … ⋅ ⋅ φ φ ( σ σ n ) {\displaystyle \varphi (L_{1})=\bigcup _{\sigma _{1}\cdots \sigma _{n}\in L_{1}}\varphi (\sigma _{1})\cdot \ldots \cdot \varphi (\sigma _{n})} Yes No Yes Yes Yes No Yes Inverse homomorphism h − − 1 {\displaystyle h^{-1}} h − − 1 ( L 1 ) = ⋃ ⋃ w ∈ ∈ L 1 h − − 1 ( w ) {\displaystyle h^{-1}(L_{1})=\bigcup _{w\in L_{1}}h^{-1}(w)} Yes Yes Yes Yes Yes Yes Yes Reverse L R = { w R ∣ ∣ w ∈ ∈ L } {\displaystyle L^{R}=\{w^{R}\mid w\in L\}} Yes No Yes Yes Yes Yes Yes Intersection with a regular language R {\displaystyle R} L ∩ ∩ R = { w ∣ ∣ w ∈ ∈ L ∧ ∧ w ∈ ∈ R } {\displaystyle L\cap R=\{w\mid w\in L\land w\in R\}} Yes Yes Yes Yes Yes Yes Yes Applications [ edit ] Programming languages [ edit ] Main articles: Syntax (programming languages) and Compiler-compiler A compiler usually has two distinct components. A lexical analyzer , sometimes generated by a tool like lex , identifies the tokens of the programming language grammar, e.g.

identifiers or keywords , numeric and string literals, punctuation and operator symbols, which are themselves specified by a simpler formal language, usually by means of regular expressions . At the most basic conceptual level, a parser , sometimes generated by a parser generator like yacc , attempts to decide if the source program is syntactically valid, that is if it is well formed with respect to the programming language grammar for which the compiler was built.

Of course, compilers do more than just parse the source code – they usually translate it into some executable format. Because of this, a parser usually outputs more than a yes/no answer, typically an abstract syntax tree . This is used by subsequent stages of the compiler to eventually generate an executable containing machine code that runs directly on the hardware, or some intermediate code that requires a virtual machine to execute.

Formal theories, systems, and proofs [ edit ] Main articles: Theory (mathematical logic) and Formal system This diagram shows the syntactic divisions within a formal system .

Strings of symbols may be broadly divided into nonsense and well-formed formulas . The set of well-formed formulas is divided into theorems and non-theorems.

In mathematical logic , a formal theory is a set of sentences expressed in a formal language.

A formal system (also called a logical calculus , or a logical system ) consists of a formal language together with a deductive apparatus (also called a deductive system ). The deductive apparatus may consist of a set of transformation rules , which may be interpreted as valid rules of inference, or a set of axioms , or have both. A formal system is used to derive one expression from one or more other expressions. Although a formal language can be identified with its formulas, a formal system cannot be likewise identified by its theorems. Two formal systems F S {\displaystyle {\mathcal {FS}}} and F S ′ {\displaystyle {\mathcal {FS'}}} may have all the same theorems and yet differ in some significant proof-theoretic way (a formula A may be a syntactic consequence of a formula B in one but not another for instance).

A formal proof or derivation is a finite sequence of well-formed formulas (which may be interpreted as sentences, or propositions ) each of which is an axiom or follows from the preceding formulas in the sequence by a rule of inference . The last sentence in the sequence is a theorem of a formal system. Formal proofs are useful because their theorems can be interpreted as true propositions.

Interpretations and models [ edit ] Main articles: Formal semantics (logic) , Interpretation (logic) , and Model theory Formal languages are entirely syntactic in nature, but may be given semantics that give meaning to the elements of the language. For instance, in mathematical logic , the set of possible formulas of a particular logic is a formal language, and an interpretation assigns a meaning to each of the formulas—usually, a truth value .

The study of interpretations of formal languages is called formal semantics . In mathematical logic, this is often done in terms of model theory . In model theory, the terms that occur in a formula are interpreted as objects within mathematical structures , and fixed compositional interpretation rules determine how the truth value of the formula can be derived from the interpretation of its terms; a model for a formula is an interpretation of terms such that the formula becomes true.

See also [ edit ] Combinatorics on words Formal method Free monoid Grammar framework Mathematical notation String (computer science) Notes [ edit ] ^ For example, first-order logic is often expressed using an alphabet that, besides symbols such as ∧, ¬, ∀ and parentheses, contains infinitely many elements x 0 , x 1 , x 2 , … that play the role of variables.

References [ edit ] Citations [ edit ] ^ See e.g.

Reghizzi, Stefano Crespi (2009).

Formal Languages and Compilation . Texts in Computer Science. Springer. p. 8.

Bibcode : 2009flc..book.....C .

ISBN 9781848820500 .

An alphabet is a finite set ^ "In the prehistory of formal language theory: Gauss Languages" . January 1992 . Retrieved 30 April 2021 .

^ "Gottlob Frege" . 5 December 2019 . Retrieved 30 April 2021 .

^ Martin Davis (1995).

"Influences of Mathematical Logic on Computer Science" . In Rolf Herken (ed.).

The universal Turing machine: a half-century survey . Springer. p. 290.

ISBN 978-3-211-82637-9 .

^ "Thue's 1914 paper: a translation" (PDF) . 28 August 2013.

Archived (PDF) from the original on 30 April 2021 . Retrieved 30 April 2021 .

^ "Emil Leon Post" . September 2001 . Retrieved 30 April 2021 .

^ Torres Quevedo, Leonardo.

Sobre un sistema de notaciones y símbolos destinados a facilitar la descripción de las máquinas, (pdf) , pp. 25–30, Revista de Obras Públicas, 17 January 1907.

^ Bruderer, Herbert (2021).

"The Global Evolution of Computer Technology" .

Milestones in Analog and Digital Computing . Springer. p. 1212.

ISBN 978-3030409739 .

^ Jager, Gerhard; Rogers, James (19 July 2012).

"Formal language theory: refining the Chomsky hierarchy" .

Philosophical Transactions of the Royal Society B .

367 (1598): 1956– 1970.

doi : 10.1098/rstb.2012.0077 .

PMC 3367686 .

PMID 22688632 .

^ "John Warner Backus" . February 2016 . Retrieved 30 April 2021 .

^ Hopcroft & Ullman (1979) , Chapter 11: Closure properties of families of languages.

Sources [ edit ] Works cited Hopcroft, John E.

; Ullman, Jeffrey D.

(1979).

Introduction to Automata Theory, Languages, and Computation . Reading, Massachusetts: Addison-Wesley Publishing.

ISBN 81-7808-347-7 .

General references A. G. Hamilton, Logic for Mathematicians , Cambridge University Press , 1978, ISBN 0-521-21838-1 .

Seymour Ginsburg , Algebraic and automata theoretic properties of formal languages , North-Holland, 1975, ISBN 0-7204-2506-9 .

Michael A. Harrison , Introduction to Formal Language Theory , Addison-Wesley, 1978.

Rautenberg, Wolfgang (2010).

A Concise Introduction to Mathematical Logic (3rd ed.). New York: Springer Science+Business Media .

doi : 10.1007/978-1-4419-1221-3 .

ISBN 978-1-4419-1220-6 .

Grzegorz Rozenberg , Arto Salomaa , Handbook of Formal Languages: Volume I-III , Springer, 1997, ISBN 3-540-61486-9 .

Patrick Suppes, Introduction to Logic , D. Van Nostrand, 1957, ISBN 0-442-08072-7 .

External links [ edit ] "Formal language" , Encyclopedia of Mathematics , EMS Press , 2001 [1994] University of Maryland , Formal Language Definitions James Power, "Notes on Formal Language Theory and Parsing" Archived 21 November 2007 at the Wayback Machine , 29 November 2002.

Drafts of some chapters in the "Handbook of Formal Language Theory", Vol. 1–3, G. Rozenberg and A. Salomaa (eds.), Springer Verlag , (1997): Alexandru Mateescu and Arto Salomaa, "Preface" in Vol.1, pp. v–viii, and "Formal Languages: An Introduction and a Synopsis", Chapter 1 in Vol. 1, pp. 1–39 Sheng Yu, "Regular Languages", Chapter 2 in Vol. 1 Jean-Michel Autebert, Jean Berstel, Luc Boasson, "Context-Free Languages and Push-Down Automata", Chapter 3 in Vol. 1 Christian Choffrut and Juhani Karhumäki, "Combinatorics of Words", Chapter 6 in Vol. 1 Tero Harju and Juhani Karhumäki, "Morphisms", Chapter 7 in Vol. 1, pp. 439–510 Jean-Eric Pin, "Syntactic semigroups", Chapter 10 in Vol. 1, pp. 679–746 M. Crochemore and C. Hancart, "Automata for matching patterns", Chapter 9 in Vol. 2 Dora Giammarresi, Antonio Restivo, "Two-dimensional Languages", Chapter 4 in Vol. 3, pp. 215–267 v t e Automata theory : formal languages and formal grammars Chomsky hierarchy Grammars Languages Abstract machines Type-0 — Type-1 — — — — — Type-2 — — Type-3 — — Unrestricted (no common name) Context-sensitive Positive range concatenation Indexed — Linear context-free rewriting systems Tree-adjoining Context-free Deterministic context-free Visibly pushdown Regular — Non-recursive Recursively enumerable Decidable Context-sensitive Positive range concatenation * Indexed * — Linear context-free rewriting language Tree-adjoining Context-free Deterministic context-free Visibly pushdown Regular Star-free Finite Turing machine Decider Linear-bounded PTIME Turing Machine Nested stack Thread automaton restricted Tree stack automaton Embedded pushdown Nondeterministic pushdown Deterministic pushdown Visibly pushdown Finite Counter-free (with aperiodic finite monoid) Acyclic finite Each category of languages, except those marked by a * , is a proper subset of the category directly above it.

Any language in each category is generated by a grammar and by an automaton in the category in the same line.

v t e Mathematical logic General Axiom list Cardinality First-order logic Formal proof Formal semantics Foundations of mathematics Information theory Lemma Logical consequence Model Theorem Theory Type theory Theorems ( list ) and paradoxes Gödel's completeness and incompleteness theorems Tarski's undefinability Banach–Tarski paradox Cantor's theorem, paradox and diagonal argument Compactness Halting problem Lindström's Löwenheim–Skolem Russell's paradox Logics Traditional Classical logic Logical truth Tautology Proposition Inference Logical equivalence Consistency Equiconsistency Argument Soundness Validity Syllogism Square of opposition Venn diagram Propositional Boolean algebra Boolean functions Logical connectives Propositional calculus Propositional formula Truth tables Many-valued logic 3 finite ∞ Predicate First-order list Second-order Monadic Higher-order Fixed-point Free Quantifiers Predicate Monadic predicate calculus Set theory Set hereditary Class ( Ur- ) Element Ordinal number Extensionality Forcing Relation equivalence partition Set operations: intersection union complement Cartesian product power set identities Types of sets Countable Uncountable Empty Inhabited Singleton Finite Infinite Transitive Ultrafilter Recursive Fuzzy Universal Universe constructible Grothendieck Von Neumann Maps and cardinality Function / Map domain codomain image In / Sur / Bi -jection Schröder–Bernstein theorem Isomorphism Gödel numbering Enumeration Large cardinal inaccessible Aleph number Operation binary Set theories Zermelo–Fraenkel axiom of choice continuum hypothesis General Kripke–Platek Morse–Kelley Naive New Foundations Tarski–Grothendieck Von Neumann–Bernays–Gödel Ackermann Constructive Formal systems ( list ), language and syntax Alphabet Arity Automata Axiom schema Expression ground Extension by definition conservative Relation Formation rule Grammar Formula atomic closed ground open Free/bound variable Language Metalanguage Logical connective ¬ ∨ ∧ → ↔ = Predicate functional variable propositional variable Proof Quantifier ∃ !

∀ rank Sentence atomic spectrum Signature String Substitution Symbol function logical/constant non-logical variable Term Theory list Example axiomatic systems ( list ) of arithmetic : Peano second-order elementary function primitive recursive Robinson Skolem of the real numbers Tarski's axiomatization of Boolean algebras canonical minimal axioms of geometry : Euclidean : Elements Hilbert's Tarski's non-Euclidean Principia Mathematica Proof theory Formal proof Natural deduction Logical consequence Rule of inference Sequent calculus Theorem Systems axiomatic deductive Hilbert list Complete theory Independence ( from ZFC ) Proof of impossibility Ordinal analysis Reverse mathematics Self-verifying theories Model theory Interpretation function of models Model equivalence finite saturated spectrum submodel Non-standard model of arithmetic Diagram elementary Categorical theory Model complete theory Satisfiability Semantics of logic Strength Theories of truth semantic Tarski's Kripke's T-schema Transfer principle Truth predicate Truth value Type Ultraproduct Validity Computability theory Church encoding Church–Turing thesis Computably enumerable Computable function Computable set Decision problem decidable undecidable P NP P versus NP problem Kolmogorov complexity Lambda calculus Primitive recursive function Recursion Recursive set Turing machine Type theory Related Abstract logic Algebraic logic Automated theorem proving Category theory Concrete / Abstract category Category of sets History of logic History of mathematical logic timeline Logicism Mathematical object Philosophy of mathematics Supertask Mathematics portal Authority control databases National Germany United States France BnF data Japan Czech Republic Israel Other Yale LUX NewPP limit report
Parsed by mw‐web.codfw.main‐6cc77c66b8‐2hwwn
Cached time: 20250812014055
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.626 seconds
Real time usage: 0.865 seconds
Preprocessor visited node count: 3073/1000000
Revision size: 28085/2097152 bytes
Post‐expand include size: 136848/2097152 bytes
Template argument size: 2444/2097152 bytes
Highest expansion depth: 15/100
Expensive parser function count: 15/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 90629/5000000 bytes
Lua time usage: 0.341/10.000 seconds
Lua memory usage: 8024234/52428800 bytes
Number of Wikibase entities loaded: 1/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  603.906      1 -total
 33.11%  199.943      2 Template:Reflist
 16.64%  100.486      5 Template:Cite_book
 11.79%   71.194      1 Template:Formal_languages
 11.58%   69.950      1 Template:Sidebar_with_collapsible_lists
  9.82%   59.324      1 Template:Harvtxt
  9.47%   57.167      1 Template:Short_description
  7.36%   44.419      1 Template:More_citations_needed
  7.30%   44.071      4 Template:Navbox
  7.20%   43.491      2 Template:Ambox Saved in parser cache with key enwiki:pcache:10939:|#|:idhash:canonical and timestamp 20250812014055 and revision id 1301445169. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Formal_language&oldid=1301445169 " Categories : Formal languages Theoretical computer science Combinatorics on words Mathematical linguistics Hidden categories: Articles with short description Short description is different from Wikidata Articles needing additional references from March 2024 All articles needing additional references Use dmy dates from November 2023 Articles to be expanded from March 2021 All articles to be expanded Webarchive template wayback links This page was last edited on 19 July 2025, at 22:12 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Formal language 52 languages Add topic

