Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 History 2 Applications Toggle Applications subsection 2.1 Mathematical foundations 2.2 Proof assistants 2.3 Programming languages 2.4 Linguistics 2.5 Social sciences 3 Logic Toggle Logic subsection 3.1 Terms 3.2 Judgments 3.3 Rules of Inference 3.3.1 Type inhabitation 4 Connections to foundations Toggle Connections to foundations subsection 4.1 Intuitionistic logic 4.1.1 Constructive mathematics 4.2 Curry-Howard correspondence 4.2.1 Type inference 4.3 Research areas 4.3.1 Category theory 4.3.2 Homotopy type theory 5 Definitions Toggle Definitions subsection 5.1 Terms and types 5.1.1 Atomic terms 5.1.2 Function terms 5.1.3 Lambda terms 5.2 Inference Rules 5.2.1 Function application 5.2.2 Reductions 5.3 Common terms and types 5.3.1 Empty type 5.3.2 Unit type 5.3.3 Boolean type 5.3.4 Natural numbers 5.4 Type constructors 5.4.1 Product type 5.4.2 Sum type 5.5 Polymorphic types 5.5.1 Products and sums 5.6 Dependent typing 5.6.1 Dependent products and sums 5.6.2 Identity type 5.6.3 Inductive types 6 Differences from set theory Toggle Differences from set theory subsection 6.1 Properties of type theories 6.2 Axioms 7 List of type theories Toggle List of type theories subsection 7.1 Major 7.2 Minor 7.3 Active research 8 See also 9 Further reading 10 Notes 11 References 12 External links Toggle External links subsection 12.1 Introductory material 12.2 Advanced material Toggle the table of contents Type theory 24 languages العربية Azərbaycanca Čeština Deutsch Eesti Ελληνικά Español Esperanto فارسی Français 한국어 Italiano עברית Қазақша Nederlands 日本語 Norsk bokmål Polski Português Русский Українська Tiếng Việt 粵語 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Mathematical theory of data types "Theory of types" redirects here. For an architectural term, see Form (architecture) § Theories .

In mathematics and theoretical computer science , a type theory is the formal presentation of a specific type system .

[ a ] Type theory is the academic study of type systems.

Some type theories serve as alternatives to set theory as a foundation of mathematics . Two influential type theories that have been proposed as foundations are: Typed λ-calculus of Alonzo Church Intuitionistic type theory of Per Martin-Löf Most computerized proof-writing systems use a type theory for their foundation . A common one is Thierry Coquand 's Calculus of Inductive Constructions .

History [ edit ] Main article: History of type theory Type theory was created to avoid paradoxes in naive set theory and formal logic [ b ] , such as Russell's paradox which demonstrates that, without proper axioms, it is possible to define the set of all sets that are not members of themselves; this set both contains itself and does not contain itself. Between 1902 and 1908, Bertrand Russell proposed various solutions to this problem.

By 1908, Russell arrived at a ramified theory of types together with an axiom of reducibility , both of which appeared in Whitehead and Russell 's Principia Mathematica published in 1910, 1912, and 1913. This system avoided contradictions suggested in Russell's paradox by creating a hierarchy of types and then assigning each concrete mathematical entity to a specific type. Entities of a given type were built exclusively of subtypes of that type, [ c ] thus preventing an entity from being defined using itself. This resolution of Russell's paradox is similar to approaches taken in other formal systems, such as Zermelo-Fraenkel set theory .

[ 4 ] Type theory is particularly popular in conjunction with Alonzo Church 's lambda calculus . One notable early example of type theory is Church's simply typed lambda calculus . Church's theory of types [ 5 ] helped the formal system avoid the Kleene–Rosser paradox that afflicted the original untyped lambda calculus. Church demonstrated [ d ] that it could serve as a foundation of mathematics and it was referred to as a higher-order logic .

In the modern literature, "type theory" refers to a typed system based around lambda calculus. One influential system is Per Martin-Löf 's intuitionistic type theory , which was proposed as a foundation for constructive mathematics . Another is Thierry Coquand 's calculus of constructions , which is used as the foundation by Rocq (previously known as Coq ), Lean , and other computer proof assistants . Type theory is an active area of research, one direction being the development of homotopy type theory .

Applications [ edit ] Mathematical foundations [ edit ] The first computer proof assistant, called Automath , used type theory to encode mathematics on a computer. Martin-Löf specifically developed intuitionistic type theory to encode all mathematics to serve as a new foundation for mathematics. There is ongoing research into mathematical foundations using homotopy type theory .

Mathematicians working in category theory already had difficulty working with the widely accepted foundation of Zermelo–Fraenkel set theory . This led to proposals such as Lawvere's Elementary Theory of the Category of Sets (ETCS).

[ 7 ] Homotopy type theory continues in this line using type theory. Researchers are exploring connections between dependent types (especially the identity type) and algebraic topology (specifically homotopy ).

Proof assistants [ edit ] Main article: Proof assistant Much of the current research into type theory is driven by proof checkers , interactive proof assistants , and automated theorem provers . Most of these systems use a type theory as the mathematical foundation for encoding proofs, which is not surprising, given the close connection between type theory and programming languages: LF is used by Twelf , often to define other type theories; many type theories which fall under higher-order logic are used by the HOL family of provers and PVS ; computational type theory is used by NuPRL ; calculus of constructions and its derivatives are used by Rocq (previously known as Coq ), Matita , and Lean ; UTT (Luo's Unified Theory of dependent Types) is used by Agda which is both a programming language and proof assistant Many type theories are supported by LEGO and Isabelle . Isabelle also supports foundations besides type theories, such as ZFC .

Mizar is an example of a proof system that only supports set theory.

Programming languages [ edit ] Any static program analysis , such as the type checking algorithms in the semantic analysis phase of compiler , has a connection to type theory. A prime example is Agda , a programming language which uses UTT (Luo's Unified Theory of dependent Types) for its type system.

The programming language ML was developed for manipulating type theories (see LCF ) and its own type system was heavily influenced by them.

Linguistics [ edit ] Type theory is also widely used in formal theories of semantics of natural languages , [ 8 ] [ 9 ] especially Montague grammar [ 10 ] and its descendants. In particular, categorial grammars and pregroup grammars extensively use type constructors to define the types ( noun , verb , etc.) of words.

The most common construction takes the basic types e {\displaystyle e} and t {\displaystyle t} for individuals and truth-values , respectively, and defines the set of types recursively as follows: if a {\displaystyle a} and b {\displaystyle b} are types, then so is ⟨ ⟨ a , b ⟩ ⟩ {\displaystyle \langle a,b\rangle } ; nothing except the basic types, and what can be constructed from them by means of the previous clause are types.

A complex type ⟨ ⟨ a , b ⟩ ⟩ {\displaystyle \langle a,b\rangle } is the type of functions from entities of type a {\displaystyle a} to entities of type b {\displaystyle b} . Thus one has types like ⟨ ⟨ e , t ⟩ ⟩ {\displaystyle \langle e,t\rangle } which are interpreted as elements of the set of functions from entities to truth-values, i.e.

indicator functions of sets of entities. An expression of type ⟨ ⟨ ⟨ ⟨ e , t ⟩ ⟩ , t ⟩ ⟩ {\displaystyle \langle \langle e,t\rangle ,t\rangle } is a function from sets of entities to truth-values, i.e. a (indicator function of a) set of sets. This latter type is standardly taken to be the type of natural language quantifiers , like everybody or nobody ( Montague 1973, Barwise and Cooper 1981).

[ 11 ] Type theory with records is a formal semantics representation framework, using records to express type theory types . It has been used in natural language processing , principally computational semantics and dialogue systems .

[ 12 ] [ 13 ] Social sciences [ edit ] Gregory Bateson introduced a theory of logical types into the social sciences; his notions of double bind and logical levels are based on Russell's theory of types.

Logic [ edit ] A type theory is a mathematical logic , which is to say it is a collection of rules of inference that result in judgments . Most logics have judgments asserting "The proposition φ φ {\displaystyle \varphi } is true", or "The formula φ φ {\displaystyle \varphi } is a well-formed formula ".

[ 14 ] A type theory has judgments that define types and assign them to a collection of formal objects, known as terms. A term and its type are often written together as t e r m : t y p e {\displaystyle \mathrm {term} :{\mathsf {type}}} .

Terms [ edit ] A term in logic is recursively defined as a constant symbol , variable , or a function application , where a term is applied to another term. Constant symbols could include the natural number 0 {\displaystyle 0} , the Boolean value t r u e {\displaystyle \mathrm {true} } , and functions such as the successor function S {\displaystyle \mathrm {S} } and conditional operator i f {\displaystyle \mathrm {if} } . Thus some terms could be 0 {\displaystyle 0} , ( S 0 ) {\displaystyle (\mathrm {S} \,0)} , ( S ( S 0 ) ) {\displaystyle (\mathrm {S} \,(\mathrm {S} \,0))} , and ( i f t r u e 0 ( S 0 ) ) {\displaystyle (\mathrm {if} \,\mathrm {true} \,0\,(\mathrm {S} \,0))} .

Judgments [ edit ] Most type theories have 4 judgments: " T {\displaystyle T} is a type " " t {\displaystyle t} is a term of type T {\displaystyle T} " "Type T 1 {\displaystyle T_{1}} is equal to type T 2 {\displaystyle T_{2}} " "Terms t 1 {\displaystyle t_{1}} and t 2 {\displaystyle t_{2}} both of type T {\displaystyle T} are equal " Judgments may follow from assumptions. For example, one might say "assuming x {\displaystyle x} is a term of type b o o l {\displaystyle {\mathsf {bool}}} and y {\displaystyle y} is a term of type n a t {\displaystyle {\mathsf {nat}}} , it follows that ( i f x y y ) {\displaystyle (\mathrm {if} \,x\,y\,y)} is a term of type n a t {\displaystyle {\mathsf {nat}}} ". Such judgments are formally written with the turnstile symbol ⊢ ⊢ {\displaystyle \vdash } .

x : b o o l , y : n a t ⊢ ⊢ ( if x y y ) : n a t {\displaystyle x:{\mathsf {bool}},y:{\mathsf {nat}}\vdash ({\textrm {if}}\,x\,y\,y):{\mathsf {nat}}} If there are no assumptions, there will be nothing to the left of the turnstile.

⊢ ⊢ S : n a t → → n a t {\displaystyle \vdash \mathrm {S} :{\mathsf {nat}}\to {\mathsf {nat}}} The list of assumptions on the left is the context of the judgment. Capital greek letters, such as Γ Γ {\displaystyle \Gamma } and Δ Δ {\displaystyle \Delta } , are common choices to represent some or all of the assumptions. The 4 different judgments are thus usually written as follows.

Formal notation for judgments Description Γ Γ ⊢ ⊢ T {\displaystyle \Gamma \vdash T} Type T {\displaystyle T} is a type (under assumptions Γ Γ {\displaystyle \Gamma } ).

Γ Γ ⊢ ⊢ t : T {\displaystyle \Gamma \vdash t:T} t {\displaystyle t} is a term of type T {\displaystyle T} (under assumptions Γ Γ {\displaystyle \Gamma } ).

Γ Γ ⊢ ⊢ T 1 = T 2 {\displaystyle \Gamma \vdash T_{1}=T_{2}} Type T 1 {\displaystyle T_{1}} is equal to type T 2 {\displaystyle T_{2}} (under assumptions Γ Γ {\displaystyle \Gamma } ).

Γ Γ ⊢ ⊢ t 1 = t 2 : T {\displaystyle \Gamma \vdash t_{1}=t_{2}:T} Terms t 1 {\displaystyle t_{1}} and t 2 {\displaystyle t_{2}} are both of type T {\displaystyle T} and are equal (under assumptions Γ Γ {\displaystyle \Gamma } ).

Some textbooks use a triple equal sign ≡ ≡ {\displaystyle \equiv } to stress that this is judgmental equality and thus an extrinsic notion of equality.

[ 15 ] The judgments enforce that every term has a type. The type will restrict which rules can be applied to a term.

Rules of Inference [ edit ] A type theory's inference rules say what judgments can be made, based on the existence of other judgments. Rules are expressed as a Gentzen -style deduction using a horizontal line, with the required input judgments above the line and the resulting judgment below the line.

[ 16 ] For example, the following inference rule states a substitution rule for judgmental equality.

Γ Γ ⊢ ⊢ t : T 1 Δ Δ ⊢ ⊢ T 1 = T 2 Γ Γ , Δ Δ ⊢ ⊢ t : T 2 {\displaystyle {\begin{array}{c}\Gamma \vdash t:T_{1}\qquad \Delta \vdash T_{1}=T_{2}\\\hline \Gamma ,\Delta \vdash t:T_{2}\end{array}}} The rules are syntactic and work by rewriting . The metavariables Γ Γ {\displaystyle \Gamma } , Δ Δ {\displaystyle \Delta } , t {\displaystyle t} , T 1 {\displaystyle T_{1}} , and T 2 {\displaystyle T_{2}} may actually consist of complex terms and types that contain many function applications, not just single symbols.

To generate a particular judgment in type theory, there must be a rule to generate it, as well as rules to generate all of that rule's required inputs, and so on. The applied rules form a proof tree , where the top-most rules need no assumptions. One example of a rule that does not require any inputs is one that states the type of a constant term. For example, to assert that there is a term 0 {\displaystyle 0} of type n a t {\displaystyle {\mathsf {nat}}} , one would write the following.

⊢ ⊢ 0 : n a t {\displaystyle {\begin{array}{c}\hline \vdash 0:nat\\\end{array}}} Type inhabitation [ edit ] Main article: Type inhabitation Generally, the desired conclusion of a proof in type theory is one of type inhabitation .

[ 17 ] The decision problem of type inhabitation (abbreviated by ∃ ∃ t .

Γ Γ ⊢ ⊢ t : τ τ ?

{\displaystyle \exists t.\Gamma \vdash t:\tau ?} ) is: Given a context Γ Γ {\displaystyle \Gamma } and a type τ τ {\displaystyle \tau } , decide whether there exists a term t {\displaystyle t} that can be assigned the type τ τ {\displaystyle \tau } in the type environment Γ Γ {\displaystyle \Gamma } .

Girard's paradox shows that type inhabitation is strongly related to the consistency of a type system with Curry–Howard correspondence. To be sound, such a system must have uninhabited types.

A type theory usually has several rules, including ones to: create a judgment (known as a context in this case) add an assumption to the context (context weakening ) rearrange the assumptions use an assumption to create a variable define reflexivity , symmetry and transitivity for judgmental equality define substitution for application of lambda terms list all the interactions of equality, such as substitution define a hierarchy of type universes assert the existence of new types Also, for each "by rule" type, there are 4 different kinds of rules "type formation" rules say how to create the type "term introduction" rules define the canonical terms and constructor functions, like "pair" and "S".

"term elimination" rules define the other functions like "first", "second", and "R".

"computation" rules specify how computation is performed with the type-specific functions.

For examples of rules, an interested reader may follow Appendix A.2 of the Homotopy Type Theory book, [ 15 ] or read Martin-Löf's Intuitionistic Type Theory.

[ 18 ] Connections to foundations [ edit ] The logical framework of a type theory bears a resemblance to intuitionistic , or constructive, logic. Formally, type theory is often cited as an implementation of the Brouwer–Heyting–Kolmogorov interpretation of intuitionistic logic.

[ 18 ] Additionally, connections can be made to category theory and computer programs .

Intuitionistic logic [ edit ] When used as a foundation, certain types are interpreted to be propositions (statements that can be proven), and terms inhabiting the type are interpreted to be proofs of that proposition. When some types are interpreted as propositions, there is a set of common types that can be used to connect them to make a Boolean algebra out of types. However, the logic is not classical logic but intuitionistic logic , which is to say it does not have the law of excluded middle nor double negation .

Under this intuitionistic interpretation, there are common types that act as the logical operators: Logic Name Logic Notation Type Notation Type Name True ⊤ ⊤ {\displaystyle \top } ⊤ ⊤ {\displaystyle \top } Unit Type False ⊥ ⊥ {\displaystyle \bot } ⊥ ⊥ {\displaystyle \bot } Empty Type Implication A → → B {\displaystyle A\to B} A → → B {\displaystyle A\to B} Function Not ¬ ¬ A {\displaystyle \neg A} A → → ⊥ ⊥ {\displaystyle A\to \bot } Function to Empty Type And A ∧ ∧ B {\displaystyle A\land B} A × × B {\displaystyle A\times B} Product Type Or A ∨ ∨ B {\displaystyle A\lor B} A + B {\displaystyle A+B} Sum Type For All ∀ ∀ a ∈ ∈ A , P ( a ) {\displaystyle \forall a\in A,P(a)} Π Π a : A .

P ( a ) {\displaystyle \Pi a:A.P(a)} Dependent Product Exists ∃ ∃ a ∈ ∈ A , P ( a ) {\displaystyle \exists a\in A,P(a)} Σ Σ a : A .

P ( a ) {\displaystyle \Sigma a:A.P(a)} Dependent Sum Because the law of excluded middle does not hold, there is no term of type Π Π a .

A + ( A → → ⊥ ⊥ ) {\displaystyle \Pi a.A+(A\to \bot )} . Likewise, double negation does not hold, so there is no term of type Π Π A .

( ( A → → ⊥ ⊥ ) → → ⊥ ⊥ ) → → A {\displaystyle \Pi A.((A\to \bot )\to \bot )\to A} .

It is possible to include the law of excluded middle and double negation into a type theory, by rule or assumption. However, terms may not compute down to canonical terms and it will interfere with the ability to determine if two terms are judgementally equal to each other.

[ citation needed ] Constructive mathematics [ edit ] Per Martin-Löf proposed his intuitionistic type theory as a foundation for constructive mathematics .

[ 14 ] Constructive mathematics requires when proving "there exists an x {\displaystyle x} with property P ( x ) {\displaystyle P(x)} ", one must construct a particular x {\displaystyle x} and a proof that it has property P {\displaystyle P} . In type theory, existence is accomplished using the dependent product type, and its proof requires a term of that type.

An example of a non-constructive proof is proof by contradiction . The first step is assuming that x {\displaystyle x} does not exist and refuting it by contradiction. The conclusion from that step is "it is not the case that x {\displaystyle x} does not exist". The last step is, by double negation, concluding that x {\displaystyle x} exists. Constructive mathematics does not allow the last step of removing the double negation to conclude that x {\displaystyle x} exists.

[ 19 ] Most of the type theories proposed as foundations are constructive, and this includes most of the ones used by proof assistants.

[ citation needed ] It is possible to add non-constructive features to a type theory, by rule or assumption. These include operators on continuations such as call with current continuation . However, these operators tend to break desirable properties such as canonicity and parametricity .

Curry-Howard correspondence [ edit ] The Curry–Howard correspondence is the observed similarity between logics and programming languages. The implication in logic, "A → → {\displaystyle \to } B" resembles a function from type "A" to type "B". For a variety of logics, the rules are similar to expressions in a programming language's types. The similarity goes farther, as applications of the rules resemble programs in the programming languages. Thus, the correspondence is often summarized as "proofs as programs".

The opposition of terms and types can also be viewed as one of implementation and specification . By program synthesis , (the computational counterpart of) type inhabitation can be used to construct (all or parts of) programs from the specification given in the form of type information.

[ 20 ] Type inference [ edit ] Main article: Type inference Many programs that work with type theory (e.g., interactive theorem provers) also do type inferencing. It lets them select the rules that the user intends, with fewer actions by the user.

Research areas [ edit ] Category theory [ edit ] Although the initial motivation for category theory was far removed from foundationalism, the two fields turned out to have deep connections. As John Lane Bell writes: "In fact categories can themselves be viewed as type theories of a certain kind; this fact alone indicates that type theory is much more closely related to category theory than it is to set theory." In brief, a category can be viewed as a type theory by regarding its objects as types (or sorts [ 21 ] ), i.e. "Roughly speaking, a category may be thought of as a type theory shorn of its syntax." A number of significant results follow in this way: [ 22 ] cartesian closed categories correspond to the typed λ-calculus ( Lambek , 1970); C-monoids (categories with products and exponentials and one non-terminal object) correspond to the untyped λ-calculus (observed independently by Lambek and Dana Scott around 1980); locally cartesian closed categories correspond to Martin-Löf type theories (Seely, 1984).

The interplay, known as categorical logic , has been a subject of active research since then; see the monograph of Jacobs (1999) for instance.

Homotopy type theory [ edit ] Homotopy type theory attempts to combine type theory and category theory. It focuses on equalities, especially equalities between types.

Homotopy type theory differs from intuitionistic type theory mostly by its handling of the equality type. In 2016, cubical type theory was proposed, which is a homotopy type theory with normalization.

[ 23 ] [ 24 ] Definitions [ edit ] Terms and types [ edit ] Atomic terms [ edit ] The most basic types are called atoms, and a term whose type is an atom is known as an atomic term. Common atomic terms included in type theories are natural numbers , often notated with the type n a t {\displaystyle {\mathsf {nat}}} , Boolean logic values ( t r u e {\displaystyle \mathrm {true} } / f a l s e {\displaystyle \mathrm {false} } ), notated with the type b o o l {\displaystyle {\mathsf {bool}}} , and formal variables , whose type may vary.

[ 17 ] For example, the following may be atomic terms.

42 : n a t {\displaystyle 42:{\mathsf {nat}}} t r u e : b o o l {\displaystyle \mathrm {true} :{\mathsf {bool}}} x : n a t {\displaystyle x:{\mathsf {nat}}} y : b o o l {\displaystyle y:{\mathsf {bool}}} Function terms [ edit ] In addition to atomic terms, most modern type theories also allow for functions . Function types introduce an arrow symbol, and are defined inductively : If σ σ {\displaystyle \sigma } and τ τ {\displaystyle \tau } are types, then the notation σ σ → → τ τ {\displaystyle \sigma \to \tau } is the type of a function which takes a parameter of type σ σ {\displaystyle \sigma } and returns a term of type τ τ {\displaystyle \tau } . Types of this form are known as simple types .

[ 17 ] Some terms may be declared directly as having a simple type, such as the following term, a d d {\displaystyle \mathrm {add} } , which takes in two natural numbers in sequence and returns one natural number.

a d d : n a t → → ( n a t → → n a t ) {\displaystyle \mathrm {add} :{\mathsf {nat}}\to ({\mathsf {nat}}\to {\mathsf {nat}})} Strictly speaking, a simple type only allows for one input and one output, so a more faithful reading of the above type is that a d d {\displaystyle \mathrm {add} } is a function which takes in a natural number and returns a function of the form n a t → → n a t {\displaystyle {\mathsf {nat}}\to {\mathsf {nat}}} . The parentheses clarify that a d d {\displaystyle \mathrm {add} } does not have the type ( n a t → → n a t ) → → n a t {\displaystyle ({\mathsf {nat}}\to {\mathsf {nat}})\to {\mathsf {nat}}} , which would be a function which takes in a function of natural numbers and returns a natural number. The convention is that the arrow is right associative , so the parentheses may be dropped from a d d {\displaystyle \mathrm {add} } 's type.

[ 17 ] Lambda terms [ edit ] New function terms may be constructed using lambda expressions , and are called lambda terms. These terms are also defined inductively: a lambda term has the form ( λ λ v .

t ) {\displaystyle (\lambda v.t)} , where v {\displaystyle v} is a formal variable and t {\displaystyle t} is a term, and its type is notated σ σ → → τ τ {\displaystyle \sigma \to \tau } , where σ σ {\displaystyle \sigma } is the type of v {\displaystyle v} , and τ τ {\displaystyle \tau } is the type of t {\displaystyle t} .

[ 17 ] The following lambda term represents a function which doubles an input natural number.

( λ λ x .

a d d x x ) : n a t → → n a t {\displaystyle (\lambda x.\mathrm {add} \,x\,x):{\mathsf {nat}}\to {\mathsf {nat}}} The variable is x {\displaystyle x} and (implicit from the lambda term's type) must have type n a t {\displaystyle {\mathsf {nat}}} . The term a d d x x {\displaystyle \mathrm {add} \,x\,x} has type n a t {\displaystyle {\mathsf {nat}}} , which is seen by applying the function application inference rule twice. Thus, the lambda term has type n a t → → n a t {\displaystyle {\mathsf {nat}}\to {\mathsf {nat}}} , which means it is a function taking a natural number as an argument and returning a natural number.

A lambda term is often referred to [ e ] as an anonymous function because it lacks a name. The concept of anonymous functions appears in many programming languages.

Inference Rules [ edit ] Function application [ edit ] The power of type theories is in specifying how terms may be combined by way of inference rules .

[ 5 ] Type theories which have functions also have the inference rule of function application : if t {\displaystyle t} is a term of type σ σ → → τ τ {\displaystyle \sigma \to \tau } , and s {\displaystyle s} is a term of type σ σ {\displaystyle \sigma } , then the application of t {\displaystyle t} to s {\displaystyle s} , often written ( t s ) {\displaystyle (t\,s)} , has type τ τ {\displaystyle \tau } . For example, if one knows the type notations 0 : nat {\displaystyle 0:{\textsf {nat}}} , 1 : nat {\displaystyle 1:{\textsf {nat}}} , and 2 : nat {\displaystyle 2:{\textsf {nat}}} , then the following type notations can be deduced from function application.

[ 17 ] ( a d d 1 ) : nat → → nat {\displaystyle (\mathrm {add} \,1):{\textsf {nat}}\to {\textsf {nat}}} ( ( a d d 2 ) 0 ) : nat {\displaystyle ((\mathrm {add} \,2)\,0):{\textsf {nat}}} ( ( a d d 1 ) ( ( a d d 2 ) 0 ) ) : nat {\displaystyle ((\mathrm {add} \,1)((\mathrm {add} \,2)\,0)):{\textsf {nat}}} Parentheses indicate the order of operations ; however, by convention, function application is left associative , so parentheses can be dropped where appropriate.

[ 17 ] In the case of the three examples above, all parentheses could be omitted from the first two, and the third may simplified to a d d 1 ( a d d 2 0 ) : nat {\displaystyle \mathrm {add} \,1\,(\mathrm {add} \,2\,0):{\textsf {nat}}} .

Reductions [ edit ] Type theories that allow for lambda terms also include inference rules known as β β {\displaystyle \beta } -reduction and η η {\displaystyle \eta } -reduction. They generalize the notion of function application to lambda terms. Symbolically, they are written ( λ λ v .

t ) s → → t [ v : : = s ] {\displaystyle (\lambda v.t)\,s\rightarrow t[v\colon =s]} ( β β {\displaystyle \beta } -reduction).

( λ λ v .

t v ) → → t {\displaystyle (\lambda v.t\,v)\rightarrow t} , if v {\displaystyle v} is not a free variable in t {\displaystyle t} ( η η {\displaystyle \eta } -reduction).

The first reduction describes how to evaluate a lambda term: if a lambda expression ( λ λ v .

t ) {\displaystyle (\lambda v.t)} is applied to a term s {\displaystyle s} , one replaces every occurrence of v {\displaystyle v} in t {\displaystyle t} with s {\displaystyle s} . The second reduction makes explicit the relationship between lambda expressions and function types: if ( λ λ v .

t v ) {\displaystyle (\lambda v.t\,v)} is a lambda term, then it must be that t {\displaystyle t} is a function term because it is being applied to v {\displaystyle v} . Therefore, the lambda expression is equivalent to just t {\displaystyle t} , as both take in one argument and apply t {\displaystyle t} to it.

[ 5 ] For example, the following term may be β β {\displaystyle \beta } -reduced.

( λ λ x .

a d d x x ) 2 → → a d d 2 2 {\displaystyle (\lambda x.\mathrm {add} \,x\,x)\,2\rightarrow \mathrm {add} \,2\,2} In type theories that also establish notions of equality for types and terms, there are corresponding inference rules of β β {\displaystyle \beta } -equality and η η {\displaystyle \eta } -equality.

[ 17 ] Common terms and types [ edit ] Empty type [ edit ] The empty type has no terms. The type is usually written ⊥ ⊥ {\displaystyle \bot } or 0 {\displaystyle \mathbb {0} } . One use for the empty type is proofs of type inhabitation . If for a type a {\displaystyle a} , it is consistent to derive a function of type a → → ⊥ ⊥ {\displaystyle a\to \bot } , then a {\displaystyle a} is uninhabited , which is to say it has no terms.

Unit type [ edit ] The unit type has exactly 1 canonical term. The type is written ⊤ ⊤ {\displaystyle \top } or 1 {\displaystyle \mathbb {1} } and the single canonical term is written ∗ ∗ {\displaystyle \ast } . The unit type is also used in proofs of type inhabitation. If for a type a {\displaystyle a} , it is consistent to derive a function of type ⊤ ⊤ → → a {\displaystyle \top \to a} , then a {\displaystyle a} is inhabited , which is to say it must have one or more terms.

Boolean type [ edit ] The Boolean type has exactly 2 canonical terms. The type is usually written bool {\displaystyle {\textsf {bool}}} or B {\displaystyle \mathbb {B} } or 2 {\displaystyle \mathbb {2} } . The canonical terms are usually t r u e {\displaystyle \mathrm {true} } and f a l s e {\displaystyle \mathrm {false} } .

Natural numbers [ edit ] Natural numbers are usually implemented in the style of Peano Arithmetic . There is a canonical term 0 : n a t {\displaystyle 0:{\mathsf {nat}}} for zero. Canonical values larger than zero use iterated applications of a successor function S : n a t → → n a t {\displaystyle \mathrm {S} :{\mathsf {nat}}\to {\mathsf {nat}}} .

Type constructors [ edit ] Some type theories allow for types of complex terms, such as functions or lists, to depend on the types of its arguments; these are called type constructors . For example, a type theory could have the dependent type l i s t a {\displaystyle {\mathsf {list}}\,a} , which should correspond to lists of terms, where each term must have type a {\displaystyle a} . In this case, l i s t {\displaystyle {\mathsf {list}}} has the kind U → → U {\displaystyle U\to U} , where U {\displaystyle U} denotes the universe of all types in the theory.

Product type [ edit ] The product type, × × {\displaystyle \times } , depends on two types, and its terms are commonly written as ordered pairs ( s , t ) {\displaystyle (s,t)} . The pair ( s , t ) {\displaystyle (s,t)} has the product type σ σ × × τ τ {\displaystyle \sigma \times \tau } , where σ σ {\displaystyle \sigma } is the type of s {\displaystyle s} and τ τ {\displaystyle \tau } is the type of t {\displaystyle t} . Each product type is then usually defined with eliminator functions f i r s t : σ σ × × τ τ → → σ σ {\displaystyle \mathrm {first} :\sigma \times \tau \to \sigma } and s e c o n d : σ σ × × τ τ → → τ τ {\displaystyle \mathrm {second} :\sigma \times \tau \to \tau } .

f i r s t ( s , t ) {\displaystyle \mathrm {first} \,(s,t)} returns s {\displaystyle s} , and s e c o n d ( s , t ) {\displaystyle \mathrm {second} \,(s,t)} returns t {\displaystyle t} .

Besides ordered pairs, this type is used for the concepts of logical conjunction and intersection .

Sum type [ edit ] The sum type is written as either + {\displaystyle +} or ⊔ ⊔ {\displaystyle \sqcup } . In programming languages, sum types may be referred to as tagged unions . Each type σ σ ⊔ ⊔ τ τ {\displaystyle \sigma \sqcup \tau } is usually defined with constructors l e f t : σ σ → → ( σ σ ⊔ ⊔ τ τ ) {\displaystyle \mathrm {left} :\sigma \to (\sigma \sqcup \tau )} and r i g h t : τ τ → → ( σ σ ⊔ ⊔ τ τ ) {\displaystyle \mathrm {right} :\tau \to (\sigma \sqcup \tau )} , which are injective , and an eliminator function m a t c h : ( σ σ → → ρ ρ ) → → ( τ τ → → ρ ρ ) → → ( σ σ ⊔ ⊔ τ τ ) → → ρ ρ {\displaystyle \mathrm {match} :(\sigma \to \rho )\to (\tau \to \rho )\to (\sigma \sqcup \tau )\to \rho } such that m a t c h f g ( l e f t x ) {\displaystyle \mathrm {match} \,f\,g\,(\mathrm {left} \,x)} returns f x {\displaystyle f\,x} , and m a t c h f g ( r i g h t y ) {\displaystyle \mathrm {match} \,f\,g\,(\mathrm {right} \,y)} returns g y {\displaystyle g\,y} .

The sum type is used for the concepts of logical disjunction and union .

Polymorphic types [ edit ] Some theories also allow terms to have their definitions depend on types. For instance, an identity function of any type could be written as λ λ x .

x : ∀ ∀ α α .

α α → → α α {\displaystyle \lambda x.x:\forall \alpha .\alpha \to \alpha } . The function is said to be polymorphic in α α {\displaystyle \alpha } , or generic in x {\displaystyle x} .

As another example, consider a function a p p e n d {\displaystyle \mathrm {append} } , which takes in a l i s t a {\displaystyle {\mathsf {list}}\,a} and a term of type a {\displaystyle a} , and returns the list with the element at the end. The type annotation of such a function would be a p p e n d : ∀ ∀ a .

l i s t a → → a → → l i s t a {\displaystyle \mathrm {append} :\forall \,a.{\mathsf {list}}\,a\to a\to {\mathsf {list}}\,a} , which can be read as "for any type a {\displaystyle a} , pass in a l i s t a {\displaystyle {\mathsf {list}}\,a} and an a {\displaystyle a} , and return a l i s t a {\displaystyle {\mathsf {list}}\,a} ". Here a p p e n d {\displaystyle \mathrm {append} } is polymorphic in a {\displaystyle a} .

Products and sums [ edit ] With polymorphism, the eliminator functions can be defined generically for all product types as f i r s t : ∀ ∀ σ σ τ τ .

σ σ × × τ τ → → σ σ {\displaystyle \mathrm {first} :\forall \,\sigma \,\tau .\sigma \times \tau \to \sigma } and s e c o n d : ∀ ∀ σ σ τ τ .

σ σ × × τ τ → → τ τ {\displaystyle \mathrm {second} :\forall \,\sigma \,\tau .\sigma \times \tau \to \tau } .

f i r s t ( s , t ) {\displaystyle \mathrm {first} \,(s,t)} returns s {\displaystyle s} , and s e c o n d ( s , t ) {\displaystyle \mathrm {second} \,(s,t)} returns t {\displaystyle t} .

Likewise, the sum type constructors can be defined for all valid types of sum members as l e f t : ∀ ∀ σ σ τ τ .

σ σ → → ( σ σ ⊔ ⊔ τ τ ) {\displaystyle \mathrm {left} :\forall \,\sigma \,\tau .\sigma \to (\sigma \sqcup \tau )} and r i g h t : ∀ ∀ σ σ τ τ .

τ τ → → ( σ σ ⊔ ⊔ τ τ ) {\displaystyle \mathrm {right} :\forall \,\sigma \,\tau .\tau \to (\sigma \sqcup \tau )} , which are injective , and the eliminator function can be given as m a t c h : ∀ ∀ σ σ τ τ ρ ρ .

( σ σ → → ρ ρ ) → → ( τ τ → → ρ ρ ) → → ( σ σ ⊔ ⊔ τ τ ) → → ρ ρ {\displaystyle \mathrm {match} :\forall \,\sigma \,\tau \,\rho .(\sigma \to \rho )\to (\tau \to \rho )\to (\sigma \sqcup \tau )\to \rho } such that m a t c h f g ( l e f t x ) {\displaystyle \mathrm {match} \,f\,g\,(\mathrm {left} \,x)} returns f x {\displaystyle f\,x} , and m a t c h f g ( r i g h t y ) {\displaystyle \mathrm {match} \,f\,g\,(\mathrm {right} \,y)} returns g y {\displaystyle g\,y} .

Dependent typing [ edit ] Some theories also permit types to be dependent on terms instead of types. For example, a theory could have the type v e c t o r n {\displaystyle {\mathsf {vector}}\,n} , where n {\displaystyle n} is a term of type n a t {\displaystyle {\mathsf {nat}}} encoding the length of the vector . This allows for greater specificity and type safety : functions with vector length restrictions or length matching requirements, such as the dot product , can encode this requirement as part of the type.

[ 26 ] There are foundational issues that can arise from dependent types if a theory is not careful about what dependencies are allowed, such as Girard's Paradox . The logician Henk Barendegt introduced the lambda cube as a framework for studying various restrictions and levels of dependent typing.

[ 27 ] Dependent products and sums [ edit ] Two common type dependencies , dependent product and dependent sum types, allow for the theory to encode BHK intuitionistic logic by acting as equivalents to universal and existential quantification ; this is formalized by Curry–Howard Correspondence .

[ 26 ] As they also connect to products and sums in set theory , they are often written with the symbols Π Π {\displaystyle \Pi } and Σ Σ {\displaystyle \Sigma } , respectively.

Sum types are seen in dependent pairs , where the second type depends on the value of the first term. This arises naturally in computer science where functions may return different types of outputs based on the input. For example, the Boolean type is usually defined with an eliminator function i f {\displaystyle \mathrm {if} } , which takes three arguments and behaves as follows.

i f t r u e x y {\displaystyle \mathrm {if} \,\mathrm {true} \,x\,y} returns x {\displaystyle x} , and i f f a l s e x y {\displaystyle \mathrm {if} \,\mathrm {false} \,x\,y} returns y {\displaystyle y} .

Ordinary definitions of i f {\displaystyle \mathrm {if} } require x {\displaystyle x} and y {\displaystyle y} to have the same type. If the type theory allows for dependent types, then it is possible to define a dependent type x : b o o l ⊢ ⊢ T F x : U → → U → → U {\displaystyle x:{\mathsf {bool}}\,\vdash \,\mathrm {TF} \,x:U\to U\to U} such that T F t r u e σ σ τ τ {\displaystyle \mathrm {TF} \,\mathrm {true} \,\sigma \,\tau } returns σ σ {\displaystyle \sigma } , and T F f a l s e σ σ τ τ {\displaystyle \mathrm {TF} \,\mathrm {false} \,\sigma \,\tau } returns τ τ {\displaystyle \tau } .

The type of i f {\displaystyle \mathrm {if} } may then be written as ∀ ∀ σ σ τ τ .

Π Π x : b o o l .

σ σ → → τ τ → → T F x σ σ τ τ {\displaystyle \forall \,\sigma \,\tau .\Pi _{x:{\mathsf {bool}}}.\sigma \to \tau \to \mathrm {TF} \,x\,\sigma \,\tau } .

Identity type [ edit ] Following the notion of Curry-Howard Correspondence, the identity type is a type introduced to mirror propositional equivalence , as opposed to the judgmental (syntactic) equivalence that type theory already provides.

An identity type requires two terms of the same type and is written with the symbol = {\displaystyle =} . For example, if x + 1 {\displaystyle x+1} and 1 + x {\displaystyle 1+x} are terms, then x + 1 = 1 + x {\displaystyle x+1=1+x} is a possible type. Canonical terms are created with a reflexivity function, r e f l {\displaystyle \mathrm {refl} } . For a term t {\displaystyle t} , the call r e f l t {\displaystyle \mathrm {refl} \,t} returns the canonical term inhabiting the type t = t {\displaystyle t=t} .

The complexities of equality in type theory make it an active research topic; homotopy type theory is a notable area of research that mainly deals with equality in type theory.

Inductive types [ edit ] Inductive types are a general template for creating a large variety of types. In fact, all the types described above and more can be defined using the rules of inductive types. Two methods of generating inductive types are induction-recursion and induction-induction . A method that only uses lambda terms is Scott encoding .

Some proof assistants , such as Rocq (previously known as Coq ) and Lean , are based on the calculus for inductive constructions, which is a calculus of constructions with inductive types.

Differences from set theory [ edit ] The most commonly accepted foundation for mathematics is first-order logic with the language and axioms of Zermelo–Fraenkel set theory with the axiom of choice , abbreviated ZFC. Type theories having sufficient expressibility may also act as a foundation of mathematics. There are a number of differences between these two approaches.

Set theory has both rules and axioms , while type theories only have rules. Type theories, in general, do not have axioms and are defined by their rules of inference.

[ 15 ] Classical set theory and logic have the law of excluded middle . When a type theory encodes the concepts of "and" and "or" as types, it leads to intuitionistic logic , and does not necessarily have the law of excluded middle.

[ 18 ] In set theory, an element is not restricted to one set. The element can appear in subsets and unions with other sets. In type theory, terms (generally) belong to only one type. Where a subset would be used, type theory can use a predicate function or use a dependently-typed product type, where each element x {\displaystyle x} is paired with a proof that the subset's property holds for x {\displaystyle x} . Where a union would be used, type theory uses the sum type, which contains new canonical terms.

Type theory has a built-in notion of computation. Thus, "1+1" and "2" are different terms in type theory, but they compute to the same value. Moreover, functions are defined computationally as lambda terms. In set theory, "1+1=2" means that "1+1" is just another way to refer the value "2". Type theory's computation does require a complicated concept of equality.

Set theory encodes numbers as sets . Type theory can encode numbers as functions using Church encoding , or more naturally as inductive types , and the construction closely resembles Peano's axioms .

In type theory, proofs are types whereas in set theory, proofs are part of the underlying first-order logic.

[ 15 ] Proponents of type theory will also point out its connection to constructive mathematics through the BHK interpretation , its connection to logic by the Curry–Howard isomorphism , and its connections to Category theory .

Properties of type theories [ edit ] Terms usually belong to a single type. However, there are set theories that define "subtyping".

Computation takes place by repeated application of rules. Many types of theories are strongly normalizing , which means that any order of applying the rules will always end in the same result. However, some are not. In a normalizing type theory, the one-directional computation rules are called "reduction rules", and applying the rules "reduces" the term. If a rule is not one-directional, it is called a "conversion rule".

Some combinations of types are equivalent to other combinations of types. When functions are considered "exponentiation", the combinations of types can be written similarly to algebraic identities.

[ 28 ] Thus, 0 + A ≅ ≅ A {\displaystyle {\mathbb {0} }+A\cong A} , 1 × × A ≅ ≅ A {\displaystyle {\mathbb {1} }\times A\cong A} , 1 + 1 ≅ ≅ 2 {\displaystyle {\mathbb {1} }+{\mathbb {1} }\cong {\mathbb {2} }} , A B + C ≅ ≅ A B × × A C {\displaystyle A^{B+C}\cong A^{B}\times A^{C}} , A B × × C ≅ ≅ ( A B ) C {\displaystyle A^{B\times C}\cong (A^{B})^{C}} .

Axioms [ edit ] Most type theories do not have axioms . This is because a type theory is defined by its rules of inference. This is a source of confusion for people familiar with Set Theory, where a theory is defined by both the rules of inference for a logic (such as first-order logic ) and axioms about sets.

Sometimes, a type theory will add a few axioms. An axiom is a judgment that is accepted without a derivation using the rules of inference. They are often added to ensure properties that cannot be added cleanly through the rules.

Axioms can cause problems if they introduce terms without a way to compute on those terms. That is, axioms can interfere with the normalizing property of the type theory.

[ 29 ] Some commonly encountered axioms are: "Axiom K" ensures "uniqueness of identity proofs". That is, that every term of an identity type is equal to reflexivity.

[ 30 ] "Univalence Axiom" holds that equivalence of types is equality of types. The research into this property led to cubical type theory , where the property holds without needing an axiom.

[ 24 ] "Law of Excluded Middle" is often added to satisfy users who want classical logic , instead of intuitionistic logic.

The Axiom of Choice does not need to be added to type theory, because in most type theories it can be derived from the rules of inference. This is because of the constructive nature of type theory, where proving that a value exists requires a method to compute the value. The Axiom of Choice is less powerful in type theory than most set theories, because type theory's functions must be computable and, being syntax-driven, the number of terms in a type must be countable. (See Axiom of choice § In constructive mathematics .) List of type theories [ edit ] Major [ edit ] Simply typed lambda calculus which is a higher-order logic Intuitionistic type theory System F LF is often used to define other type theories Calculus of constructions and its derivatives Minor [ edit ] Automath ST type theory UTT (Luo's Unified Theory of dependent Types) some forms of combinatory logic others defined in the lambda cube (also known as pure type systems ) others under the name typed lambda calculus Active research [ edit ] Homotopy type theory explores equality of types Cubical Type Theory is an implementation of homotopy type theory See also [ edit ] Class (set theory) Type–token distinction Further reading [ edit ] Aarts, C.; Backhouse, R.; Hoogendijk, P.; Voermans, E.; van der Woude, J. (December 1992).

"A Relational Theory of Datatypes" . Technische Universiteit Eindhoven.

Andrews B., Peter (2002).

An Introduction to Mathematical Logic and Type Theory: To Truth Through Proof (2nd ed.). Kluwer.

ISBN 978-1-4020-0763-7 .

Jacobs, Bart (1999).

Categorical Logic and Type Theory . Studies in Logic and the Foundations of Mathematics. Vol. 141. Elsevier.

ISBN 978-0-444-50170-7 .

Archived from the original on 2023-08-10 . Retrieved 2020-07-19 .

Covers type theory in depth, including polymorphic and dependent type extensions. Gives categorical semantics .

Cardelli, Luca (1996).

"Type Systems" . In Tucker, Allen B. (ed.).

The Computer Science and Engineering Handbook . CRC Press. pp.

2208– 36.

ISBN 9780849329098 .

Archived from the original on 2008-04-10 . Retrieved 2004-06-26 .

Collins, Jordan E. (2012).

A History of the Theory of Types: Developments After the Second Edition of 'Principia Mathematica' . Lambert Academic Publishing.

hdl : 11375/12315 .

ISBN 978-3-8473-2963-3 .

Provides a historical survey of the developments of the theory of types with a focus on the decline of the theory as a foundation of mathematics over the four decades following the publication of the second edition of 'Principia Mathematica'.

Constable, Robert L.

(2012) [2002].

"Naïve Computational Type Theory" (PDF) . In Schwichtenberg, H.; Steinbruggen, R. (eds.).

Proof and System-Reliability . Nato Science Series II. Vol. 62. Springer. pp.

213– 259.

ISBN 9789401004138 .

Archived (PDF) from the original on 2022-10-09.

Intended as a type theory counterpart of Paul Halmos 's (1960) Naïve Set Theory Coquand, Thierry (2018) [2006].

"Type Theory" .

Stanford Encyclopedia of Philosophy .

Thompson, Simon (1991).

Type Theory and Functional Programming . Addison–Wesley.

ISBN 0-201-41667-0 .

Archived from the original on 2021-03-23 . Retrieved 2006-04-03 .

Hindley, J. Roger (2008) [1995].

Basic Simple Type Theory . Cambridge University Press.

ISBN 978-0-521-05422-5 .

A good introduction to simple type theory for computer scientists; the system described is not exactly Church's STT though.

Book review Archived 2011-06-07 at the Wayback Machine Kamareddine, Fairouz D.; Laan, Twan; Nederpelt, Rob P. (2004).

A modern perspective on type theory: from its origins until today . Springer.

ISBN 1-4020-2334-0 .

Ferreirós, José; Domínguez, José Ferreirós (2007). "X. Logic and Type Theory in the Interwar Period".

Labyrinth of thought: a history of set theory and its role in modern mathematics (2nd ed.). Springer.

ISBN 978-3-7643-8349-7 .

Laan, T.D.L. (1997).

The evolution of type theory in logic and mathematics (PDF) (PhD). Eindhoven University of Technology.

doi : 10.6100/IR498552 .

ISBN 90-386-0531-5 .

Archived (PDF) from the original on 2022-10-09.

Montague, R. (1973) "The proper treatment of quantification in ordinary English". In K. J. J. Hintikka, J. M. E. Moravcsik, and P. Suppes (eds.), Approaches to Natural Language (Synthese Library, 49), Dordrecht: Reidel, 221–242; reprinted in Portner and Partee (eds.) 2002, pp. 17–35. See: Montague Semantics , Stanford Encyclopedia of Philosophy.

Notes [ edit ] ^ See § Terms and types ^ The Kleene–Rosser paradox "The Inconsistency of Certain Formal Logics" on page 636 Annals of Mathematics 36 number 3  (July 1935), showed that 1 = 2 {\displaystyle 1=2} .

[ 1 ] ^ In Julia 's type system, for example, abstract types have no instances, but can have subtype, [ 2 ] : 110 whereas concrete types do not have subtypes but can have instances, for " documentation, optimization, and dispatch ".

[ 3 ] ^ Church demonstrated his logistic method with his simple theory of types, [ 5 ] and explained his method in 1956, [ 6 ] pages 47-68.

^ In Julia , for example, a function with no name, but with two parameters in some tuple (x,y) can be denoted by say, (x,y) -> x^5+y , as an anonymous function.

[ 25 ] References [ edit ] ^ Kleene, S. C. & Rosser, J. B. (1935). "The inconsistency of certain formal logics".

Annals of Mathematics .

36 (3): 630– 636.

doi : 10.2307/1968646 .

JSTOR 1968646 .

^ Balbaert, Ivo (2015) Getting Started With Julia Programming ISBN 978-1-78328-479-5 ^ docs.julialang.org v.1 Types Archived 2022-03-24 at the Wayback Machine ^ Stanford Encyclopedia of Philosophy (rev. Mon Oct 12, 2020) Russell’s Paradox Archived December 18, 2021, at the Wayback Machine 3. Early Responses to the Paradox ^ a b c d Church, Alonzo (1940). "A formulation of the simple theory of types".

The Journal of Symbolic Logic .

5 (2): 56– 68.

doi : 10.2307/2266170 .

JSTOR 2266170 .

S2CID 15889861 .

^ Alonzo Church (1956) Introduction To Mathematical Logic Vol 1 ^ ETCS at the n Lab ^ Chatzikyriakidis, Stergios; Luo, Zhaohui (2017-02-07).

Modern Perspectives in Type-Theoretical Semantics . Springer.

ISBN 978-3-319-50422-3 .

Archived from the original on 2023-08-10 . Retrieved 2022-07-29 .

^ Winter, Yoad (2016-04-08).

Elements of Formal Semantics: An Introduction to the Mathematical Theory of Meaning in Natural Language . Edinburgh University Press.

ISBN 978-0-7486-7777-1 .

Archived from the original on 2023-08-10 . Retrieved 2022-07-29 .

^ Cooper, Robin. " Type theory and semantics in flux Archived 2022-05-10 at the Wayback Machine ." Handbook of the Philosophy of Science 14 (2012): 271-323.

^ Barwise, Jon; Cooper, Robin (1981) Generalized quantifiers and natural language Linguistics and Philosophy 4 (2):159--219 (1981) ^ Cooper, Robin (2005). "Records and Record Types in Semantic Theory".

Journal of Logic and Computation .

15 (2): 99– 112.

doi : 10.1093/logcom/exi004 .

^ Cooper, Robin (2010).

Type theory and semantics in flux .

Handbook of the Philosophy of Science. Volume 14: Philosophy of Linguistics . Elsevier.

^ a b Martin-Löf, Per (1987-12-01).

"Truth of a proposition, evidence of a judgement, validity of a proof" .

Synthese .

73 (3): 407– 420.

doi : 10.1007/BF00484985 .

ISSN 1573-0964 .

^ a b c d The Univalent Foundations Program (2013).

Homotopy Type Theory: Univalent Foundations of Mathematics . Homotopy Type Theory.

^ Smith, Peter.

"Types of proof system" (PDF) .

logicmatters.net .

Archived (PDF) from the original on 2022-10-09 . Retrieved 29 December 2021 .

^ a b c d e f g h Henk Barendregt; Wil Dekkers; Richard Statman (20 June 2013).

Lambda Calculus with Types . Cambridge University Press. pp.

1– 66.

ISBN 978-0-521-76614-2 .

^ a b c "Rules to Martin-Löf's Intuitionistic Type Theory" (PDF) .

Archived (PDF) from the original on 2021-10-21 . Retrieved 2022-01-22 .

^ "proof by contradiction" .

nlab .

Archived from the original on 13 August 2023 . Retrieved 29 December 2021 .

^ Heineman, George T.; Bessai, Jan; Düdder, Boris; Rehof, Jakob (2016). "A long and winding road towards modular synthesis".

Leveraging Applications of Formal Methods, Verification and Validation: Foundational Techniques . ISoLA 2016. Lecture Notes in Computer Science. Vol. 9952. Springer. pp.

303– 317.

doi : 10.1007/978-3-319-47166-2_21 .

ISBN 978-3-319-47165-5 .

^ Barendregt, Henk (1991). "Introduction to generalized type systems".

Journal of Functional Programming .

1 (2): 125– 154.

doi : 10.1017/s0956796800020025 .

hdl : 2066/17240 .

ISSN 0956-7968 .

S2CID 44757552 .

^ Bell, John L. (2012).

"Types, Sets and Categories" (PDF) . In Kanamory, Akihiro (ed.).

Sets and Extensions in the Twentieth Century . Handbook of the History of Logic. Vol. 6. Elsevier.

ISBN 978-0-08-093066-4 .

Archived (PDF) from the original on 2018-04-17 . Retrieved 2012-11-03 .

^ Sterling, Jonathan; Angiuli, Carlo (2021-06-29). "Normalization for Cubical Type Theory".

2021 36th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS) . Rome, Italy: IEEE. pp.

1– 15.

arXiv : 2101.11479 .

doi : 10.1109/LICS52264.2021.9470719 .

ISBN 978-1-6654-4895-6 .

S2CID 231719089 .

^ a b Cohen, Cyril; Coquand, Thierry; Huber, Simon; Mörtberg, Anders (2016).

"Cubical Type Theory: A constructive interpretation of the univalence axiom" (PDF) .

21st International Conference on Types for Proofs and Programs (TYPES 2015) .

arXiv : 1611.02108 .

doi : 10.4230/LIPIcs.CVIT.2016.23 (inactive 2 July 2025).

Archived (PDF) from the original on 2022-10-09.

{{ cite journal }} :  CS1 maint: DOI inactive as of July 2025 ( link ) ^ Balbaert,Ivo (2015) Getting Started with Julia ^ a b Bove, Ana; Dybjer, Peter (2009), Bove, Ana; Barbosa, Luís Soares; Pardo, Alberto; Pinto, Jorge Sousa (eds.), "Dependent Types at Work" , Language Engineering and Rigorous Software Development: International LerNet ALFA Summer School 2008, Piriapolis, Uruguay, February 24 - March 1, 2008, Revised Tutorial Lectures , Lecture Notes in Computer Science, Berlin, Heidelberg: Springer, pp.

57– 99, doi : 10.1007/978-3-642-03153-3_2 , ISBN 978-3-642-03153-3 , retrieved 2024-01-18 ^ Barendegt, Henk (April 1991).

"Introduction to generalized type systems" .

Journal of Functional Programming .

1 (2): 125– 154.

doi : 10.1017/S0956796800020025 .

hdl : 2066/17240 – via Cambridge Core.

^ Milewski, Bartosz.

"Programming with Math (Exploring Type Theory)" .

YouTube .

Archived from the original on 2022-01-22 . Retrieved 2022-01-22 .

^ "Axioms and Computation" .

Theorem Proving in Lean .

Archived from the original on 22 December 2021 . Retrieved 21 January 2022 .

^ "Axiom K" .

nLab .

Archived from the original on 2022-01-19 . Retrieved 2022-01-21 .

External links [ edit ] Introductory material [ edit ] Type Theory at nLab , which has articles on many topics.

Intuitionistic Type Theory article at the Stanford Encyclopedia of Philosophy Lambda Calculi with Types book by Henk Barendregt Calculus of Constructions / Typed Lambda Calculus textbook style paper by Helmut Brandl Intuitionistic Type Theory notes by Per Martin-Löf Programming in Martin-Löf's Type Theory book Homotopy Type Theory book, which proposed homotopy type theory as a mathematical foundation.

Advanced material [ edit ] Robert L. Constable (ed.).

"Computational type theory" .

Scholarpedia .

The TYPES Forum — moderated e-mail forum focusing on type theory in computer science, operating since 1987.

"Introduction to Type Theory" .

Implementing Mathematics with The Nuprl Proof Development System . Prentice-Hall. 1985.

Types Project lecture notes of summer schools 2005–2008 The 2005 summer school has introductory lectures Oregon Programming Languages Summer School , many lectures and some notes.

Summer 2013 lectures including Robert Harper's talks on YouTube Summer 2015 Types, Logic, Semantics, and Verification Andrej Bauer's blog v t e Computer science Note: This template roughly follows the 2012 ACM Computing Classification System .

Hardware Printed circuit board Peripheral Integrated circuit Very-large-scale integration System on a chip (SoC) Energy consumption (green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Cyber-physical system Fault tolerance Wireless sensor network Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control variable Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human–centered computing Interaction design Augmented reality Virtual reality Social computing Ubiquitous computing Visualization Accessibility Human–computer interaction Mobile computing Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Image compression Solid modeling Applied computing Quantum computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Category Outline Glossaries v t e Mathematical logic General Axiom list Cardinality First-order logic Formal proof Formal semantics Foundations of mathematics Information theory Lemma Logical consequence Model Theorem Theory Type theory Theorems ( list ) and paradoxes Gödel's completeness and incompleteness theorems Tarski's undefinability Banach–Tarski paradox Cantor's theorem, paradox and diagonal argument Compactness Halting problem Lindström's Löwenheim–Skolem Russell's paradox Logics Traditional Classical logic Logical truth Tautology Proposition Inference Logical equivalence Consistency Equiconsistency Argument Soundness Validity Syllogism Square of opposition Venn diagram Propositional Boolean algebra Boolean functions Logical connectives Propositional calculus Propositional formula Truth tables Many-valued logic 3 finite ∞ Predicate First-order list Second-order Monadic Higher-order Fixed-point Free Quantifiers Predicate Monadic predicate calculus Set theory Set hereditary Class ( Ur- ) Element Ordinal number Extensionality Forcing Relation equivalence partition Set operations: intersection union complement Cartesian product power set identities Types of sets Countable Uncountable Empty Inhabited Singleton Finite Infinite Transitive Ultrafilter Recursive Fuzzy Universal Universe constructible Grothendieck Von Neumann Maps and cardinality Function / Map domain codomain image In / Sur / Bi -jection Schröder–Bernstein theorem Isomorphism Gödel numbering Enumeration Large cardinal inaccessible Aleph number Operation binary Set theories Zermelo–Fraenkel axiom of choice continuum hypothesis General Kripke–Platek Morse–Kelley Naive New Foundations Tarski–Grothendieck Von Neumann–Bernays–Gödel Ackermann Constructive Formal systems ( list ), language and syntax Alphabet Arity Automata Axiom schema Expression ground Extension by definition conservative Relation Formation rule Grammar Formula atomic closed ground open Free/bound variable Language Metalanguage Logical connective ¬ ∨ ∧ → ↔ = Predicate functional variable propositional variable Proof Quantifier ∃ !

∀ rank Sentence atomic spectrum Signature String Substitution Symbol function logical/constant non-logical variable Term Theory list Example axiomatic systems ( list ) of arithmetic : Peano second-order elementary function primitive recursive Robinson Skolem of the real numbers Tarski's axiomatization of Boolean algebras canonical minimal axioms of geometry : Euclidean : Elements Hilbert's Tarski's non-Euclidean Principia Mathematica Proof theory Formal proof Natural deduction Logical consequence Rule of inference Sequent calculus Theorem Systems axiomatic deductive Hilbert list Complete theory Independence ( from ZFC ) Proof of impossibility Ordinal analysis Reverse mathematics Self-verifying theories Model theory Interpretation function of models Model equivalence finite saturated spectrum submodel Non-standard model of arithmetic Diagram elementary Categorical theory Model complete theory Satisfiability Semantics of logic Strength Theories of truth semantic Tarski's Kripke's T-schema Transfer principle Truth predicate Truth value Type Ultraproduct Validity Computability theory Church encoding Church–Turing thesis Computably enumerable Computable function Computable set Decision problem decidable undecidable P NP P versus NP problem Kolmogorov complexity Lambda calculus Primitive recursive function Recursion Recursive set Turing machine Type theory Related Abstract logic Algebraic logic Automated theorem proving Category theory Concrete / Abstract category Category of sets History of logic History of mathematical logic timeline Logicism Mathematical object Philosophy of mathematics Supertask Mathematics portal v t e Formal semantics (natural language) Central concepts Compositionality Denotation Entailment Extension Generalized quantifier Intension Logical form Presupposition Proposition Reference Scope Speech act Syntax–semantics interface Truth conditions Topics Areas Anaphora Ambiguity Binding Conditionals Definiteness Disjunction Evidentiality Focus Indexicality Lexical semantics Modality Negation Propositional attitudes Tense–aspect–mood Quantification Vagueness Phenomena Antecedent-contained deletion Cataphora Coercion Conservativity Counterfactuals Crossover effects Cumulativity De dicto and de re De se Deontic modality Discourse relations Donkey anaphora Epistemic modality Exhaustivity Faultless disagreement Free choice inferences Givenness Homogeneity (linguistics) Hurford disjunction Inalienable possession Intersective modification Logophoricity Mirativity Modal subordination Opaque contexts Performatives Polarity items Privative adjectives Quantificational variability effect Responsive predicate Rising declaratives Scalar implicature Sloppy identity Subsective modification Subtrigging Telicity Temperature paradox Veridicality Formalism Formal systems Alternative semantics Categorial grammar Combinatory categorial grammar Discourse representation theory (DRT) Dynamic semantics Generative grammar Glue semantics Inquisitive semantics Intensional logic Lambda calculus Mereology Montague grammar Segmented discourse representation theory (SDRT) Situation semantics Supervaluationism Type theory TTR Concepts Autonomy of syntax Context set Continuation Conversational scoreboard Downward entailing Existential closure Function application Meaning postulate Monads Plural quantification Possible world Quantifier raising Quantization Question under discussion Semantic parsing Squiggle operator Strawson entailment Strict conditional Type shifter Universal grinder See also Cognitive semantics Computational semantics Distributional semantics Formal grammar Inferentialism Logic translation Linguistics wars Philosophy of language Pragmatics Semantics of logic Authority control databases : National Germany United States NewPP limit report
Parsed by mw‐api‐ext.codfw.main‐5cf8f5fb49‐gz8ms
Cached time: 20250811235243
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 1.062 seconds
Real time usage: 1.406 seconds
Preprocessor visited node count: 5863/1000000
Revision size: 62526/2097152 bytes
Post‐expand include size: 202653/2097152 bytes
Template argument size: 4109/2097152 bytes
Highest expansion depth: 20/100
Expensive parser function count: 9/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 165492/5000000 bytes
Lua time usage: 0.472/10.000 seconds
Lua memory usage: 7839403/52428800 bytes
Number of Wikibase entities loaded: 1/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  789.558      1 -total
 20.98%  165.633      2 Template:Reflist
 17.62%  139.118      8 Template:Navbox
 16.39%  129.385      8 Template:Cite_web
 13.10%  103.459     16 Template:Cite_book
 11.81%   93.221      1 Template:Short_description
 11.28%   89.032      1 Template:Computer_science
  8.50%   67.140      2 Template:Pagetype
  5.73%   45.230      1 Template:Authority_control
  5.60%   44.188      2 Template:Cn Saved in parser cache with key enwiki:pcache:40282:|#|:idhash:canonical and timestamp 20250811235243 and revision id 1302265807. Rendering was triggered because: unknown Retrieved from " https://en.wikipedia.org/w/index.php?title=Type_theory&oldid=1302265807 " Categories : Type theory Systems of formal logic Hierarchy Hidden categories: Webarchive template wayback links CS1 maint: DOI inactive as of July 2025 Articles with short description Short description is different from Wikidata All articles with unsourced statements Articles with unsourced statements from January 2024 This page was last edited on 24 July 2025, at 10:16 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Type theory 24 languages Add topic

