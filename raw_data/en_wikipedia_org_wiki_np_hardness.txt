Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Definition 2 Consequences 3 Examples 4 NP-naming convention 5 Application areas 6 NP-hard problems 7 See also 8 References Toggle the table of contents NP-hardness 24 languages العربية 閩南語 / Bân-lâm-gí Català Deutsch Español Esperanto فارسی Français 한국어 Italiano עברית Nederlands 日本語 Norsk bokmål Norsk nynorsk Polski Português Română Русский Simple English Српски / srpski Українська Tiếng Việt 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Complexity class For a gentler introduction, see P versus NP problem .

Euler diagram for P , NP , NP-complete, and NP-hard set of problems. The left side is valid under the assumption that P≠NP , while the right side is valid under the assumption that P=NP (except that the empty language and its complement are never NP-complete) In computational complexity theory , a computational problem H is called NP-hard if, for  every problem L which can be solved in non-deterministic polynomial-time , there is a polynomial-time reduction from L to H . That is, assuming a solution for H takes 1 unit time, H ' s solution can be used to solve L in polynomial time.

[ 1 ] [ 2 ] As a consequence, finding a polynomial time algorithm to solve a single NP-hard problem would give polynomial time algorithms for all the problems in the complexity class NP . As it is suspected, but unproven, that P≠NP , it is unlikely that any polynomial-time algorithms for NP-hard problems exist.

[ 3 ] [ 4 ] A simple example of an NP-hard problem is the subset sum problem .

Informally, if H is NP-hard, then it is at least as difficult to solve as the problems in NP . However, the opposite direction is not true: some problems are undecidable , and therefore even more difficult to solve than all problems in NP, but they are probably not NP-hard (unless P=NP).

[ 5 ] Definition [ edit ] A decision problem H is NP-hard when for every problem L in NP, there is a polynomial-time many-one reduction from L to H .

[ 1 ] : 80 Another definition is to require that there be a polynomial-time reduction from an NP-complete problem G to H .

[ 1 ] : 91 As any problem L in NP reduces in polynomial time to G , L reduces in turn to H in polynomial time so this new definition implies the previous one. It does not restrict the class NP-hard to decision problems, and it also includes search problems or optimization problems .

Consequences [ edit ] If P ≠ NP, then NP-hard problems could not be solved in polynomial time.

Some NP-hard optimization problems can be polynomial-time approximated up to some constant approximation ratio (in particular, those in APX ) or even up to any approximation ratio (those in PTAS or FPTAS ). There are many classes of approximability, each one enabling approximation up to a different level.

[ 6 ] Examples [ edit ] All NP-complete problems are also NP-hard (see List of NP-complete problems ). For example, the optimization problem of finding the least-cost cyclic route through all nodes of a weighted graph—commonly known as the travelling salesman problem —is NP-hard.

[ 7 ] The subset sum problem is another example: given a set of integers, does any non-empty subset of them add up to zero? That is a decision problem and happens to be NP-complete.

There are decision problems that are NP-hard but not NP-complete such as the halting problem . That is the problem which asks "given a program and its input, will it run forever?" That is a yes / no question and so is a decision problem. It is easy to prove that the halting problem is NP-hard but not NP-complete. For example, the Boolean satisfiability problem can be reduced to the halting problem by transforming it to the description of a Turing machine that tries all truth value assignments and when it finds one that satisfies the formula it halts and otherwise it goes into an infinite loop. It is also easy to see that the halting problem is not in NP since all problems in NP are decidable in a finite number of operations, but the halting problem, in general, is undecidable . There are also NP-hard problems that are neither NP-complete nor Undecidable . For instance, the language of true quantified Boolean formulas is decidable in polynomial space , but not in non-deterministic polynomial time (unless NP = PSPACE ).

[ 8 ] NP-naming convention [ edit ] NP-hard problems do not have to be elements of the complexity class NP.
As NP plays a central role in computational complexity , it is used as the basis of several classes: NP Class of computational decision problems for which any given yes -solution can be verified as a solution in polynomial time by a deterministic Turing machine (or solvable by a non-deterministic Turing machine in polynomial time).

NP-hard Class of problems which are at least as hard as the hardest problems in NP. Problems that are NP-hard do not have to be elements of NP; indeed, they may not even be decidable.

NP-complete Class of decision problems which contains the hardest problems in NP. Each NP-complete problem has to be in NP.

NP-easy At most as hard as NP, but not necessarily in NP.

NP-equivalent Decision problems that are both NP-hard and NP-easy, but not necessarily in NP.

NP-intermediate If P and NP are different, then there exist decision problems in the region of NP that fall between P and the NP-complete problems. (If P and NP are the same class, then NP-intermediate problems do not exist because in this case every NP-complete problem would fall in P, and by definition, every problem in NP can be reduced to an NP-complete problem.) Application areas [ edit ] NP-hard problems are often tackled with rules-based languages in areas including: Approximate computing Configuration Cryptography Data mining Decision support Phylogenetics Planning Process monitoring and control Rosters or schedules Routing/vehicle routing Scheduling NP-hard problems [ edit ] Problems that are decidable but not NP-complete , often are optimization problems: Knapsack optimization problems Integer programming Travelling salesman optimization problem Minimum vertex cover Maximum clique Longest simple path Graph coloring ; an application: register allocation in compilers See also [ edit ] Lists of problems List of unsolved problems Reduction (complexity) Unknowability References [ edit ] ^ a b c Leeuwen, Jan van , ed. (1998).

Handbook of Theoretical Computer Science . Vol. A, Algorithms and complexity. Amsterdam: Elsevier.

ISBN 0262720140 .

OCLC 247934368 .

^ Knuth, Donald (1974). "Postscript about NP-hard problems".

ACM SIGACT News .

6 (2): 15– 16.

doi : 10.1145/1008304.1008305 .

S2CID 46480926 .

^ Daniel Pierre Bovet; Pierluigi Crescenzi (1994).

Introduction to the Theory of Complexity . Prentice Hall. p. 69.

ISBN 0-13-915380-2 .

^ "Shtetl-Optimized » Blog Archive » The Scientific Case for P≠NP" .

www.scottaaronson.com . Retrieved 2016-09-25 .

^ "Is undecidable(complement of R) a subset of NP-hard?" .

Computer Science Stack Exchange . Retrieved 2024-02-09 .

^ Escoffier, B.; Paschos, B.Th. (2010). "A survey on the structure of approximation classes".

Computer Science Review .

4 (1): 19– 40.

^ Lawler, E. L.

; Lenstra, J. K.

; Rinnooy Kan, A. H. G.; Shmoys, D. B. (1985), The Traveling Salesman Problem: A Guided Tour of Combinatorial Optimization , John Wiley & Sons, ISBN 0-471-90413-9 .

^ More precisely, this language is PSPACE-complete ; see, for example, Wegener, Ingo (2005), Complexity Theory: Exploring the Limits of Efficient Algorithms , Springer, p. 189, ISBN 9783540210450 .

Garey, Michael R.

; Johnson, David S.

(1979).

Computers and Intractability: A Guide to the Theory of NP-Completeness . Series of Books in the Mathematical Sciences (1st ed.). New York: W. H. Freeman and Company .

ISBN 9780716710455 .

MR 0519066 .

OCLC 247570676 .

v t e Complexity classes Considered feasible DLOGTIME AC 0 ACC 0 TC TC 0 L SL RL FL NL NL-complete NC SC CC P P-complete ZPP RP BPP BQP APX FP Suspected infeasible UP NP NP-complete NP-hard co-NP co-NP-complete TFNP FNP AM QMA PH ⊕P PP #P #P-complete IP PSPACE PSPACE-complete Considered infeasible EXPTIME NEXPTIME EXPSPACE 2-EXPTIME ELEMENTARY PR R RE ALL Class hierarchies Polynomial hierarchy Exponential hierarchy Grzegorczyk hierarchy Arithmetical hierarchy Boolean hierarchy Families of classes DTIME NTIME DSPACE NSPACE Probabilistically checkable proof Interactive proof system List of complexity classes Retrieved from " https://en.wikipedia.org/w/index.php?title=NP-hardness&oldid=1287715747 " Categories : NP-hard problems Complexity classes Hidden categories: CS1: long volume value Articles with short description Short description matches Wikidata This page was last edited on 28 April 2025, at 00:35 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents NP-hardness 24 languages Add topic

