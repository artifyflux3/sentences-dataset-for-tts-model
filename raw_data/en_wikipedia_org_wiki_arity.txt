Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Examples Toggle Examples subsection 1.1 Nullary 1.2 Unary 1.3 Binary 1.4 Ternary 1.5 n -ary 1.6 Varying arity 2 Terminology 3 See also 4 References 5 External links Toggle the table of contents Arity 33 languages Català Чӑвашла Čeština Deutsch Eesti Español Esperanto فارسی Français Galego 한국어 Ido Bahasa Indonesia Italiano עברית Magyar Македонски Nederlands 日本語 Norsk bokmål Polski Português Română Русский Simple English Slovenčina کوردی Српски / srpski Srpskohrvatski / српскохрватски Svenska Tagalog Українська 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Number of arguments required by a function "Adicity" redirects here. Not to be confused with Acidity .

In logic , mathematics , and computer science , arity ( / ˈ ær ɪ t i / ⓘ ) is the number of arguments or operands taken by a function , operation or relation . In mathematics, arity may also be called rank, [ 1 ] [ 2 ] but this word can have many other meanings. In logic and philosophy , arity may also be called adicity and degree .

[ 3 ] [ 4 ] In linguistics , it is usually named valency .

[ 5 ] Examples [ edit ] In general, functions or operators with a given arity follow the naming conventions of n -based numeral systems , such as binary and hexadecimal . A Latin prefix is combined with the -ary suffix. For example: A nullary function takes no arguments.

Example: f ( ) = 2 {\displaystyle f()=2} A unary function takes one argument.

Example: f ( x ) = 2 x {\displaystyle f(x)=2x} A binary function takes two arguments.

Example: f ( x , y ) = 2 x y {\displaystyle f(x,y)=2xy} A ternary function takes three arguments.

Example: f ( x , y , z ) = 2 x y z {\displaystyle f(x,y,z)=2xyz} An n -ary function takes n arguments.

Example: f ( x 1 , x 2 , … … , x n ) = 2 ∏ ∏ i = 1 n x i {\textstyle f(x_{1},x_{2},\ldots ,x_{n})=2\prod _{i=1}^{n}x_{i}} Nullary [ edit ] A constant can be treated as the output of an operation of arity 0, called a nullary operation .

Also, outside of functional programming , a function without arguments can be meaningful and not necessarily constant (due to side effects ). Such functions may have some hidden input , such as global variables or the whole state of the system (time, free memory, etc.).

Unary [ edit ] Examples of unary operators in mathematics and in programming include the unary minus and plus, the increment and decrement operators in C -style languages (not in logical languages), and the successor , factorial , reciprocal , floor , ceiling , fractional part , sign , absolute value , square root (the principal square root), complex conjugate (unary of "one" complex number , that however has two parts at a lower level of abstraction), and norm functions in mathematics.  In programming the two's complement , address reference , and the logical NOT operators are examples of unary operators.

All functions in lambda calculus and in some functional programming languages (especially those descended from ML ) are technically unary, but see n-ary below.

According to Quine , the Latin distributives being singuli , bini , terni , and so forth, the term "singulary" is the correct adjective, rather than "unary".

[ 6 ] Abraham Robinson follows Quine's usage.

[ 7 ] In philosophy, the adjective monadic is sometimes used to describe a one-place relation such as 'is square-shaped' as opposed to a two-place relation such as 'is the sister of'.

Binary [ edit ] Most operators encountered in programming and mathematics are of the binary form. For both programming and mathematics, these include the multiplication operator , the radix operator, the often omitted exponentiation operator, the logarithm operator, the addition operator, and the division operator. Logical predicates such as OR , XOR , AND , IMP are typically used as binary operators with two distinct operands. In CISC architectures, it is common to have two source operands (and store result in one of them).

Ternary [ edit ] The computer programming language C and its various descendants (including C++ , C# , Java , Julia , Perl , and others) provide the ternary conditional operator ?: . The first operand (the condition) is evaluated, and if it is true, the result of the entire expression is the value of the second operand, otherwise it is the value of the third operand. This operator has a lazy or 'shortcut' evaluation strategy that does not evaluate whichever of the second and third arguments is not used. Some functional programming languages, such as Agda , have such an evaluation strategy for all functions and consequently implement if...then...else as an ordinary function; several others, such as Haskell , can do this but for syntactic, performance or historical reasons choose to define keywords instead.

The Python language has a ternary conditional expression, x if C else y . In Elixir the equivalent would be if ( C , do : x , else : y ) .

The Forth language also contains a ternary operator, */ , which multiplies the first two (one-cell) numbers, dividing by the third, with the intermediate result being a double cell number. This is used when the intermediate result would overflow a single cell.

The Unix dc calculator has several ternary operators, such as | , which will pop three values from the stack and efficiently compute x y mod z {\textstyle x^{y}{\bmod {z}}} with arbitrary precision .

Many ( RISC ) assembly language instructions are ternary (as opposed to only two operands specified in CISC); or higher, such as MOV %AX , ( %BX , %CX ) , which will load ( MOV ) into register AX the contents of a calculated memory location that is the sum (parenthesis) of the registers BX and CX .

n -ary [ edit ] The arithmetic mean of n real numbers is an n -ary  function: x ¯ ¯ = 1 n ( ∑ ∑ i = 1 n x i ) = x 1 + x 2 + ⋯ ⋯ + x n n {\displaystyle {\bar {x}}={\frac {1}{n}}\left(\sum _{i=1}^{n}{x_{i}}\right)={\frac {x_{1}+x_{2}+\dots +x_{n}}{n}}} Similarly, the geometric mean of n positive real numbers is an n -ary function: ( ∏ ∏ i = 1 n a i ) 1 n = a 1 a 2 ⋯ ⋯ a n n .

{\displaystyle \left(\prod _{i=1}^{n}a_{i}\right)^{\frac {1}{n}}=\ {\sqrt[{n}]{a_{1}a_{2}\cdots a_{n}}}.} Note that a logarithm of the geometric mean is the arithmetic mean of the logarithms of its n arguments From a mathematical point of view, a function of n arguments can always be considered as a function of a single argument that is an element of some product space . However, it may be convenient for notation to consider n -ary functions, as for example multilinear maps (which are not linear maps on the product space, if n ≠ 1 ).

The same is true for programming languages, where functions taking several arguments could always be defined as functions taking a single argument of some composite type such as a tuple , or in languages with higher-order functions , by currying .

Varying arity [ edit ] In computer science, a function that accepts a variable number of arguments is called variadic . In logic and philosophy, predicates or relations accepting a variable number of arguments are called multigrade , anadic, or variably polyadic.

[ 8 ] Terminology [ edit ] Latinate names are commonly used for specific arities, primarily based on Latin distributive numbers meaning "in group of n ", though some are based on Latin cardinal numbers or ordinal numbers . For example, 1-ary is based on cardinal unus , rather than from distributive singulī that would result in singulary .

n -ary Arity (Latin based) Adicity (Greek based) Example in mathematics Example in computer science 0-ary nullary (from nūllus ) niladic a constant a function without arguments, True , False 1-ary unary monadic additive inverse logical NOT operator 2-ary binary dyadic addition logical OR , XOR , AND operators 3-ary ternary triadic triple product of vectors ternary conditional operator 4-ary quaternary tetradic 5-ary quinary pentadic 6-ary senary hexadic 7-ary septenary hebdomadic 8-ary octonary ogdoadic 9-ary novenary (alt. nonary) enneadic 10-ary denary (alt. decenary) decadic more than 2-ary multary and multiary polyadic varying variadic sum; e.g., Σ variadic function , reduce n - ary means having n operands (or parameters), but is often used as a synonym of "polyadic".

These words are often used to describe anything related to that number (e.g., undenary chess is a chess variant with an 11×11 board, or the Millenary Petition of 1603).

The arity of a relation (or predicate ) is the dimension of the domain in the corresponding Cartesian product . (A function of arity n thus has arity n +1 considered as a relation.) In computer programming , there is often a syntactical distinction between operators and functions ; syntactical operators usually have arity 1, 2, or 3 (the ternary operator ?: is also common).  Functions vary widely in the number of arguments, though large numbers can become unwieldy. Some programming languages also offer support for variadic functions , i.e., functions syntactically accepting a variable number of arguments.

See also [ edit ] Mathematics portal Philosophy portal Logic of relatives Binary relation Ternary relation Theory of relations Signature (logic) Parameter p -adic number Cardinality Valency (linguistics) n -ary code n -ary group Function prototype – Declaration of a function's name and type signature but not body Type signature – Defines the inputs and outputs for a function, subroutine or method Univariate and multivariate Finitary References [ edit ] ^ Hazewinkel, Michiel (2001).

Encyclopaedia of Mathematics, Supplement III . Springer. p. 3.

ISBN 978-1-4020-0198-7 .

^ Schechter, Eric (1997).

Handbook of Analysis and Its Foundations . Academic Press. p. 356.

ISBN 978-0-12-622760-4 .

^ Detlefsen, Michael; McCarty, David Charles; Bacon, John B. (1999).

Logic from A to Z . Routledge. p.

7 .

ISBN 978-0-415-21375-2 .

^ Cocchiarella, Nino B.; Freund, Max A. (2008).

Modal Logic: An Introduction to its Syntax and Semantics . Oxford University Press. p. 121.

ISBN 978-0-19-536658-7 .

^ Crystal, David (2008).

Dictionary of Linguistics and Phonetics (6th ed.). John Wiley & Sons. p. 507.

ISBN 978-1-405-15296-9 .

^ Quine, W. V. O. (1940), Mathematical logic , Cambridge, Massachusetts: Harvard University Press, p. 13 ^ Robinson, Abraham (1966), Non-standard Analysis , Amsterdam: North-Holland, p. 19 ^ Oliver, Alex (2004). "Multigrade Predicates".

Mind .

113 (452): 609– 681.

doi : 10.1093/mind/113.452.609 .

External links [ edit ] Look up Appendix:English arities and adicities in Wiktionary, the free dictionary.

A monograph available free online: Burris, Stanley N., and H.P. Sankappanavar, H. P., 1981.

A Course in Universal Algebra.

Springer-Verlag.

ISBN 3-540-90578-2 . Especially pp. 22–24.

v t e Mathematical logic General Axiom list Cardinality First-order logic Formal proof Formal semantics Foundations of mathematics Information theory Lemma Logical consequence Model Theorem Theory Type theory Theorems ( list ) and paradoxes Gödel's completeness and incompleteness theorems Tarski's undefinability Banach–Tarski paradox Cantor's theorem, paradox and diagonal argument Compactness Halting problem Lindström's Löwenheim–Skolem Russell's paradox Logics Traditional Classical logic Logical truth Tautology Proposition Inference Logical equivalence Consistency Equiconsistency Argument Soundness Validity Syllogism Square of opposition Venn diagram Propositional Boolean algebra Boolean functions Logical connectives Propositional calculus Propositional formula Truth tables Many-valued logic 3 finite ∞ Predicate First-order list Second-order Monadic Higher-order Fixed-point Free Quantifiers Predicate Monadic predicate calculus Set theory Set hereditary Class ( Ur- ) Element Ordinal number Extensionality Forcing Relation equivalence partition Set operations: intersection union complement Cartesian product power set identities Types of sets Countable Uncountable Empty Inhabited Singleton Finite Infinite Transitive Ultrafilter Recursive Fuzzy Universal Universe constructible Grothendieck Von Neumann Maps and cardinality Function / Map domain codomain image In / Sur / Bi -jection Schröder–Bernstein theorem Isomorphism Gödel numbering Enumeration Large cardinal inaccessible Aleph number Operation binary Set theories Zermelo–Fraenkel axiom of choice continuum hypothesis General Kripke–Platek Morse–Kelley Naive New Foundations Tarski–Grothendieck Von Neumann–Bernays–Gödel Ackermann Constructive Formal systems ( list ), language and syntax Alphabet Arity Automata Axiom schema Expression ground Extension by definition conservative Relation Formation rule Grammar Formula atomic closed ground open Free/bound variable Language Metalanguage Logical connective ¬ ∨ ∧ → ↔ = Predicate functional variable propositional variable Proof Quantifier ∃ !

∀ rank Sentence atomic spectrum Signature String Substitution Symbol function logical/constant non-logical variable Term Theory list Example axiomatic systems ( list ) of arithmetic : Peano second-order elementary function primitive recursive Robinson Skolem of the real numbers Tarski's axiomatization of Boolean algebras canonical minimal axioms of geometry : Euclidean : Elements Hilbert's Tarski's non-Euclidean Principia Mathematica Proof theory Formal proof Natural deduction Logical consequence Rule of inference Sequent calculus Theorem Systems axiomatic deductive Hilbert list Complete theory Independence ( from ZFC ) Proof of impossibility Ordinal analysis Reverse mathematics Self-verifying theories Model theory Interpretation function of models Model equivalence finite saturated spectrum submodel Non-standard model of arithmetic Diagram elementary Categorical theory Model complete theory Satisfiability Semantics of logic Strength Theories of truth semantic Tarski's Kripke's T-schema Transfer principle Truth predicate Truth value Type Ultraproduct Validity Computability theory Church encoding Church–Turing thesis Computably enumerable Computable function Computable set Decision problem decidable undecidable P NP P versus NP problem Kolmogorov complexity Lambda calculus Primitive recursive function Recursion Recursive set Turing machine Type theory Related Abstract logic Algebraic logic Automated theorem proving Category theory Concrete / Abstract category Category of sets History of logic History of mathematical logic timeline Logicism Mathematical object Philosophy of mathematics Supertask Mathematics portal Retrieved from " https://en.wikipedia.org/w/index.php?title=Arity&oldid=1281014024 " Categories : Abstract algebra Universal algebra Hidden categories: Pages using the Phonos extension Articles with short description Short description is different from Wikidata Pages including recorded pronunciations This page was last edited on 17 March 2025, at 19:44 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Arity 33 languages Add topic

