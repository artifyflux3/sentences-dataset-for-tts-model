Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Intuition 2 Abstract interpretation of computer programs 3 Formalization 4 Examples of abstract domains Toggle Examples of abstract domains subsection 4.1 Numerical abstract domains 4.2 Machine word abstract domains 5 See also 6 References 7 External links Toggle the table of contents Abstract interpretation 7 languages Deutsch Eesti فارسی Français Italiano 日本語 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Approach to static program analysis In computer science , abstract interpretation is a theory of sound approximation of the semantics of computer programs , based on monotonic functions over ordered sets , especially lattices . It can be viewed as a partial execution of a computer program which gains information about its semantics (e.g., control-flow , data-flow ) without performing all the calculations .

Its main concrete application is formal static analysis , the automatic extraction of information about the possible executions of computer programs; such analyses have two main usages: inside compilers , to analyse programs to decide whether certain optimizations or transformations are applicable; for debugging or even the certification of programs against classes of bugs.

Abstract interpretation was formalized by the French computer scientist working couple Patrick Cousot and Radhia Cousot in the late 1970s.

[ 1 ] [ 2 ] Intuition [ edit ] This section illustrates abstract interpretation by means of real-world, non-computing examples.

Consider the people in a conference room.  Assume a unique identifier for each person in the room, like a social security number in the United States.  To prove that someone is not present, all one needs to do is see if their social security number is not on the list. Since two different people cannot have the same number, it is possible to prove or disprove the presence of a participant simply by looking up their number.

However it is possible that only the names of attendees were registered. If the name of a person is not found in the list, we may safely conclude that that person was not present; but if it is, we cannot conclude definitely without further inquiries, due to the possibility of homonyms (for example, two people named John Smith).  Note that this imprecise information will still be adequate for most purposes, because homonyms are rare in practice. However, in all rigor, we cannot say for sure that somebody was present in the room; all we can say is that they were possibly here. If the person we are looking up is a criminal, we will issue an alarm ; but there is of course the possibility of issuing a false alarm . Similar phenomena will occur in the analysis of programs.

If we are only interested in some specific information, say, "was there a person of age n {\displaystyle n} in the room?", keeping a list of all names and dates of births is unnecessary. We may safely and without loss of precision restrict ourselves to keeping a list of the participants' ages. If this is already too much to handle, we might keep only the age of the youngest, m {\displaystyle m} and oldest person, M {\displaystyle M} . If the question is about an age strictly lower than m {\displaystyle m} or strictly higher than M {\displaystyle M} , then we may safely respond that no such participant was present. Otherwise, we may only be able to say that we do not know.

In the case of computing, concrete, precise information is in general not computable within finite time and memory (see Rice's theorem and the halting problem ).

Abstraction is used to allow for generalized answers to questions (for example, answering "maybe" to a yes/no question, meaning "yes or no", when we (an algorithm of abstract interpretation) cannot compute the precise answer with certainty); this simplifies the problems, making them amenable to automatic solutions. One crucial requirement is to add enough vagueness so as to make problems manageable while still retaining enough precision for answering the important questions (such as "might the program crash?").

Abstract interpretation of computer programs [ edit ] Given a programming or specification language, abstract interpretation consists of giving several semantics linked by relations of abstraction. A semantics is a mathematical characterization of a possible behavior of the program. The most precise semantics, describing very closely the actual execution of the program, are called the concrete semantics . For instance, the concrete semantics of an imperative programming language may associate to each program the set of execution traces it may produce – an execution trace being a sequence of possible consecutive states of the execution of the program; a state typically consists of the value of the program counter and the memory locations (globals, stack and heap). More abstract semantics are then derived; for instance, one may consider only the set of reachable states in the executions (which amounts to considering the last states in finite traces).

The goal of static analysis is to derive a computable semantic interpretation  at some point. For instance, one may choose to represent the state of a program manipulating integer variables by forgetting the actual values of the variables and only keeping their signs (+, − or 0). For some elementary operations, such as multiplication , such an abstraction does not lose any precision: to get the sign of a product, it is sufficient to know the sign of the operands. For some other operations, the abstraction may lose precision: for instance, it is impossible to know the sign of a sum whose operands are respectively positive and negative.

Sometimes a loss of precision is necessary to make the semantics decidable (see Rice's theorem and the halting problem ). In general, there is a compromise to be made between the precision of the analysis and its decidability ( computability ), or tractability ( computational cost ).

In practice the abstractions that are defined are tailored to both the program properties one desires to analyze, and to the set of target programs. The first large scale automated analysis of computer programs with abstract interpretation was motivated by the accident that resulted in the destruction of the first flight of the Ariane 5 rocket in 1996.

[ 3 ] Formalization [ edit ] Example: abstraction of integer sets (red) to sign sets (green) Let L {\displaystyle L} be an ordered set , called concrete set , and let L ′ {\displaystyle L'} be another ordered set, called abstract set . These two sets are related to each other by defining total functions that map elements from one to the other.

A  function α α {\displaystyle \alpha } is called an abstraction function if it maps an element x {\displaystyle x} in the concrete set L {\displaystyle L} to an element α α ( x ) {\displaystyle \alpha (x)} in the abstract set L ′ {\displaystyle L'} . That is, element α α ( x ) {\displaystyle \alpha (x)} in L ′ {\displaystyle L'} is the abstraction of x {\displaystyle x} in L {\displaystyle L} .

A function γ γ {\displaystyle \gamma } is called a concretization function if it maps an element x ′ {\displaystyle x'} in the abstract set L ′ {\displaystyle L'} to an element γ γ ( x ′ ) {\displaystyle \gamma (x')} in the concrete set L {\displaystyle L} . That is, element γ γ ( x ′ ) {\displaystyle \gamma (x')} in L {\displaystyle L} is a concretization of x ′ {\displaystyle x'} in L ′ {\displaystyle L'} .

Let L 1 {\displaystyle L_{1}} , L 2 {\displaystyle L_{2}} , L 1 ′ {\displaystyle L'_{1}} , and L 2 ′ {\displaystyle L'_{2}} be ordered sets. The concrete semantics f {\displaystyle f} is a monotonic function from L 1 {\displaystyle L_{1}} to L 2 {\displaystyle L_{2}} . A function f ′ {\displaystyle f'} from L 1 ′ {\displaystyle L'_{1}} to L 2 ′ {\displaystyle L'_{2}} is said to be a valid abstraction of f {\displaystyle f} if, for all x ′ {\displaystyle x'} in L 1 ′ {\displaystyle L'_{1}} , we have ( f ∘ ∘ γ γ ) ( x ′ ) ≤ ≤ ( γ γ ∘ ∘ f ′ ) ( x ′ ) {\displaystyle (f\circ \gamma )(x')\leq (\gamma \circ f')(x')} .

Program semantics are generally described using fixed points in the presence of loops or recursive procedures. Suppose that L {\displaystyle L} is a complete lattice and let f {\displaystyle f} be a monotonic function from L {\displaystyle L} into L {\displaystyle L} . Then, any x ′ {\displaystyle x'} such that f ( x ′ ) ≤ ≤ x ′ {\displaystyle f(x')\leq x'} is an abstraction of the least fixed-point of f {\displaystyle f} , which exists, according to the Knaster–Tarski theorem .

The difficulty is now to obtain such an x ′ {\displaystyle x'} . If L ′ {\displaystyle L'} is of finite height, or at least verifies the ascending chain condition (all ascending sequences are ultimately stationary), then such an x ′ {\displaystyle x'} may be obtained as the stationary limit of the ascending sequence x n ′ {\displaystyle x'_{n}} defined by induction as follows: x 0 ′ = ⊥ ⊥ {\displaystyle x'_{0}=\bot } (the least element of L ′ {\displaystyle L'} ) and x n + 1 ′ = f ′ ( x n ′ ) {\displaystyle x'_{n+1}=f'(x'_{n})} .

In other cases, it is still possible to obtain such an x ′ {\displaystyle x'} through a (pair-) widening operator , [ 4 ] defined as a binary operator ∇ ∇ : : L × × L → → L {\displaystyle \nabla \colon L\times L\to L} which satisfies the following conditions: For all x {\displaystyle x} and y {\displaystyle y} , we have x ≤ ≤ x ∇ ∇ y {\displaystyle x\leq x\mathbin {\nabla } y} and y ≤ ≤ x ∇ ∇ y {\displaystyle y\leq x\mathbin {\nabla } y} , and For any ascending sequence ( y n ′ ) n ≥ ≥ 0 {\displaystyle (y'_{n})_{n\geq 0}} , the sequence defined by x 0 ′ := ⊥ ⊥ {\displaystyle x'_{0}:=\bot } and x n + 1 ′ := x n ′ ∇ ∇ y n ′ {\displaystyle x'_{n+1}:=x'_{n}\mathbin {\nabla } y'_{n}} is ultimately stationary. We can then take y n ′ = f ′ ( x n ′ ) {\displaystyle y'_{n}=f'(x'_{n})} .

In some cases, it is possible to define abstractions using Galois connections ( α α , γ γ ) {\displaystyle (\alpha ,\gamma )} where α α {\displaystyle \alpha } is from L {\displaystyle L} to L ′ {\displaystyle L'} and γ γ {\displaystyle \gamma } is from L ′ {\displaystyle L'} to L {\displaystyle L} . This supposes the existence of best abstractions, which is not necessarily the case. For instance, if we abstract sets of couples ( x , y ) {\displaystyle (x,y)} of real numbers by enclosing convex polyhedra , there is no optimal abstraction to the disc defined by x 2 + y 2 ≤ ≤ 1 {\displaystyle x^{2}+y^{2}\leq 1} .

Examples of abstract domains [ edit ] Numerical abstract domains [ edit ] One can assign to each variable x {\displaystyle x} available at a given program point an interval [ L x , H x ] {\displaystyle [L_{x},H_{x}]} . A state assigning the value v ( x ) {\displaystyle v(x)} to variable x {\displaystyle x} will be a concretization of these intervals if, for all x {\displaystyle x} , we have v ( x ) ∈ ∈ [ L x , H x ] {\displaystyle v(x)\in [L_{x},H_{x}]} . From the intervals [ L x , H x ] {\displaystyle [L_{x},H_{x}]} and [ L y , H y ] {\displaystyle [L_{y},H_{y}]} for variables x {\displaystyle x} and y {\displaystyle y} , respectively, one can easily obtain intervals for x + y {\displaystyle x+y} (namely, [ L x + L y , H x + H y ] {\displaystyle [L_{x}+L_{y},H_{x}+H_{y}]} ) and for x − − y {\displaystyle x-y} (namely, [ L x − − H y , H x − − L y ] {\displaystyle [L_{x}-H_{y},H_{x}-L_{y}]} ); note that these are exact abstractions, since the set of possible outcomes for, say, x + y {\displaystyle x+y} , is precisely the interval [ L x + L y , H x + H y ] {\displaystyle [L_{x}+L_{y},H_{x}+H_{y}]} . More complex formulas can be derived for multiplication, division, etc., yielding so-called interval arithmetics .

[ 5 ] Let us now consider the following very simple program: y = x;
z = x - y; Combination of interval arithmetic ( green ) and congruence mod 2 on integers ( cyan ) as abstract domains to analyze a simple piece of C code ( red : concrete sets of possible values at runtime). Using the congruence information ( 0 =even, 1 =odd), a zero division can be excluded. (Since only one variable is involved, relational vs. non-relational domains is not an issue here.) A 3-dimensional convex example polyhedron describing the possible values of 3 variables at some program point. Each of the variables may be zero, but all three can't be zero simultaneously. The latter property cannot be described in the interval arithmetics domain.

With reasonable arithmetic types, the result for z should be zero. But if we do interval arithmetic starting from x in [0, 1], one gets z in [−1, +1]. While each of the operations taken individually was exactly abstracted, their composition isn't.

The problem is evident: we did not keep track of the equality relationship between x and y ; actually, this domain of intervals does not take into account any relationships between variables, and is thus a non-relational domain . Non-relational domains tend to be fast and simple to implement, but imprecise.

Some examples of relational numerical abstract domains are: congruence relations on integers [ 6 ] [ 7 ] convex polyhedra [ 8 ] (cf. left picture) – with some high computational costs difference-bound matrices [ 9 ] "octagons" [ 10 ] [ 11 ] [ 12 ] linear equalities [ 13 ] and combinations thereof (such as the reduced product, [ 2 ] cf. right picture).

When one chooses an abstract domain, one typically has to strike a balance between keeping fine-grained relationships, and high computational costs.

Machine word abstract domains [ edit ] While high-level languages such as Python or Haskell use unbounded integers by default, lower-level programming languages such as C or assembly language typically operate on finitely-sized machine words , which are more suitably modeled using the integers modulo 2 n {\textstyle 2^{n}} (where n is the bit width of a machine word). There are several abstract domains suitable for various analyses of such variables.

The bitfield domain treats each bit in a machine word separately, i.e., a word of width n is treated as an array of n abstract values. The abstract values are taken from the set { 0 , 1 , ⊥ ⊥ } {\textstyle \{0,1,\bot \}} , and the abstraction and concretization functions are given by: [ 14 ] [ 15 ] γ γ ( 0 ) = { 0 } {\displaystyle \gamma (0)=\{0\}} , γ γ ( 1 ) = { 1 } {\displaystyle \gamma (1)=\{1\}} , γ γ ( ⊥ ⊥ ) = { 0 , 1 } {\displaystyle \gamma (\bot )=\{0,1\}} , α α ( { 0 } ) = 0 {\displaystyle \alpha (\{0\})=0} , α α ( { 1 } ) = 1 {\displaystyle \alpha (\{1\})=1} , α α ( { 0 , 1 } ) = ⊥ ⊥ {\displaystyle \alpha (\{0,1\})=\bot } , α α ( { } ) = ⊥ ⊥ {\displaystyle \alpha (\{\})=\bot } . Bitwise operations on these abstract values are identical with the corresponding logical operations in some three-valued logics : [ 16 ] NOT(A) A ¬A 0 1 ⊥ ⊥ 1 0 AND(A, B) A ∧ B B 0 ⊥ 1 A 0 0 0 0 ⊥ 0 ⊥ ⊥ 1 0 ⊥ 1 OR(A, B) A ∨ B B 0 ⊥ 1 A 0 0 ⊥ 1 ⊥ ⊥ ⊥ 1 1 1 1 1 Further domains include the signed interval domain and the unsigned interval domain . All three of these domains support forwards and backwards abstract operators for common operations such as addition, shifts , xor, and multiplication. These domains can be combined using the reduced product.

[ 17 ] See also [ edit ] Model checking Symbolic simulation Symbolic execution List of tools for static code analysis — contains both abstract-interpretation based (sound) and ad hoc (unsound) tools Static program analysis — overview of analysis methods, including, but not restricted to, abstract interpretation Interpreter (computing) References [ edit ] ^ Cousot, Patrick; Cousot, Radhia (1977).

"Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints" (PDF) .

Conference Record of the Fourth ACM Symposium on Principles of Programming Languages, Los Angeles, California, USA, January 1977 . ACM Press. pp.

238– 252.

doi : 10.1145/512950.512973 .

S2CID 207614632 .

^ a b Cousot, Patrick; Cousot, Radhia (1979).

"Systematic Design of Program Analysis Frameworks" (PDF) .

Conference Record of the Sixth Annual ACM Symposium on Principles of Programming Languages, San Antonio, Texas, USA, January 1979 . ACM Press. pp.

269– 282.

doi : 10.1145/567752.567778 .

S2CID 1547466 .

^ Faure, Christèle.

"PolySpace Technologies History" . Retrieved 3 October 2010 .

^ Cousot, P.; Cousot, R. (August 1992).

"Comparing the Galois Connection and Widening / Narrowing Approaches to Abstract Interpretation" (PDF) . In Bruynooghe, Maurice; Wirsing, Martin (eds.).

Proc. 4th Int. Symp. on Programming Language Implementation and Logic Programming (PLILP) . Lecture Notes in Computer Science. Vol. 631. Springer. pp.

269– 296.

ISBN 978-0-387-55844-8 .

^ Cousot, Patrick; Cousot, Radhia (1976).

"Static determination of dynamic properties of programs" (PDF) .

Proceedings of the Second International Symposium on Programming . Dunod, Paris, France. pp.

106– 130.

^ Granger, Philippe (1989). "Static Analysis of Arithmetical Congruences".

International Journal of Computer Mathematics .

30 ( 3– 4): 165– 190.

doi : 10.1080/00207168908803778 .

^ Philippe Granger (1991). "Static Analysis of Linear Congruence Equalities Among Variables of a Program". In Abramsky, S.; Maibaum, T.S.E. (eds.).

Proc. Int. J. Conf. on Theory and Practice of Software Development (TAPSOFT) . Lecture Notes in Computer Science. Vol. 493. Springer. pp.

169– 192.

^ Cousot, Patrick; Halbwachs, Nicolas (January 1978).

"Automatic Discovery of Linear Restraints Among Variables of a Program" (PDF) .

Conf. Rec. 5th ACM Symp. on Principles of Programming Languages (POPL) . pp.

84– 97.

^ Miné, Antoine (2001). "A New Numerical Abstract Domain Based on Difference-Bound Matrices". In Danvy, Olivier; Filinski, Andrzej (eds.).

Programs as Data Objects, Second Symposium, (PADO) . Lecture Notes in Computer Science. Vol. 2053. Springer. pp.

155– 172.

arXiv : cs/0703073 .

^ Miné, Antoine (Dec 2004).

Weakly Relational Numerical Abstract Domains (PDF) (Ph.D. thesis). Laboratoire d'Informatique de l'École Normale Supérieure.

^ Antoine Miné (2006). "The Octagon Abstract Domain".

Higher Order Symbol. Comput .

19 (1): 31– 100.

arXiv : cs/0703084 .

doi : 10.1007/s10990-006-8609-1 .

^ Clarisó, Robert; Cortadella, Jordi (2007). "The Octahedron Abstract Domain".

Science of Computer Programming .

64 : 115– 139.

doi : 10.1016/j.scico.2006.03.009 .

hdl : 10609/109823 .

^ Michael Karr (1976). "Affine Relationships Among Variables of a Program".

Acta Informatica .

6 (2): 133– 151.

doi : 10.1007/BF00268497 .

S2CID 376574 .

^ Miné, Antoine (Jun 2012).

"Abstract domains for bit-level machine integer and floating-point operations" .

WING'12 - 4th International Workshop on Invariant Generation . Manchester, United Kingdom: 16.

^ Regehr, John; Duongsaa, Usit (Jun 2006).

"Deriving abstract transfer functions for analyzing embedded software" .

Proceedings of the 2006 ACM SIGPLAN/SIGBED conference on Language, compilers, and tool support for embedded systems . LCTES '06. New York, NY, USA: Association for Computing Machinery. pp.

34– 43.

doi : 10.1145/1134650.1134657 .

ISBN 978-1-59593-362-1 .

S2CID 13221224 .

^ Reps, T.; Loginov, A.; Sagiv, M. (Jul 2002).

"Semantic minimization of 3-valued propositional formulae" .

Proceedings 17th Annual IEEE Symposium on Logic in Computer Science . pp.

40– 51.

doi : 10.1109/LICS.2002.1029816 .

ISBN 0-7695-1483-9 .

S2CID 8451238 .

^ Yoon, Yongho; Lee, Woosuk; Yi, Kwangkeun (2023-06-06).

"Inductive Program Synthesis via Iterative Forward-Backward Abstract Interpretation" .

Proceedings of the ACM on Programming Languages .

7 (PLDI): 174:1657–174:1681.

arXiv : 2304.10768 .

doi : 10.1145/3591288 .

External links [ edit ] A web-page on Abstract Interpretation maintained by Patrick Cousot Roberto Bagnara's paper showing how it is possible to implement an abstract-interpretation based static analyzer for a C-like programming language The Static Analysis Symposia , proceedings appearing in the Springer LNCS series Conference on Verification, Model-Checking, and Abstract Interpretation (VMCAI), affiliated at the POPL conference , proceedings appearing in the Springer LNCS series Lecture notes Abstract Interpretation . Patrick Cousot. MIT.

David Schmidt's lecture notes on abstract interpretation Møller and Schwarzbach's lecture notes on Static Program Analysis Agostino Cortesi's lecture notes on Program Analysis and Verification Slides by Grégoire Sutre going through every step of Abstract Interpretation with many examples - also introducing Galois connections v t e Program analysis Key concepts Control-flow graph Correctness Hyperproperties Invariants Path explosion Polyvariance Rice's theorem Runtime verification Safety and liveness Undefined behavior Semantics Types Axiomatic Denotational Categorical semantics Operational Big-step Small-step Models Lambda calculus Petri net Process calculus Rewriting system State machine Turing machine Analyses Static Abstract interpretation Alias Control flow kCFA Data-flow Dependence Effect system Escape Model checking Pointer Shape Symbolic execution Termination Type systems Typestate Dynamic Data-flow Taint tracking Concolic testing Fuzzing Invariant inference Program slicing Testing Formal methods Concepts Curry–Howard correspondence Loop invariant Refinement Side effect Soundness and completeness Specification Languages Verification Logics Hoare Incorrectness Linear Separation Temporal Data structures BDD E-graph Hashcons Union-find Tools Constraint solvers CHC SAT SMT Lightweight Alloy TLA+ Proof assistants ACL2 Agda F* HOL Light HOL4 Idris Isabelle Isabelle/HOL Lean LEGO Mizar NuPRL PVS Rocq Twelf Category Outline Glossary Retrieved from " https://en.wikipedia.org/w/index.php?title=Abstract_interpretation&oldid=1291943451 " Categories : Abstract interpretation Program analysis Hidden categories: Articles with short description Short description matches Wikidata This page was last edited on 24 May 2025, at 09:28 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Abstract interpretation 7 languages Add topic

