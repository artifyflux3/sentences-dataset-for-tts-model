Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 History 2 Software life cycle Toggle Software life cycle subsection 2.1 Transition from release to maintenance to end of the lifespan 2.2 Change cycle 3 Categories of software maintenance 4 Maintainability 5 Workforce 6 Alternatives to maintenance 7 Research 8 References 9 Sources Toggle the table of contents Software maintenance 29 languages العربية Català Deutsch Eesti Español فارسی Français Galego 한국어 Հայերեն Hrvatski Italiano עברית Magyar Македонски 日本語 Norsk bokmål Polski Português Русский Shqip Српски / srpski தமிழ் Türkçe Українська اردو Tiếng Việt 粵語 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Modification of software after delivery Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Outline of software development v t e Software maintenance is the modification of software after delivery.

Software maintenance is often considered lower skilled and less rewarding than new development. As such, it is a common target for outsourcing or offshoring . Usually, the team developing the software is different from those who will be maintaining it. The developers lack an incentive to write the code to be easily maintained. Software is often delivered incomplete and almost always contains some bugs that the maintenance team must fix. Software maintenance often initially includes the development of new functionality, but as the product nears the end of its lifespan, maintenance is reduced to the bare minimum and then cut off entirely before the product is withdrawn.

Each maintenance cycle begins with a change request typically originating from an end user. That request is evaluated and if it is decided to implement it, the programmer studies the existing code to understand how it works before implementing the change. Testing to make sure the existing functionality is retained and the desired new functionality is added often comprises most of the maintenance cost.

Software maintenance is not as well studied as other phases of the software life cycle, despite comprising most of the cost. Understanding has not changed significantly since the 1980s. Software maintenance can be categorized into several types depending on whether it is preventative or reactive and whether it is seeking to add functionality or preserve existing functionality, the latter typically in the face of a changed environment.

History [ edit ] In the early 1970s, companies began to separate out software maintenance with its own team of engineers to free up software development teams from support tasks.

[ 1 ] In 1972, R. G. Canning published "The Maintenance 'Iceberg ' ", in which he contended that software maintenance was an extension of software development with an additional input: the existing system.

[ 1 ] The discipline of software maintenance has changed little since then.

[ 2 ] One twenty-first century innovation has been companies deliberately releasing incomplete software and planning to finish it post-release. This type of change, and others that expand functionality, is often called software evolution instead of maintenance.

[ 2 ] Software life cycle [ edit ] Diagram for a traditional software development life cycle from 1988 Despite testing and quality assurance , virtually all software contains bugs where the system does not work as intended. Post-release maintenance is necessary to remediate these bugs when they are found.

[ 3 ] Most software is a combination of pre-existing commercial off-the-shelf (COTS) and open-source software components with custom-written code. COTS and open-source software is typically updated over time, which can reduce the maintenance burden, but the modifications to these software components will need to be adjusted for in the final product.

[ 4 ] Unlike software development , which is focused on meeting specified requirements, software maintenance is driven by events—such as user requests or detection of a bug.

[ 5 ] Its main purpose is to preserve the usefulness of the software, usually in the face of changing requirements.

[ 6 ] If conceived of as part of the software development life cycle , maintenance is the last and typically the longest phase of the cycle, [ 7 ] [ 8 ] comprising 80 to 90 percent of the lifecycle cost.

[ 9 ] Other models consider maintenance separate from software development, instead as part of the software maintenance life cycle (SMLC).

[ 8 ] SMLC models typically include understanding the code, modifying it, and revalidating it.

[ 8 ] Transition from release to maintenance to end of the lifespan [ edit ] Diagram showing the steps for software retirement Frequently, software is delivered in an incomplete state. Developers will test a product until running out of time or funding, because they face fewer consequences for an imperfect product than going over time or budget.

[ 10 ] The transition from the development to the maintenance team is often inefficient, without lists of known issues or validation tests, which the maintenance team will  likely recreate.

[ 11 ] After release, members of the development team are likely to be reassigned or otherwise become unavailable. The maintenance team will require additional resources for the first year after release, both for technical support and fixing defects left over from development.

[ 10 ] Initially, software may go through a period of enhancements after release. New features are added according to user feedback. At some point, the company may decide that it is no longer profitable to make functional improvements, and restrict support to bug fixing and emergency updates. Changes become increasingly difficult and expensive due to lack of expertise or decaying architecture due to software aging . After a product is no longer maintained, and does not receive even this limited level of updating, some vendors will seek to extract revenue from the software as long as possible, even though the product is likely to become increasingly avoided. Eventually, the software will be withdrawn from the market, although it may remain in use. During this process, the software becomes a legacy system .

[ 12 ] Change cycle [ edit ] The first step in the change cycle is receiving a change request from a customer and analyzing it to confirm the problem and decide whether to implement the change.

[ 13 ] This may require input from multiple departments; for example, the marketing team can help evaluate whether the change is expected to bring more business.

[ 14 ] Software development effort estimation is a difficult problem, including for maintenance change requests, [ 15 ] but the request is likely to be declined if it is too expensive or infeasible.

[ 16 ] If it is decided to implement the request, it can be assigned to a scheduled release and implemented.

[ 16 ] Although agile methodology does not have a maintenance phase, [ 17 ] the change cycle can be enacted as a scrum sprint .

[ 18 ] Understanding existing code is an essential step before modifying it.

[ 2 ] The rate of understanding depends both on the code base as well as the skill of the programmer.

[ 19 ] Following coding conventions such as using clear function and variable names that correspond to their purpose makes understanding easier.

[ 20 ] Use of conditional loop statements only if the code could execute more than once, and eliminating code that will never execute can also increase understandability.

[ 21 ] Experienced programmers have an easier time understanding what the code does at a high level.

[ 22 ] Software visualization is sometimes used to speed up this process.

[ 23 ] Modification to the code may take place in any way. On the one hand, it is common to haphazardly apply a quick fix without being granted enough time to update the code documentation .

[ 24 ] On the other hard structured iterative enhancement can begin by changing the top-level requirements document and propagating the change down to lower levels of the system.

[ 25 ] Modification often includes code refactoring (improving the structure without changing functionality) and restructuring (improving structure and functionality at the same time).

[ 26 ] Unlike commercial software, free and open source software change cycles are largely restricted to coding and testing, with minimal documentation. Open-source software projects instead rely on mailing lists and a large number of contributors to understand the code base and fix bugs efficiently.

[ 27 ] An additional problem with maintenance is that nearly every change to code will introduce new bugs or unexpected ripple effects , which require another round of fixes.

[ 2 ] Testing can consume most of the maintenance resource for safety-critical code, due to the need to revalidate the entire software if any changes are made.

[ 28 ] Revalidation may include code review , regression testing with a subset of unit tests , integration tests , and system tests .

[ 26 ] The goal of the testing is to verify that previous functionality is retained, and the new functionality has been added.

[ 29 ] Categories of software maintenance [ edit ] The key purpose of software maintenance is ensuring that the product continues to meet usability requirements. At times, this may mean extending the product's capabilities beyond what was initially envisioned.

[ 30 ] According to the ISO / IEC 14764 specification, software maintenance can be classified into four types: [ 31 ] Corrective maintenance : modification of software to fix a bug or other failure to meet requirements, typically reported by an end user.

[ 31 ] [ 32 ] Preventive maintenance : forward-looking modification of software after delivery to ensure it continues to meet requirements or fix problems that have not manifested yet.

[ 33 ] [ 31 ] This type of maintenance is performed especially on systems that are required to be highly safe or available.

[ 33 ] Software rejuvenation is one form of preventative maintenance to clean up state and prevent future problems.

[ 33 ] Adaptive maintenance: modification of software performed after delivery to ensure its continuing usability in a changed or changing environment.

[ 31 ] [ 33 ] Perfective maintenance: enhancement of software after delivery to improve qualities such as user experience , processing efficiency, and maintainability .

[ 33 ] [ 34 ] Perfective maintenance is necessary if other types of maintenance are carried out, because modification of an existing code base will otherwise increase complexity and cause the existing structure to deteriorate.

[ 34 ] Perfective maintenance may include rewriting documentation , code refactoring , and performance tuning.

[ 33 ] According to some estimates, enhancement (the latter two categories) comprises some 80 percent of software maintenance.

[ 35 ] Maintainability [ edit ] Maintainability is the quality of software enabling it to be easily modified without breaking existing functionality.

[ 31 ] According to the  ISO/IEC 14764 specification, activity to ensure software maintainability prior to release counts as part of software maintenance.

[ 5 ] Many software development organizations neglect maintainability, even though doing so will increase long-term costs.

[ 36 ] Technical debt is incurred when programmers, often out of laziness or urgency to meet a deadline, choose quick and dirty solutions rather than build maintainability into their code.

[ 37 ] A common cause is underestimates in software development effort estimation , leading to insufficient resources allocated to development.

[ 38 ] One important aspect is having a large amount of automated software tests that can detect if existing functionality is compromised by a change.

[ 31 ] A maintainability index can be calculated with certain formulae from lines-of-code measures , McCabe measures and Halstead complexity measures .

The measurement and tracking of maintainability are intended to help reduce or reverse a system's tendency toward "code entropy" or degraded integrity, and to indicate when it becomes cheaper and/or less risky to rewrite the code than it is to change it.

A challenge with maintainability is that many software engineering courses do not emphasize it, and give out one-and-done assignments that have clear and unchanging specifications.

[ 39 ] Software engineering courses do not cover systems as complex as occur in the real world.

[ 40 ] Development engineers who know that they will not be responsible for maintaining the software do not have an incentive to build in maintainability.

[ 2 ] Workforce [ edit ] Maintenance is often considered an unrewarding job for software engineers , who, if assigned to maintenance, were more likely to quit.

[ 41 ] [ 42 ] It often pays less than a comparable job in software development.

[ 42 ] The task is often assigned to temporary workers or lesser-skilled staff, [ 2 ] [ 43 ] although maintenance engineers are also typically older than developers, partly because they must be familiar with outdated technologies.

[ 43 ] In 2008, around 900,000 of the 1.3 million software engineers and programmers working in the United States were doing maintenance.

[ 44 ] Companies started separate teams for maintenance, which led to outsourcing this work to a different company, and by the turn of the twenty-first century, sometimes offshoring the work to another country—whether as part of the original company or a separate entity.

[ 45 ] [ 9 ] The typical sources of outsourcing are developed countries such as the United States, the United Kingdom, Japan, and Australia, while destinations are usually lower-cost countries such as China, India, Russia, and Ireland.

[ 46 ] Reasons for offshoring include taking advantage of lower labor costs, enabling around-the-clock support, reducing time pressure on developers, and to move support closer to the market for the product.

[ 47 ] Downsides of offshoring include communication barriers in the form of such factors as time zone and organizational disjunction and cultural differences.

[ 9 ] Despite many employers considering maintenance lower-skilled work and the phase of software development most suited to offshoring, [ 9 ] [ 48 ] it requires close communication with the customer and rapid response, both of which are hampered by these communication difficulties.

[ 9 ] Alternatives to maintenance [ edit ] In software engineering, the term legacy system does not have a fixed meaning, but often refers to older systems which are large, difficult to modify, and also necessary for current business needs. Often legacy systems are written in obsolete programming languages , lack documentation, have a deteriorating structure after years of changes, and depend on experts to keep it operational.

[ 49 ] When dealing with these systems, at some point so much technical debt accumulates that maintenance is not practical or economical.

[ 12 ] Other choices include: Freezing—do no more work on the legacy system.

[ 50 ] This option may be chosen if the vendor wants to continue to extract revenue as long as possible while avoiding maintenance costs.

[ 12 ] Outsourcing functionality of the legacy system to a different company, especially if it is not considered a core business function.

[ 50 ] Discarding the existing legacy system and redeveloping a new application from scratch to fulfill the same purpose as the legacy system.

[ 50 ] However, this approach is inefficient due to discarding a working system, and with this approach there is a danger that the new system will not fulfill changing business requirements.

[ 50 ] Wrapping the legacy application in an abstraction layer to simplify outdated interfaces.

[ 50 ] The source code is not modified but the new interface allows a tried and tested component to be accessed by newer applications. This approach does not fix any of the issues with maintaining a legacy system.

[ 51 ] Databases, functions, and entire applications may be wrapped in this way.

[ 52 ] Migrating the legacy system to a new platform, which can reduce the expense of new software development by reusing the  implementation, design, specification, and requirements of the legacy system.

[ 53 ] Migration can take 5 to 10 years, but results in greater flexibility and long-term savings in software maintenance.

[ 54 ] As much as 80 percent of the expense is in testing; that is, ensuring that the new system has the same output as the old system.

[ 55 ] After the new system is finished, there needs to be a transition from the old system to the new system with minimum disruption to business functions.

[ 55 ] Research [ edit ] Despite taking up the lion's share of software development resources, maintenance is the least studied phase of software development.

[ 56 ] [ 57 ] Much of the literature has focused on how to develop maintainable code from the outset, with less focus on motivating engineers to make maintainability a priority.

[ 58 ] As of 2020 [update] , automated solutions for code refactoring to reduce maintenance effort are an active area of research, [ 59 ] as is machine-learning enhanced maintainability assessment.

[ 60 ] References [ edit ] ^ a b Tripathy & Naik 2014 , p. 25.

^ a b c d e f Offutt, Jeff (January 2018).

"Overview of Software Maintenance and Evolution" .

George Mason University Department of Computer Science . Retrieved 5 May 2024 .

^ Tripathy & Naik 2014 , p. 4.

^ Tripathy & Naik 2014 , pp. 5–6.

^ a b Tripathy & Naik 2014 , p. 26.

^ Madhusudhan et al.

2017 , p. 761.

^ Varga 2018 , p. 3.

^ a b c Tripathy & Naik 2014 , p. 7.

^ a b c d e Ulziit et al.

2015 , p. 764.

^ a b Reifer 2012 , p. 22.

^ Reifer 2012 , p. 21.

^ a b c Tripathy & Naik 2014 , p. 89.

^ Madhusudhan et al.

2017 , p. 763.

^ Tripathy & Naik 2014 , p. 120.

^ Madhusudhan et al.

2017 , p. 762.

^ a b Tripathy & Naik 2014 , p. 123.

^ Ali et al.

2024 , p. 126.

^ Ali et al.

2024 , p. 130.

^ Tripathy & Naik 2014 , p. 296.

^ Tripathy & Naik 2014 , pp. 296–297.

^ Tripathy & Naik 2014 , p. 309.

^ Tripathy & Naik 2014 , p. 297.

^ Tripathy & Naik 2014 , pp. 318–319.

^ Tripathy & Naik 2014 , pp. 85–86.

^ Tripathy & Naik 2014 , p. 86.

^ a b Tripathy & Naik 2014 , p. 94.

^ Tripathy & Naik 2014 , p. 59.

^ Reifer 2012 , p. 5.

^ Tripathy & Naik 2014 , p. 98.

^ Varga 2018 , p. 4.

^ a b c d e f Varga 2018 , p. 5.

^ Tripathy & Naik 2014 , pp. 26–27.

^ a b c d e f Tripathy & Naik 2014 , p. 27.

^ a b Varga 2018 , pp. 5–6.

^ Varga 2018 , p. 5 fn 4.

^ Varga 2018 , p. 12.

^ Varga 2018 , pp. 6–7.

^ Varga 2018 , p. 7.

^ Varga 2018 , pp. 7–8.

^ Varga 2018 , p. 9.

^ Madhusudhan et al.

2017 , p. 764.

^ a b Reifer 2012 , p. 7.

^ a b Reifer 2012 , p. 8.

^ Reifer 2012 , p. 1.

^ Rahman et al.

2024 , p. 1.

^ Rahman et al.

2021 , Research Background.

^ Ulziit et al.

2015 , p. 763.

^ Reifer 2012 , p. 2.

^ Tripathy & Naik 2014 , pp. 187–188.

^ a b c d e Tripathy & Naik 2014 , p. 188.

^ Tripathy & Naik 2014 , p. 189.

^ Tripathy & Naik 2014 , p. 191.

^ Tripathy & Naik 2014 , pp. 188–189.

^ Tripathy & Naik 2014 , p. 195.

^ a b Tripathy & Naik 2014 , p. 196.

^ Madhusudhan et al.

2017 , p. 759.

^ Ulziit et al.

2015 , p. 766.

^ Reifer 2012 , pp. 4–5.

^ Baqais & Alshayeb 2020 , p. 459.

^ Alsolai & Roper 2020 , p. 106214.

Sources [ edit ] Ali, Muhammad; Cheema, Sehrish Munawar; Naz, Ammerha; Pires, Ivan Miguel (2024). "SAMSEF: An Agile Software Maintenance Leveraging Scrum Framework for Improved Efficiency and Effectiveness".

Good Practices and New Perspectives in Information Systems and Technologies . Lecture Notes in Networks and Systems. Vol. 989. Springer Nature Switzerland. pp.

126– 136.

doi : 10.1007/978-3-031-60227-6_11 .

ISBN 978-3-031-60226-9 .

Alsolai, Hadeel; Roper, Marc (2020).

"A systematic literature review of machine learning techniques for software maintainability prediction" (PDF) .

Information and Software Technology .

119 106214.

doi : 10.1016/j.infsof.2019.106214 .

Baqais, Abdulrahman Ahmed Bobakr; Alshayeb, Mohammad (2020). "Automatic software refactoring: a systematic literature review".

Software Quality Journal .

28 (2): 459– 502.

doi : 10.1007/s11219-019-09477-y .

Madhusudhan, V.; Suma, V.; Rao, Jawahar J. (2017).

Software Maintenance: From the Perspective of Effort and Cost Requirement . Proceedings of the International Conference on Data Engineering and Communication Technology. Springer. pp.

759– 768.

ISBN 978-981-10-1678-3 .

Rahman, Hanif Ur; da Silva, Alberto Rodrigues; Alzayed, Asaad; Raza, Mushtaq (2024). "A Systematic Literature Review on Software Maintenance Offshoring Decisions".

Information and Software Technology .

172 107475.

doi : 10.1016/j.infsof.2024.107475 .

Rahman, Hanif Ur; Raza, Mushtaq; Afsar, Palwasha; Khan, Habib Ullah (2021). "Empirical Investigation of Influencing Factors Regarding Offshore Outsourcing Decision of Application Maintenance".

IEEE Access .

9 : 58589– 58608.

Bibcode : 2021IEEEA...958589R .

doi : 10.1109/ACCESS.2021.3073315 .

hdl : 10576/37687 .

ISSN 2169-3536 .

Reifer, Donald J. (2012).

Software Maintenance Success Recipes . CRC Press.

ISBN 978-1-4398-5167-8 .

Tripathy, Priyadarshi; Naik, Kshirasagar (2014).

Software Evolution and Maintenance: A Practitioner's Approach . John Wiley & Sons.

ISBN 978-0-470-60341-3 .

Ulziit, Bayarbuyan; Warraich, Zeeshan Akhtar; Gencel, Cigdem; Petersen, Kai (2015). "A conceptual framework of challenges and solutions for managing global software maintenance".

Journal of Software: Evolution and Process .

27 (10): 763– 792.

doi : 10.1002/smr.1720 .

Varga, Ervin (2018).

Unraveling Software Maintenance and Evolution: Thinking Outside the Box . Springer.

ISBN 978-3-319-71303-8 .

v t e Computer science Note: This template roughly follows the 2012 ACM Computing Classification System .

Hardware Printed circuit board Peripheral Integrated circuit Very-large-scale integration System on a chip (SoC) Energy consumption (green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Cyber-physical system Fault tolerance Wireless sensor network Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control variable Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human–centered computing Interaction design Augmented reality Virtual reality Social computing Ubiquitous computing Visualization Accessibility Human–computer interaction Mobile computing Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Image compression Solid modeling Applied computing Quantum computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Category Outline Glossaries v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Systems design Requirements Functional requirement Non-functional requirement Capacity Users Compute Memory Storage Network Web traffic Interface API SOAP REST GraphQL gRPC Webhook High-level design Client Load balancing Application server Message queue Integration Vertical Peer-to-peer API gateway pub-sub Event source ETL Batch Stream Orchestration Architectures Monolithic Microservices Event-driven Client–server Serverless Circuit breaker Rate limiting Database Relational NoSQL Graph Key–value LSM tree Time series Column oriented Principles Consistency Reliability CAP theorem Maintainability Configurability Modularity Durability Scalability Stateless Asynchronous I/O Loose coupling Availability Fault tolerance Failover Single point of failure Replication Consistent hashing Circuit breaker Latency Cache CDN Shard Database index Pre-caching Storage Object storage Block storage Observability Logging Metrics Tracing Error rate Queries per second Notification system Anomaly detection Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Commons Category v t e IEEE standards Current 488 693 730 754 Revision 854 828 829 896 1003 1014 1016 1076 1149.1 1154 1164 1275 1278 1284 1355 1394 1451 1497 1516 1541 1547 1584 1588 1596 1603 1613 1619 1666 1667 1675 1685 1722 1733 1800 1801 1815 1849 1850 1855 1900 1901 1902 1904 1905 2030 2050 11073 12207 14764 16085 16326 29148 42010 802 series 802 .2 .4 .5 .6 .7 .8 .9 .10 .12 .14 .16 WiMAX · d · e .17 .18 .20 .21 .22 .24 802.1 D p Q Qav Qat Qay Qaz Qbb w X AB ad AE ag ah ak aq AS AX ( LACP ) BA 802.3 ( Ethernet ) -1983 a b d e i j u x y z ab ac ad ae af ah ak an aq at au av az ba bt bu by bz ca cb cc cd ce cg ch ck cm cn cp cq cr cs ct cu cv cw cx cy cz da db dd de df 802.11 ( Wi-Fi ) -1997 legacy mode a b c d e f g h i j k n ( Wi-Fi 4 ) p r s u v w y z aa ac ( Wi-Fi 5 ) ad ( WiGig ) ae af ah ai aj ak aq ax ( Wi-Fi 6 ) ay az ba bb bc bd be ( Wi-Fi 7 ) bf bh bi bk bn ( Wi-Fi 8 ) 802.15 .1 ( Bluetooth ) .2 .3 .4 ( Zigbee ) .4a .4b .4c .4d .4e .4f .4g .4z .5 .6 .7 Proposed P1363 P1619 P1699 P1823 P1906.1 Superseded 754-1985 830 1219 1233 1362 1364 1471 Category v t e International Organization for Standardization (ISO) standards List of ISO standards – ISO romanizations – IEC standards 1–9999 1 2 3 4 6 7 9 16 17 31 -0 -1 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 68-1 128 216 217 226 228 233 259 261 262 302 306 361 500 518 519 639 -1 -2 -3 -5 -6 646 657 668 690 704 732 764 838 843 860 898 965 999 1000 1004 1007 1073-1 1073-2 1155 1413 1538 1629 1745 1989 2014 2015 2022 2033 2047 2108 2145 2146 2240 2281 2533 2709 2711 2720 2788 2848 2852 2921 3029 3103 3166 -1 -2 -3 3297 3307 3601 3602 3864 3901 3950 3977 4031 4157 4165 4217 4909 5218 5426 5427 5428 5725 5775 5776 5800 5807 5964 6166 6344 6346 6373 6385 6425 6429 6438 6523 6709 6943 7001 7002 7010 7027 7064 7098 7185 7200 7498 -1 7637 7736 7810 7811 7812 7813 7816 7942 8000 8093 8178 8217 8373 8501-1 8571 8583 8601 8613 8632 8651 8652 8691 8805/8806 8807 8820-5 8859 -1 -2 -3 -4 -5 -6 -7 -8 -8-I -9 -10 -11 -12 -13 -14 -15 -16 8879 9000/9001 9036 9075 9126 9141 9227 9241 9293 9314 9362 9407 9496 9506 9529 9564 9592/9593 9594 9660 9797-1 9897 9899 9945 9984 9985 9995 10000–19999 10006 10007 10116 10118-3 10160 10161 10165 10179 10206 10218 10279 10303 -11 -21 -22 -28 -238 10383 10585 10589 10628 10646 10664 10746 10861 10957 10962 10967 11073 11170 11172 11179 11404 11544 11783 11784 11785 11801 11889 11898 11940 ( -2 ) 11941 11941 (TR) 11992 12006 12052 12182 12207 12234-2 12620 13211 -1 -2 13216 13250 13399 13406-2 13450 13485 13490 13567 13568 13584 13616 13816 13818 14000 14031 14224 14289 14396 14443 14496 -2 -3 -6 -10 -11 -12 -14 -17 -20 14617 14644 14649 14651 14698 14764 14882 14971 15022 15189 15288 15291 15398 15408 15444 -3 -9 15445 15438 15504 15511 15686 15693 15706 -2 15707 15897 15919 15924 15926 15926 WIP 15930 15938 16023 16262 16355-1 16485 16612-2 16750 16949 (TS) 17024 17025 17100 17203 17369 17442 17506 17799 18004 18014 18181 18245 18629 18760 18916 19005 19011 19092 -1 -2 19114 19115 19125 19136 19407 19439 19500 19501 19502 19503 19505 19506 19507 19508 19509 19510 19600 19752 19757 19770 19775-1 19794-5 19831 20000–29999 20000 20022 20121 20400 20802 20830 21000 21001 21047 21122 21500 21778 21827 22000 22275 22300 22301 22395 22537 23000 23003 23008 23009 23090-3 23092 23094-1 23094-2 23270 23271 23360 23941 24517 24613 24617 24707 24728 25178 25964 26000 26262 26300 26324 27000 series 27000 27001 27002 27005 27006 27729 28000 29110 29148 29199-2 29500 30000+ 30170 31000 32000 37001 38500 39075 40314 40500 42010 45001 50001 55000 56000 80000 Category Retrieved from " https://en.wikipedia.org/w/index.php?title=Software_maintenance&oldid=1303327031 " Categories : Software maintenance IEEE standards ISO/IEC standards Hidden categories: Articles with short description Short description is different from Wikidata Good articles Articles containing potentially dated statements from 2020 All articles containing potentially dated statements This page was last edited on 30 July 2025, at 09:33 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Software maintenance 29 languages Add topic

