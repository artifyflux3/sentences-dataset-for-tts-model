Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Programming languages 2 Denotational semantics 3 See also 4 References Toggle the table of contents Function type 2 languages Русский Українська Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia In computer science and mathematical logic , a function type (or arrow type or exponential ) is the type of a variable or parameter to which a function has or can be assigned, or an argument or result type of a higher-order function taking or returning a function.

A function type depends on the type of the parameters and the result type of the function (it, or more accurately the unapplied type constructor · → · , is a higher-kinded type ). In theoretical settings and programming languages where functions are defined in curried form , such as the simply typed lambda calculus , a function type depends on exactly two types, the domain A and the range B . Here a function type is often denoted A → B , following mathematical convention, or B A , based on there existing exactly B A (exponentially many) set-theoretic functions mappings A to B in the category of sets . The class of such maps or functions is called the exponential object . The act of currying makes the function type adjoint to the product type ; this is explored in detail in the article on currying.

The function type can be considered to be a special case of the dependent product type , which among other properties, encompasses the idea of a polymorphic function .

Programming languages [ edit ] The syntax used for function types in several programming languages can be summarized, including an example type signature for the higher-order function composition function: Language Notation Example type signature With first-class functions , parametric polymorphism C# Func< α 1 , α 2 ,..., α n , ρ > Func < A , C > compose ( Func < B , C > f , Func < A , B > g ); Haskell α -> ρ compose :: ( b -> c ) -> ( a -> b ) -> a -> c OCaml α -> ρ compose : ( ' b -> ' c ) -> ( ' a -> ' b ) -> ' a -> ' c Scala ( α 1 , α 2 ,..., α n ) => ρ def compose [ A , B , C ]( f : B => C , g : A => B ): A => C Standard ML α -> ρ compose : ( 'b -> 'c ) -> ( 'a -> 'b ) -> 'a -> 'c Swift α -> ρ func compose < A , B , C >( f : ( B ) -> C , g : ( A ) -> B ) -> ( A ) -> C Rust fn( α 1 , α 2 ,..., α n ) -> ρ fn compose < A , B , C > ( f : fn ( A ) -> B , g : fn ( B ) -> C ) -> fn ( A ) -> C With first-class functions , without parametric polymorphism Go func( α 1 , α 2 ,..., α n ) ρ var compose func ( func ( int ) int , func ( int ) int ) func ( int ) int C++ , Objective-C , with blocks ρ (^)( α 1 , α 2 ,..., α n ) int ( ^ compose ( int ( ^ f )( int ), int ( ^ g )( int )))( int ); Without first-class functions , parametric polymorphism C ρ (*)( α 1 , α 2 ,..., α n ) int ( * compose ( int ( * f )( int ), int ( * g )( int )))( int ); C++11 Not unique.

std::function< ρ ( α 1 , α 2 ,..., α n )> is the more general type (see below).

function < function < int ( int ) > ( function < int ( int ) > , function < int ( int ) > ) > compose ; When looking at the example type signature of, for example C#, the type of the function compose is actually Func<Func<A,B>,Func<B,C>,Func<A,C>> .

Due to type erasure in C++11's std::function , it is more common to use templates for higher order function parameters and type inference ( auto ) for closures .

Denotational semantics [ edit ] The function type in programming languages does not correspond to the space of all set-theoretic functions. Given the countably infinite type of natural numbers as the domain and the booleans as range, then there are an uncountably infinite number (2 ℵ 0 = c ) of set-theoretic functions between them. Clearly this space of functions is larger than the number of functions that can be defined in any programming language, as there exist only countably many programs (a program being a finite sequence of a finite number of symbols) and one of the set-theoretic functions effectively solves the halting problem .

Denotational semantics concerns itself with finding more appropriate models (called domains ) to model programming language concepts such as function types. It turns out that restricting expression to the set of computable functions is not sufficient either if the programming language allows writing non-terminating computations (which is the case if the programming language is Turing complete ). Expression must be restricted to the so-called continuous functions (corresponding to continuity in the Scott topology , not continuity in the real analytical sense). Even then, the set of continuous function contains the parallel-or function, which cannot be correctly defined in all programming languages.

See also [ edit ] Cartesian closed category Currying Exponential object , category-theoretic equivalent First-class function Function space , set-theoretic equivalent References [ edit ] Pierce, Benjamin C.

(2002).

Types and Programming Languages . The MIT Press. pp.

99 –100.

ISBN 9780262162098 .

Mitchell, John C.

Foundations for Programming Languages . The MIT Press.

function type at the n Lab Homotopy Type Theory: Univalent Foundations of Mathematics , The Univalent Foundations Program, Institute for Advanced Study .

See section 1.2 .

v t e Data types Uninterpreted Bit Byte Trit Tryte Word Bit array Numeric Arbitrary-precision or bignum Complex Decimal Fixed point Block floating point Floating point Reduced precision Minifloat Half precision bfloat16 Single precision Double precision Quadruple precision Octuple precision Extended precision Long double Integer signedness Interval Rational Pointer Address physical virtual Reference Text Character String null-terminated Composite Algebraic data type generalized Array Associative array Class Dependent Equality Inductive Intersection List Object metaobject Option type Product Record or Struct Refinement Set Union tagged Other Boolean Bottom type Collection Enumerated type Exception Function type Opaque data type Recursive data type Semaphore Stream Strongly typed identifier Top type Type class Empty type Unit type Void Related topics Abstract data type Boxing Data structure Generic Kind metaclass Parametric polymorphism Primitive data type Interface Subtyping Type constructor Type conversion Type system Type theory Variable Retrieved from " https://en.wikipedia.org/w/index.php?title=Function_type&oldid=1136509009 " Categories : Data types Subroutines Type theory This page was last edited on 30 January 2023, at 17:52 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Function type 2 languages Add topic

