Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Python example 2 In Smalltalk-80 3 In Ruby 4 In Objective-C 5 Support in languages and tools 6 See also 7 References 8 External links Toggle the table of contents Metaclass 12 languages العربية Deutsch Español Français 한국어 Italiano 日本語 Português Русский Tiếng Việt 粵語 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia A metaclass describes commen behaviour for classes, like a class does for objects This article has multiple issues.

Please help improve it or discuss these issues on the talk page .

( Learn how and when to remove these messages ) This article possibly contains original research .

Please improve it by verifying the claims made and adding inline citations . Statements consisting only of original research should be removed.

( September 2013 ) ( Learn how and when to remove this message ) This article needs additional citations for verification .

Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed.

Find sources: "Metaclass" – news · newspapers · books · scholar · JSTOR ( September 2013 ) ( Learn how and when to remove this message ) ( Learn how and when to remove this message ) In object-oriented programming , a metaclass is a class whose instances are classes themselves. Unlike ordinary classes, which define the behaviors of objects, metaclasses specify the behaviors of classes and their instances. Not all object-oriented programming languages support the concept of metaclasses. For those that do, the extent of control metaclasses have over class behaviors varies. Metaclasses are often implemented by treating classes as first-class citizens , making a metaclass an object that creates and manages these classes. Each programming language adheres to its own metaobject protocol , which are the rules that determine interactions among objects, classes, and metaclasses.

[ 1 ] Metaclasses are utilized to automate code generation and to enhance framework development.

[ 2 ] Python example [ edit ] In Python , the builtin class type is a metaclass.

[ 3 ] [ 4 ] [ 5 ] Consider this simple Python class: class Car : def __init__ ( self , make : str , model : str , year : int , color : str ): self .

make = make self .

model = model self .

year = year self .

color = color @property def description ( self ) -> str : """Return a description of this car.""" return f " { self .

color } { self .

make } { self .

model } " At run time, Car itself is an instance of type . The source code of the Car class, shown above, does not include such details as the size in bytes of Car objects, their binary layout in memory, how they are allocated, that the __init__ method is automatically called each time a Car is created, and so on. These details come into play not only when a new Car object is created, but also each time any attribute of a Car is accessed. In languages without metaclasses, these details are defined by the language specification and can't be overridden. In Python, the metaclass - type - controls these details of Car 's behavior. They can be overridden by using a different metaclass instead of type .

The above example contains some redundant code to do with the four attributes make , model , year , and color . It is possible to eliminate some of this redundancy using a custom metaclass. In Python, a metaclass is most easily defined as a subclass of type .

class AttributeInitType ( type ): def __call__ ( self , * args , ** kwargs ): """Create a new instance.""" # First, create the object in the normal default way.

obj = type .

__call__ ( self , * args ) # Additionally, set attributes on the new object.

for name , value in kwargs .

items (): setattr ( obj , name , value ) # Return the new object.

return obj This metaclass only overrides object creation.  All other aspects of class and object behavior are still handled by type .

Now the class Car can be rewritten to use this metaclass. In Python 3 this is done by providing a "keyword argument" metaclass to the class definition: class Car ( object , metaclass = AttributeInitType ): @property def description ( self ) -> str : """Return a description of this car.""" return " " .

join ( str ( value ) for value in self .

__dict__ .

values ()) The resulting object Car can be instantiated as usual, but can contain any number of keyword arguments: new_car = Car ( make = 'Toyota' , model = 'Prius' , year = 2005 , color = 'Green' , engine = 'Hybrid' ) In Smalltalk-80 [ edit ] This section does not cite any sources .

Please help improve this section by adding citations to reliable sources . Unsourced material may be challenged and removed .

( October 2013 ) ( Learn how and when to remove this message ) The Smalltalk-80 metaclass hierarchy as a UML diagram Diagram of the inheritance and instance relationships between classes and metaclasses in Smalltalk In Smalltalk , everything is an object . Additionally, Smalltalk is a class based system, which means that every object has a class that defines the structure of that object (i.e. the instance variables the object has) and the messages an object understands. Together this implies that a class in Smalltalk is an object and that, therefore a class needs to be an instance of a class (called metaclass).

As an example, a car object c is an instance of the class Car . In turn, the class Car is again an object and as such an instance of the metaclass of Car called Car class . Note the blank in the name of the metaclass. The name of the metaclass is the Smalltalk expression that, when evaluated, results in the metaclass object. Thus evaluating Car class results in the metaclass object for Car whose name is Car class (one can confirm this by evaluating Car class name which returns the name of the metaclass of Car .) Class methods actually belong to the metaclass, just as instance methods actually belong to the class. When a message is sent to the object 2 , the search for the method starts in Integer . If it is not found it proceeds up the superclass chain, stopping at Object whether it is found or not.

When a message is sent to Integer the search for the method starts in Integer class and proceeds up the superclass chain to Object class . Note that, so far, the metaclass inheritance chain exactly follows that of the class inheritance chain. But the metaclass chain extends further because Object class is the subclass of Class . All metaclasses are subclasses of Class.

In early Smalltalks, there was only one metaclass called Class . This implied that the methods all classes have were the same, in particular the method to create new objects, i.e., new . To allow classes to have their own methods and their own instance variables (called class instance variables and should not be confused with class variables ), Smalltalk-80 introduced for each class C their own metaclass C class . This means that each metaclass is effectively a singleton class.

Since there is no requirement that metaclasses behave differently from each other, all metaclasses are instances of only one class called Metaclass . The metaclass of Metaclass is called Metaclass class which again is an instance of class Metaclass .

In Smalltalk-80, every class (except Object ) has a superclass . The abstract superclass of all metaclasses is Class , which describes the general nature of classes.

The superclass hierarchy for metaclasses parallels that for classes, except for class Object . ALL metaclasses are subclasses of Class , therefore: Object class superclass == Class.

Like conjoined twins , classes and metaclasses are born together.

Metaclass has an instance variable thisClass , which points to its conjoined class.
Note that the usual Smalltalk class browser does not show metaclasses as separate classes. Instead the class browser allows to edit the class together with its metaclass at the same time.

The names of classes in the metaclass hierarchy are easily confused with the concepts of the same name. For instance: Object is the base class that provides common methods for all objects; "an object" is an integer, or a widget, or a Car , etc.

Class is the base of the metaclasses that provides common methods for all classes (though it is not a metaclass itself); "a class" is something like Integer , or Widget , or Car , etc.

Metaclass provides common methods for all metaclasses.

Four classes provide the facilities to describe new classes. Their inheritance hierarchy (from Object), and the main facilities they provide are: Object - default behavior common to all objects, like class access Behavior - minimum state for compiling methods and creating/running objects ClassDescription ( abstract class ) - class/variable naming, comments Class - similar, more comprehensive, facilities to superclasses Metaclass - initializing class variables, instance creation messages In Ruby [ edit ] Ruby purifies the Smalltalk-80 concept of metaclasses by introducing eigenclasses ,
removing the Metaclass class,
and (un)redefining the class-of map.
The change can be schematized as follows: [ 6 ] Smalltalk-80 Classes Implicit metaclasses Terminal objects → Ruby Classes Eigenclasses of classes Eigenclasses of eigenclasses Terminal objects Eigenclasses of terminal objects Note in particular the correspondence between Smalltalk's implicit metaclasses and Ruby's eigenclasses of classes.
The Ruby eigenclass model makes the concept of implicit metaclasses fully uniform: every object x has its own meta-object, called the eigenclass of x , which is one meta-level higher than x . The "higher order" eigenclasses usually exist purely conceptually – they do not contain any methods or store any (other) data in most Ruby programs.

[ 7 ] The following diagrams show a sample core structure of Smalltalk-80 and Ruby in comparison.

[ 8 ] In both languages, the structure consists of a built-in part which contains the circular objects (i.e. objects that appear in a cycle formed by a combination of blue or green links) and a user-part which has four explicit objects: classes A and B and terminal objects u and v .
Green links show the child→parent relation of inheritance (with the implicit upward direction), blue links show the complementary member→container relation of instantiation (a blue link from x points to the least actual container of x that is the start point for the method lookup when a method is invoked on x ). Gray nodes display the eigenclasses (resp. implicit metaclasses in the case of Smalltalk-80).

Smalltalk-80 Ruby The diagram on the right also provides a picture of lazy evaluation of eigenclasses in Ruby. The v object can have its eigenclass evaluated (allocated) as a consequence of adding singleton methods to v .

According to the Ruby's introspection method named class ,
the class of every class (and of every eigenclass) is
constantly the Class class (denoted by c in the diagram).

Class , and Struct are the only classes that have classes as instances.

[ 9 ] [ disputed – discuss ] Subclassing of Class is disallowed.
Following the standard definition of metaclasses we can conclude that Class and Struct are the only metaclasses in Ruby.
This seems to contradict the correspondence between Ruby and Smalltalk,
since in Smalltalk-80, every class has its own metaclass.
The discrepancy is based on the disagreement between
the class introspection method in Ruby and Smalltalk. While the map x ↦ x.

class coincides on terminal objects, it differs in the restriction to classes. As already mentioned above, for a class x , the Ruby expression x .class evaluates constantly to Class . In Smalltalk-80, if x is a class then the expression x class corresponds
to the Ruby's x .singleton_class – which evaluates to the eigenclass of x .

In Objective-C [ edit ] This section needs additional citations for verification .

Please help improve this article by adding citations to reliable sources in this section. Unsourced material may be challenged and removed.

( October 2013 ) ( Learn how and when to remove this message ) This section's tone or style may not reflect the encyclopedic tone used on Wikipedia .

See Wikipedia's guide to writing better articles for suggestions.

( September 2013 ) ( Learn how and when to remove this message ) Diagram of the inheritance and instance relationships between classes and metaclasses in Objective-C. Note that Objective-C has multiple root classes; each root class would have a separate hierarchy. This diagram only shows the hierarchy for an example root class NSObject. Each other root class would have a similar hierarchy.

Metaclasses in Objective-C are almost the same as those in Smalltalk-80—not surprising since Objective-C borrows a lot from Smalltalk. Like Smalltalk, in Objective-C, the instance variables and methods are defined by an object's class. A class is an object, hence it is an instance of a metaclass.

Like Smalltalk, in Objective-C, class methods are simply methods called on the class object, hence a class's class methods must be defined as instance methods in its metaclass. Because different classes can have different sets of class methods, each class must have its own separate metaclass. Classes and metaclasses are always created as a pair: the runtime has functions objc_allocateClassPair() and objc_registerClassPair() to create and register class-metaclass pairs, respectively.

There are no names for the metaclasses; however, a pointer to any class object can be referred to with the generic type Class (similar to the type id being used for a pointer to any object).

Because class methods are inherited through inheritance, like Smalltalk, metaclasses must follow an inheritance scheme paralleling that of classes (e.g. if class A's parent class is class B, then A's metaclass's parent class is B's metaclass), except that of the root class.

Unlike Smalltalk, the metaclass of the root class inherits from the root class (usually NSObject using the Cocoa framework) itself. This ensures that all class objects are ultimately instances of the root class, so that you can use the instance methods of the root class, usually useful utility methods for objects, on class objects themselves.

Since metaclass objects do not behave differently (you cannot add class methods for a metaclass, so metaclass objects all have the same methods), they are all instances of the same class—the metaclass of the root class (unlike Smalltalk). Thus, the metaclass of the root class is an instance of itself. The reason for this is that all metaclasses inherit from root class; hence, they must inherit the class methods of the root class.

[ 10 ] Support in languages and tools [ edit ] The following are some of the most prominent programming languages that support metaclasses.

Common Lisp , via CLOS Delphi and other versions of Object Pascal influenced by it Groovy Objective-C ooRexx Python Perl , via the metaclass pragma, as well as Moose Ruby Smalltalk C++ (proposed for a possible inclusion in future version of the standard) [ 11 ] Some less widespread languages that support metaclasses include OpenJava , OpenC++ , OpenAda , CorbaScript , ObjVLisp , Object-Z , MODEL-K , XOTcl , and MELDC . Several of these languages date from the early 1990s and are of academic interest.

[ 12 ] Logtalk , an object-oriented extension of Prolog , also supports metaclasses.

Resource Description Framework (RDF) and Unified Modeling Language (UML) both support metaclasses.

See also [ edit ] Metamodel Metaprogramming Metaobject Kind (type theory) Reflection Dynamism Adapter pattern Metaclass (Semantic Web) References [ edit ] ^ Ira R. Forman and Scott Danforth (1999).

Putting Metaclasses to Work . Addison-Wesley.

ISBN 0-201-43305-2 .

^ AloorRavi, Sulekha (2022).

Metaprogramming with Python . Birmingham: Packt Publishing.

^ IBM Metaclass programming in Python, parts 1 Archived 2008-09-03 at the Wayback Machine , 2 and 3 ^ Artima Forum: Metaclasses in Python 3.0 (part 1 of 2) (part 2 of 2) ^ David Mertz.

"A Primer on Python Metaclass Programming" .

ONLamp . Archived from the original on April 30, 2003 . Retrieved June 28, 2006 .

^ "The Ruby Object Model: Comparison with Smalltalk-80" .

^ Paolo Perrotta (2010).

Metaprogramming Ruby . Pragmatic Bookshelf.

ISBN 978-1-934356-47-0 .

^ "Object Membership: The Core Structure of Object Technology" .

^ "Struct" .

^ Cocoa with Love: What is a meta-class in Objective-C?

^ Herb Sutter .

"Metaclasses" (PDF) .

^ "An implementation of mixins in Java using metaclasses" (PDF) . Archived from the original (PDF) on 2007-10-16 . Retrieved 2007-11-27 .

External links [ edit ] What Is a Metaclass?

v t e Data types Uninterpreted Bit Byte Trit Tryte Word Bit array Numeric Arbitrary-precision or bignum Complex Decimal Fixed point Block floating point Floating point Reduced precision Minifloat Half precision bfloat16 Single precision Double precision Quadruple precision Octuple precision Extended precision Long double Integer signedness Interval Rational Pointer Address physical virtual Reference Text Character String null-terminated Composite Algebraic data type generalized Array Associative array Class Dependent Equality Inductive Intersection List Object metaobject Option type Product Record or Struct Refinement Set Union tagged Other Boolean Bottom type Collection Enumerated type Exception Function type Opaque data type Recursive data type Semaphore Stream Strongly typed identifier Top type Type class Empty type Unit type Void Related topics Abstract data type Boxing Data structure Generic Kind metaclass Parametric polymorphism Primitive data type Interface Subtyping Type constructor Type conversion Type system Type theory Variable v t e Meta- Domains and methods Meta-analysis Metabibliography Metaclass Semantic Web Metacognition Meta-learning Metamemory Meta-communication Metacomputing Metadata Metadesign Metadiscourse Meta-emotion Metamood Metafiction Metagaming Metagenomics Metaheuristic Metahistory Metahumor Metaknowledge Metalanguage Metapragmatics Metasemantics Metalinguistics Metamaterials Metamathematics Metamedia Metamodeling Metamodernism Metamotivation Metanarrative Metaobject Meta-optimization Meta-organization Metaphenomics Metaphilosophy Metaepistemology Metaethics Metalogic Meta-ontology Metaphysics Metametaphysics Metapolitics Metapopulation Metaprogramming Metapsychiatry Metapsychology Metapuzzle Meta-reference Meta-regulation Metascience Metasociology Meta-system Metatheorem Metatheory Metaverse NewPP limit report
Parsed by mw‐web.codfw.main‐6cc77c66b8‐v5dst
Cached time: 20250812014125
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.415 seconds
Real time usage: 0.500 seconds
Preprocessor visited node count: 1622/1000000
Revision size: 21099/2097152 bytes
Post‐expand include size: 84908/2097152 bytes
Template argument size: 10285/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 10/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 65807/5000000 bytes
Lua time usage: 0.250/10.000 seconds
Lua memory usage: 6888657/52428800 bytes
Number of Wikibase entities loaded: 0/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  418.513      1 -total
 33.26%  139.196      1 Template:Reflist
 20.65%   86.410      3 Template:Cite_book
 20.27%   84.850      2 Template:Navbox
 20.08%   84.055      1 Template:Data_types
 18.19%   76.126      1 Template:Multiple_issues
 13.94%   58.322      1 Template:Short_description
 13.16%   55.096      5 Template:Ambox
  8.84%   37.001      1 Template:Original_research
  8.49%   35.547      2 Template:Pagetype Saved in parser cache with key enwiki:pcache:558359:|#|:idhash:canonical and timestamp 20250812014125 and revision id 1287766734. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Metaclass&oldid=1287766734 " Category : Class (computer programming) Hidden categories: Webarchive template wayback links Articles with short description Short description is different from Wikidata Articles that may contain original research from September 2013 All articles that may contain original research Articles needing additional references from September 2013 All articles needing additional references Articles with multiple maintenance issues Articles needing additional references from October 2013 All accuracy disputes Articles with disputed statements from May 2015 Wikipedia articles with style issues from September 2013 All articles with style issues Articles with example Python (programming language) code This page was last edited on 28 April 2025, at 09:53 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Metaclass 12 languages Add topic

