Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Description 2 Convergence 3 Cost Toggle Cost subsection 3.1 Caching row maximums 3.2 Cyclic and parallel Jacobi 4 Algorithm Toggle Algorithm subsection 4.1 Notes 4.2 Example 5 Applications for real symmetric matrices 6 Julia implementation 7 Generalizations 8 References 9 Further reading 10 External links Toggle the table of contents Jacobi eigenvalue algorithm 9 languages Deutsch Italiano עברית Nederlands 日本語 Олык марий Português Русский Українська Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Numerical linear algebra algorithm In numerical linear algebra , the Jacobi eigenvalue algorithm is an iterative method for the calculation of the eigenvalues and eigenvectors of a real symmetric matrix (a process known as diagonalization ). It is named after Carl Gustav Jacob Jacobi , who first proposed the method in 1846, [ 1 ] but it only became widely used in the 1950s with the advent of computers.

[ 2 ] This algorithm is inherently a dense matrix algorithm: it draws little or no advantage from being applied to a sparse matrix, and it will destroy sparseness by creating fill-in. Similarly, it will not preserve structures such as being banded of the matrix on which it operates.

Description [ edit ] Let S {\displaystyle S} be a symmetric matrix, and G = G ( i , j , θ θ ) {\displaystyle G=G(i,j,\theta )} be a Givens rotation matrix . Then: S ′ = G ⊤ ⊤ S G {\displaystyle S'=G^{\top }SG\,} is symmetric and similar to S {\displaystyle S} .

Furthermore, S ′ ′ {\displaystyle S^{\prime }} has entries: S i i ′ = c 2 S i i − − 2 s c S i j + s 2 S j j S j j ′ = s 2 S i i + 2 s c S i j + c 2 S j j S i j ′ = S j i ′ = ( c 2 − − s 2 ) S i j + s c ( S i i − − S j j ) S i k ′ = S k i ′ = c S i k − − s S j k k ≠ ≠ i , j S j k ′ = S k j ′ = s S i k + c S j k k ≠ ≠ i , j S k l ′ = S k l k , l ≠ ≠ i , j {\displaystyle {\begin{aligned}S'_{ii}&=c^{2}\,S_{ii}-2\,sc\,S_{ij}+s^{2}\,S_{jj}\\S'_{jj}&=s^{2}\,S_{ii}+2sc\,S_{ij}+c^{2}\,S_{jj}\\S'_{ij}&=S'_{ji}=(c^{2}-s^{2})\,S_{ij}+sc\,(S_{ii}-S_{jj})\\S'_{ik}&=S'_{ki}=c\,S_{ik}-s\,S_{jk}&k\neq i,j\\S'_{jk}&=S'_{kj}=s\,S_{ik}+c\,S_{jk}&k\neq i,j\\S'_{kl}&=S_{kl}&k,l\neq i,j\end{aligned}}} where s = sin ⁡ ⁡ ( θ θ ) {\displaystyle s=\sin(\theta )} and c = cos ⁡ ⁡ ( θ θ ) {\displaystyle c=\cos(\theta )} .

Since G {\displaystyle G} is orthogonal, S {\displaystyle S} and S ′ ′ {\displaystyle S^{\prime }} have the same Frobenius norm | | ⋅ ⋅ | | F {\displaystyle ||\cdot ||_{F}} (the square-root sum of squares of all components), however we can choose θ θ {\displaystyle \theta } such that S i j ′ ′ = 0 {\displaystyle S_{ij}^{\prime }=0} , in which case S ′ ′ {\displaystyle S^{\prime }} has a larger sum of squares on the diagonal: S i j ′ = cos ⁡ ⁡ ( 2 θ θ ) S i j + 1 2 sin ⁡ ⁡ ( 2 θ θ ) ( S i i − − S j j ) {\displaystyle S'_{ij}=\cos(2\theta )S_{ij}+{\tfrac {1}{2}}\sin(2\theta )(S_{ii}-S_{jj})} Set this equal to 0, and rearrange: tan ⁡ ⁡ ( 2 θ θ ) = 2 S i j S j j − − S i i {\displaystyle \tan(2\theta )={\frac {2S_{ij}}{S_{jj}-S_{ii}}}} if S j j = S i i {\displaystyle S_{jj}=S_{ii}} θ θ = π π 4 {\displaystyle \theta ={\frac {\pi }{4}}} In order to optimize this effect, S ij should be the off-diagonal element with the largest absolute value, called the pivot .

The Jacobi eigenvalue method repeatedly performs rotations until the matrix becomes almost diagonal. Then the elements in the diagonal are approximations of the (real) eigenvalues of S .

Convergence [ edit ] If p = S k l {\displaystyle p=S_{kl}} is a pivot element , then by definition | S i j | ≤ ≤ | p | {\displaystyle |S_{ij}|\leq |p|} for 1 ≤ ≤ i , j ≤ ≤ n , i ≠ ≠ j {\displaystyle 1\leq i,j\leq n,i\neq j} . Let Γ Γ ( S ) 2 {\displaystyle \Gamma (S)^{2}} denote the sum of squares of all off-diagonal entries of S {\displaystyle S} . Since S {\displaystyle S} has exactly 2 N := n ( n − − 1 ) {\displaystyle 2N:=n(n-1)} off-diagonal elements, we have p 2 ≤ ≤ Γ Γ ( S ) 2 ≤ ≤ 2 N p 2 {\displaystyle p^{2}\leq \Gamma (S)^{2}\leq 2Np^{2}} or 2 p 2 ≥ ≥ Γ Γ ( S ) 2 / N {\displaystyle 2p^{2}\geq \Gamma (S)^{2}/N} . Now Γ Γ ( S J ) 2 = Γ Γ ( S ) 2 − − 2 p 2 {\displaystyle \Gamma (S^{J})^{2}=\Gamma (S)^{2}-2p^{2}} . This implies Γ Γ ( S J ) 2 ≤ ≤ ( 1 − − 1 / N ) Γ Γ ( S ) 2 {\displaystyle \Gamma (S^{J})^{2}\leq (1-1/N)\Gamma (S)^{2}} or Γ Γ ( S J ) ≤ ≤ ( 1 − − 1 / N ) 1 / 2 Γ Γ ( S ) {\displaystyle \Gamma (S^{J})\leq (1-1/N)^{1/2}\Gamma (S)} ;
that is, the sequence of Jacobi rotations converges at least linearly by a factor ( 1 − − 1 / N ) 1 / 2 {\displaystyle (1-1/N)^{1/2}} to a diagonal matrix .

A number of N {\displaystyle N} Jacobi rotations is called a sweep; let S σ σ {\displaystyle S^{\sigma }} denote the result. The previous estimate yields Γ Γ ( S σ σ ) ≤ ≤ ( 1 − − 1 N ) N / 2 Γ Γ ( S ) {\displaystyle \Gamma (S^{\sigma })\leq \left(1-{\frac {1}{N}}\right)^{N/2}\Gamma (S)} ; that is, the sequence of sweeps converges at least linearly with a factor  ≈ e 1 / 2 {\displaystyle e^{1/2}} .

However the following result of Schönhage [ 3 ] yields locally quadratic convergence. To this end let S have m distinct eigenvalues λ λ 1 , .

.

.

, λ λ m {\displaystyle \lambda _{1},...,\lambda _{m}} with multiplicities ν ν 1 , .

.

.

, ν ν m {\displaystyle \nu _{1},...,\nu _{m}} and let d > 0 be the smallest distance of two different eigenvalues. Let us call a number of N S := n ( n − − 1 ) 2 − − ∑ ∑ μ μ = 1 m 1 2 ν ν μ μ ( ν ν μ μ − − 1 ) ≤ ≤ N {\displaystyle N_{S}:={\frac {n(n-1)}{2}}-\sum _{\mu =1}^{m}{\frac {1}{2}}\nu _{\mu }(\nu _{\mu }-1)\leq N} Jacobi rotations a Schönhage-sweep. If S s {\displaystyle S^{s}} denotes the result then Γ Γ ( S s ) ≤ ≤ n 2 − − 1 ( γ γ 2 d − − 2 γ γ ) , γ γ := Γ Γ ( S ) {\displaystyle \Gamma (S^{s})\leq {\sqrt {{\frac {n}{2}}-1}}\left({\frac {\gamma ^{2}}{d-2\gamma }}\right),\quad \gamma :=\Gamma (S)} .

Thus convergence becomes quadratic as soon as Γ Γ ( S ) < d 2 + n 2 − − 1 {\displaystyle \Gamma (S)<{\frac {d}{2+{\sqrt {{\frac {n}{2}}-1}}}}} Cost [ edit ] Each Givens rotation can be done in O ( n ) {\displaystyle O(n)} steps when the pivot element p is known. However the search for p requires inspection of all N ≈ ⁠ 1 / 2 ⁠ n 2 off-diagonal elements, which means this search dominates the overall complexity and pushes the computational complexity of a sweep in the classical Jacobi algorithm to O ( n 4 ) {\displaystyle O(n^{4})} . Competing algorithms attain O ( n 3 ) {\displaystyle O(n^{3})} complexity for a full diagonalisation.

Caching row maximums [ edit ] We can reduce the complexity of finding the pivot element from O( N ) to O( n ) if we introduce an additional index array m 1 , … … , m n − − 1 {\displaystyle m_{1},\,\dots \,,\,m_{n-1}} with the property that m i {\displaystyle m_{i}} is the index of the largest element in row i , ( i = 1, ..., n − 1) of the current S . Then the indices of the pivot ( k , l )  must be one of the pairs ( i , m i ) {\displaystyle (i,m_{i})} . Also the updating of the index array can be done in O( n ) average-case complexity: First, the maximum entry in the updated rows k and l can be found in O( n ) steps. In the other rows i , only the entries in columns k and l change. Looping over these rows, if m i {\displaystyle m_{i}} is neither k nor l , it suffices to compare the old maximum at m i {\displaystyle m_{i}} to the new entries and update m i {\displaystyle m_{i}} if necessary. If m i {\displaystyle m_{i}} should be equal to k or l and the corresponding entry decreased during the update, the maximum over row i has to be found from scratch in O( n ) complexity. However, this will happen on average only once per rotation. Thus, each rotation has  O( n ) and one sweep O( n 3 ) average-case complexity, which is equivalent to one matrix multiplication. Additionally the m i {\displaystyle m_{i}} must be initialized before the process starts, which can be done in n 2 steps.

Typically the Jacobi method converges within numerical precision after a small number of sweeps. Note that multiple eigenvalues reduce the number of iterations since N S < N {\displaystyle N_{S}<N} .

Cyclic and parallel Jacobi [ edit ] An alternative approach is to forego the search entirely, and simply have each sweep pivot every off-diagonal element once, in some predetermined order. It has been shown that this cyclic Jacobi attains quadratic convergence, [ 4 ] [ 5 ] just like the classical Jacobi.

The opportunity for parallelisation that is particular to Jacobi is based on combining cyclic Jacobi with the observation that Givens rotations for disjoint sets of indices commute, so that several can be applied in parallel. Concretely, if G 1 {\displaystyle G_{1}} pivots between indices i 1 , j 1 {\displaystyle i_{1},j_{1}} and G 2 {\displaystyle G_{2}} pivots between indices i 2 , j 2 {\displaystyle i_{2},j_{2}} , then from { i 1 , j 1 } ∩ ∩ { i 2 , j 2 } = ∅ ∅ {\displaystyle \{i_{1},j_{1}\}\cap \{i_{2},j_{2}\}=\varnothing } follows G 1 G 2 = G 2 G 1 {\displaystyle G_{1}G_{2}=G_{2}G_{1}} because in computing G 1 G 2 A {\displaystyle G_{1}G_{2}A} or G 2 G 1 A {\displaystyle G_{2}G_{1}A} the G 1 {\displaystyle G_{1}} rotation only needs to access rows i 1 , j 1 {\displaystyle i_{1},j_{1}} and the G 2 {\displaystyle G_{2}} rotation only needs to access rows i 2 , j 2 {\displaystyle i_{2},j_{2}} . Two processors can perform both rotations in parallel, because no matrix element is accessed for both.

Partitioning the set of index pairs of a sweep into classes that are pairwise disjoint is equivalent to partitioning the edge set of a complete graph into matchings , which is the same thing as edge colouring it; each colour class then becomes a round within the sweep. The minimal number of rounds is the chromatic index of the complete graph, and equals n {\displaystyle n} for odd n {\displaystyle n} but n − − 1 {\displaystyle n-1} for even n {\displaystyle n} . A simple rule for odd n {\displaystyle n} is to handle the pairs { i 1 , j 1 } {\displaystyle \{i_{1},j_{1}\}} and { i 2 , j 2 } {\displaystyle \{i_{2},j_{2}\}} in the same round if i 1 + j 1 ≡ ≡ i 2 + j 2 ( mod n ) {\displaystyle i_{1}+j_{1}\equiv i_{2}+j_{2}\textstyle {\pmod {n}}} . For even n {\displaystyle n} one may create n − − 1 {\displaystyle n-1} rounds k = 0 , 1 , … … , n − − 2 {\displaystyle k=0,1,\dotsc ,n-2} where a pair { i , j } {\displaystyle \{i,j\}} for 1 ⩽ ⩽ i < j ⩽ ⩽ n − − 1 {\displaystyle 1\leqslant i<j\leqslant n-1} goes into round ( i + j ) mod ( n − − 1 ) {\displaystyle (i+j){\bmod {(}}n-1)} and additionally a pair { i , n } {\displaystyle \{i,n\}} for 1 ⩽ ⩽ i ⩽ ⩽ n − − 1 {\displaystyle 1\leqslant i\leqslant n-1} goes into round 2 i mod ( n − − 1 ) {\displaystyle 2i{\bmod {(}}n-1)} . This brings the time complexity of a sweep down from O ( n 3 ) {\displaystyle O(n^{3})} to O ( n 2 ) {\displaystyle O(n^{2})} , if n / 2 {\displaystyle n/2} processors are available.

A round would consist of each processor first calculating ( c , s ) {\displaystyle (c,s)} for its rotation, and then applying the  rotation from the left (rotating between rows). Next, the processors synchronise before applying the transpose rotation from the right (rotating between columns), and finally synchronising again. A matrix element may be accessed by two processors during a round, but not by both during the same half of this round.

Further parallelisation is possible by dividing the work for a single rotation between several processors, but that might be getting too fine-grained to be practical.

Algorithm [ edit ] The following algorithm is a description of the Jacobi method in math-like notation.
It calculates a vector e which contains the eigenvalues and a matrix E which contains the corresponding eigenvectors; that is, e i {\displaystyle e_{i}} is an eigenvalue and the column E i {\displaystyle E_{i}} an orthonormal eigenvector for e i {\displaystyle e_{i}} , i = 1, ..., n .

procedure jacobi( S ∈ R n × n ; out e ∈ R n ; out E ∈ R n × n ) var i , k , l , m , state ∈ N s , c , t , p , y , d , r ∈ R ind ∈ N n changed ∈ L n function maxind( k ∈ N ) ∈ N !

index of largest off-diagonal element in row k m := k +1 for i := k +2 to n do if │ S ki │ > │ S km │ then m := i endif endfor return m endfunc procedure update( k ∈ N ; t ∈ R ) !

update e k and its status y := e k ; e k := y + t if changed k and ( y = e k ) then changed k := false; state := state −1 elsif (not changed k ) and ( y ≠ e k ) then changed k := true; state := state +1 endif endproc procedure rotate( k , l , i , j ∈ N ) !

perform rotation of S ij , S kl ┌ ┐    ┌     ┐┌ ┐
    │ S kl │    │ c − s ││ S kl │
    │ │ := │     ││ │
    │ S ij │    │ s c ││ S ij │
    └ ┘    └     ┘└ ┘ endproc !

init e, E, and arrays ind, changed E := I ; state := n for k := 1 to n do ind k := maxind( k ); e k := S kk ; changed k := true endfor while state ≠0 do !

next rotation m := 1 !

find index (k,l) of pivot p for k := 2 to n −1 do if │ S k ind k │ > │ S m ind m │ then m := k endif endfor k := m ; l := ind m ; p := S kl !

calculate c = cos φ, s = sin φ y := ( e l − e k )/2; d := │ y │+√( p 2 + y 2 ) r := √( p 2 + d 2 ); c := d / r ; s := p / r ; t := p 2 / d if y <0 then s := − s ; t := − t endif S kl := 0.0; update( k ,− t ); update( l , t )
    !

rotate rows and columns k and l for i := 1 to k −1 do rotate( i , k , i , l ) endfor for i := k +1 to l −1 do rotate( k , i , i , l ) endfor for i := l +1 to n do rotate( k , i , l , i ) endfor !

rotate eigenvectors for i := 1 to n do ┌ ┐    ┌     ┐┌ ┐
      │ E ik │    │ c − s ││ E ik │
      │ │ := │     ││ │
      │ E il │    │ s c ││ E il │
      └ ┘    └     ┘└ ┘ endfor !

update all potentially changed ind i for i := 1 to n do ind i := maxind( i ) endfor loop endproc Notes [ edit ] 1. The logical array changed holds the status of each eigenvalue. If the numerical value of e k {\displaystyle e_{k}} or e l {\displaystyle e_{l}} changes during an iteration, the corresponding component of changed is set to true , otherwise to false . The integer state counts the number of components of changed which have the value true . Iteration stops as soon as state = 0. This means that none of the approximations e 1 , .

.

.

, e n {\displaystyle e_{1},\,...\,,e_{n}} has recently changed its value and thus it is not very likely that this will happen if iteration continues. Here it is assumed that floating point operations are optimally rounded to the nearest floating point number.

2. The upper triangle of the matrix S is destroyed while the lower triangle and the diagonal are unchanged. Thus it is possible to restore S if necessary according to for k := 1 to n −1 do !

restore matrix S for l := k +1 to n do S kl := S lk endfor endfor 3. The eigenvalues are not necessarily in descending order. This can be achieved by a simple sorting algorithm.

for k := 1 to n −1 do m := k for l := k +1 to n do if e l > e m then m := l endif endfor if k ≠ m then swap e m , e k swap E m , E k endif endfor 4. The algorithm is written using matrix notation (1 based arrays instead of 0 based).

5. When implementing the algorithm, the part specified using matrix notation must be performed simultaneously.

6. This implementation does not correctly account for the case in which one dimension is an independent subspace.  For example, if given a diagonal matrix, the above implementation will never terminate, as none of the eigenvalues will change.  Hence, in real implementations, extra logic must be added to account for this case.

Example [ edit ] Let S = ( 4 − − 30 60 − − 35 − − 30 300 − − 675 420 60 − − 675 1620 − − 1050 − − 35 420 − − 1050 700 ) {\displaystyle S={\begin{pmatrix}4&-30&60&-35\\-30&300&-675&420\\60&-675&1620&-1050\\-35&420&-1050&700\end{pmatrix}}} Then jacobi produces the following eigenvalues and eigenvectors after 3 sweeps (19 iterations) : e 1 = 2585.25381092892231 {\displaystyle e_{1}=2585.25381092892231} E 1 = ( 0.0291933231647860588 − − 0.328712055763188997 0.791411145833126331 − − 0.514552749997152907 ) {\displaystyle E_{1}={\begin{pmatrix}0.0291933231647860588\\-0.328712055763188997\\0.791411145833126331\\-0.514552749997152907\end{pmatrix}}} e 2 = 37.1014913651276582 {\displaystyle e_{2}=37.1014913651276582} E 2 = ( − − 0.179186290535454826 0.741917790628453435 − − 0.100228136947192199 − − 0.638282528193614892 ) {\displaystyle E_{2}={\begin{pmatrix}-0.179186290535454826\\0.741917790628453435\\-0.100228136947192199\\-0.638282528193614892\end{pmatrix}}} e 3 = 1.4780548447781369 {\displaystyle e_{3}=1.4780548447781369} E 3 = ( − − 0.582075699497237650 0.370502185067093058 0.509578634501799626 0.514048272222164294 ) {\displaystyle E_{3}={\begin{pmatrix}-0.582075699497237650\\0.370502185067093058\\0.509578634501799626\\0.514048272222164294\end{pmatrix}}} e 4 = 0.1666428611718905 {\displaystyle e_{4}=0.1666428611718905} E 4 = ( 0.792608291163763585 0.451923120901599794 0.322416398581824992 0.252161169688241933 ) {\displaystyle E_{4}={\begin{pmatrix}0.792608291163763585\\0.451923120901599794\\0.322416398581824992\\0.252161169688241933\end{pmatrix}}} Applications for real symmetric matrices [ edit ] When the eigenvalues (and eigenvectors) of a symmetric matrix are known, the following
values are easily calculated.

Singular values The singular values of a (square) matrix A {\displaystyle A} are the square roots of the (non-negative) eigenvalues of A T A {\displaystyle A^{T}A} . In case of a symmetric matrix S {\displaystyle S} we have of S T S = S 2 {\displaystyle S^{T}S=S^{2}} , hence the singular values of S {\displaystyle S} are the absolute values of the eigenvalues of S {\displaystyle S} .

2-norm and spectral radius The 2-norm of a matrix A is the norm based on the Euclidean vectornorm; that is, the largest value ‖ ‖ A x ‖ ‖ 2 {\displaystyle \|Ax\|_{2}} when x runs through all vectors with ‖ ‖ x ‖ ‖ 2 = 1 {\displaystyle \|x\|_{2}=1} . It is the largest singular value of A {\displaystyle A} . In case of a symmetric matrix it is the largest absolute value of its eigenvectors and thus equal to its spectral radius.

Condition number The condition number of a nonsingular matrix A {\displaystyle A} is defined as cond ( A ) = ‖ ‖ A ‖ ‖ 2 ‖ ‖ A − − 1 ‖ ‖ 2 {\displaystyle {\mbox{cond}}(A)=\|A\|_{2}\|A^{-1}\|_{2}} . In case of a symmetric matrix it is the absolute value of the quotient of the largest and smallest eigenvalue. Matrices with large condition numbers can cause numerically unstable results: small perturbation can result in large errors.

Hilbert matrices are the most famous ill-conditioned matrices. For example, the fourth-order Hilbert matrix has a condition of 15514, while for order 8 it is 2.7 × 10 8 .

Rank A matrix A {\displaystyle A} has rank r {\displaystyle r} if it has r {\displaystyle r} columns that are linearly independent while the remaining columns are linearly dependent on these. Equivalently, r {\displaystyle r} is the dimension of the range of A {\displaystyle A} . Furthermore it is the number of nonzero singular values.

In case of a symmetric matrix r is the number of nonzero eigenvalues. Unfortunately because of rounding errors numerical approximations of zero eigenvalues may not be zero (it may also happen that a numerical approximation is zero while the true value is not). Thus one can only calculate the numerical rank by making a decision which of the eigenvalues are close enough to zero.

Pseudo-inverse The pseudo inverse of a matrix A {\displaystyle A} is the unique matrix X = A + {\displaystyle X=A^{+}} for which A X {\displaystyle AX} and X A {\displaystyle XA} are symmetric and for which A X A = A , X A X = X {\displaystyle AXA=A,XAX=X} holds. If A {\displaystyle A} is nonsingular, then A + = A − − 1 {\displaystyle A^{+}=A^{-1}} .

When procedure jacobi (S, e, E) is called, then the relation S = E T Diag ( e ) E {\displaystyle S=E^{T}{\mbox{Diag}}(e)E} holds where Diag( e )  denotes the diagonal matrix with vector e on the diagonal. Let e + {\displaystyle e^{+}} denote the vector where e i {\displaystyle e_{i}} is replaced by 1 / e i {\displaystyle 1/e_{i}} if e i ≤ ≤ 0 {\displaystyle e_{i}\leq 0} and by 0  if e i {\displaystyle e_{i}} is (numerically close to) zero. Since matrix E is orthogonal, it follows that the pseudo-inverse of S is given by S + = E T Diag ( e + ) E {\displaystyle S^{+}=E^{T}{\mbox{Diag}}(e^{+})E} .

Least squares solution If matrix A {\displaystyle A} does not have full rank, there may not be a solution of the linear system A x = b {\displaystyle Ax=b} . However one can look for a vector x for which ‖ ‖ A x − − b ‖ ‖ 2 {\displaystyle \|Ax-b\|_{2}} is minimal. The solution is x = A + b {\displaystyle x=A^{+}b} . In case of a symmetric matrix S as before, one has x = S + b = E T Diag ( e + ) E b {\displaystyle x=S^{+}b=E^{T}{\mbox{Diag}}(e^{+})Eb} .

Matrix exponential From S = E T Diag ( e ) E {\displaystyle S=E^{T}{\mbox{Diag}}(e)E} one finds exp ⁡ ⁡ S = E T Diag ( exp ⁡ ⁡ e ) E {\displaystyle \exp S=E^{T}{\mbox{Diag}}(\exp e)E} where  exp e {\displaystyle e} is the vector where e i {\displaystyle e_{i}} is replaced by exp ⁡ ⁡ e i {\displaystyle \exp e_{i}} . In the same way, f ( S ) {\displaystyle f(S)} can be calculated in an obvious way for any (analytic) function f {\displaystyle f} .

Linear differential equations The differential equation x ′ = A x , x ( 0 ) = a {\displaystyle x'=Ax,x(0)=a} has the solution x ( t ) = exp ⁡ ⁡ ( t A ) {\displaystyle x(t)=\exp(tA)} . For a symmetric matrix S {\displaystyle S} , it follows that x ( t ) = E T Diag ( exp ⁡ ⁡ t e ) E a {\displaystyle x(t)=E^{T}{\mbox{Diag}}(\exp te)Ea} . If a = ∑ ∑ i = 1 n a i E i {\displaystyle a=\sum _{i=1}^{n}a_{i}E_{i}} is the expansion of a {\displaystyle a} by the eigenvectors of S {\displaystyle S} , then x ( t ) = ∑ ∑ i = 1 n a i exp ⁡ ⁡ ( t e i ) E i {\displaystyle x(t)=\sum _{i=1}^{n}a_{i}\exp(te_{i})E_{i}} .

Let W s {\displaystyle W^{s}} be the vector space spanned by the eigenvectors of S {\displaystyle S} which correspond to a negative eigenvalue and W u {\displaystyle W^{u}} analogously for the positive eigenvalues. If a ∈ ∈ W s {\displaystyle a\in W^{s}} then lim t → → ∞ ∞ x ( t ) = 0 {\displaystyle {\mbox{lim}}_{t\rightarrow \infty }x(t)=0} ; that is, the equilibrium point 0 is attractive to x ( t ) {\displaystyle x(t)} . If a ∈ ∈ W u {\displaystyle a\in W^{u}} then lim t → → ∞ ∞ x ( t ) = ∞ ∞ {\displaystyle {\mbox{lim}}_{t\rightarrow \infty }x(t)=\infty } ; that is, 0 is repulsive to x ( t ) {\displaystyle x(t)} .

W s {\displaystyle W^{s}} and W u {\displaystyle W^{u}} are called stable and unstable manifolds for S {\displaystyle S} . If a {\displaystyle a} has components in both manifolds, then one component is attracted and one component is repelled. Hence x ( t ) {\displaystyle x(t)} approaches W u {\displaystyle W^{u}} as t → → ∞ ∞ {\displaystyle t\to \infty } .

Julia implementation [ edit ] The following code is a straight-forward implementation of the mathematical description of the Jacobi eigenvalue algorithm in the Julia programming language .

using LinearAlgebra , Test function find_pivot ( Sprime ) n = size ( Sprime , 1 ) pivot_i = pivot_j = 0 pivot = 0.0 for j = 1 : n for i = 1 : ( j - 1 ) if abs ( Sprime [ i , j ]) > pivot pivot_i = i pivot_j = j pivot = abs ( Sprime [ i , j ]) end end end return ( pivot_i , pivot_j , pivot ) end # in practice one should not instantiate explicitly the Givens rotation matrix function givens_rotation_matrix ( n , i , j , θ ) G = Matrix { Float64 }( I ,( n , n )) G [ i , i ] = G [ j , j ] = cos ( θ ) G [ i , j ] = sin ( θ ) G [ j , i ] = - sin ( θ ) return G end # S is a symmetric n by n matrix n = 4 sqrtS = randn ( n , n ); S = sqrtS * sqrtS ' ; # the largest allowed off-diagonal element of U' * S * U # where U are the eigenvectors tol = 1e-14 Sprime = copy ( S ) U = Matrix { Float64 }( I ,( n , n )) while true ( pivot_i , pivot_j , pivot ) = find_pivot ( Sprime ) if pivot < tol break end θ = atan ( 2 * Sprime [ pivot_i , pivot_j ] / ( Sprime [ pivot_j , pivot_j ] - Sprime [ pivot_i , pivot_i ] )) / 2 G = givens_rotation_matrix ( n , pivot_i , pivot_j , θ ) # update Sprime and U Sprime .= G '* Sprime * G U .= U * G end # Sprime is now (almost) a diagonal matrix # extract eigenvalues λ = diag ( Sprime ) # sort eigenvalues (and corresponding eigenvectors U) by increasing values i = sortperm ( λ ) λ = λ [ i ] U = U [ : , i ] # S should be equal to U * diagm(λ) * U' @test S ≈ U * diagm ( λ ) * U ' Generalizations [ edit ] The Jacobi Method has been generalized to complex Hermitian matrices , general nonsymmetric real and complex matrices as well as block matrices.

Since singular values of a real matrix are the square roots of the eigenvalues of the symmetric matrix S = A T A {\displaystyle S=A^{T}A} it can also be used for the calculation of these values. For this case, the method is modified in such a way that S must not be explicitly calculated which reduces the danger of round-off errors . Note that J S J T = J A T A J T = J A T J T J A J T = B T B {\displaystyle JSJ^{T}=JA^{T}AJ^{T}=JA^{T}J^{T}JAJ^{T}=B^{T}B} with B := J A J T {\displaystyle B\,:=JAJ^{T}} .

References [ edit ] ^ Jacobi, C.G.J.

(1846).

"Über ein leichtes Verfahren, die in der Theorie der Säkularstörungen vorkommenden Gleichungen numerisch aufzulösen" .

Crelle's Journal (in German).

1846 (30): 51– 94.

doi : 10.1515/crll.1846.30.51 .

S2CID 199546177 .

^ Golub, G.H.

; van der Vorst, H.A.

(2000).

"Eigenvalue computation in the 20th century" .

Journal of Computational and Applied Mathematics .

123 ( 1– 2): 35– 65.

doi : 10.1016/S0377-0427(00)00413-1 .

^ Schönhage, A.

(1964). "Zur quadratischen Konvergenz des Jacobi-Verfahrens".

Numerische Mathematik (in German).

6 (1): 410– 412.

doi : 10.1007/BF01386091 .

MR 0174171 .

S2CID 118301078 .

^ Wilkinson, J.H.

(1962). "Note on the Quadratic Convergence of the Cyclic Jacobi Process".

Numerische Mathematik .

6 : 296– 300.

doi : 10.1007/BF01386321 .

^ van Kempen, H.P.M. (1966). "On Quadratic Convergence of the Special Cyclic Jacobi Method".

Numerische Mathematik .

9 : 19– 22.

doi : 10.1007/BF02165225 .

Further reading [ edit ] Press, WH; Teukolsky, SA; Vetterling, WT; Flannery, BP (2007), "Section 11.1. Jacobi Transformations of a Symmetric Matrix" , Numerical Recipes: The Art of Scientific Computing (3rd ed.), New York: Cambridge University Press, ISBN 978-0-521-88068-8 , archived from the original on 2011-08-11 , retrieved 2011-08-13 Rutishauser, H. (1966). "Handbook Series Linear Algebra: The Jacobi method for real symmetric matrices".

Numerische Mathematik .

9 (1): 1– 10.

doi : 10.1007/BF02165223 .

MR 1553948 .

S2CID 120520713 .

Sameh, A.H. (1971).

"On Jacobi and Jacobi-like algorithms for a parallel computer" .

Mathematics of Computation .

25 (115): 579– 590.

doi : 10.1090/s0025-5718-1971-0297131-6 .

JSTOR 2005221 .

MR 0297131 .

Shroff, Gautam M. (1991). "A parallel algorithm for the eigenvalues and eigenvectors of a general complex matrix".

Numerische Mathematik .

58 (1): 779– 805.

CiteSeerX 10.1.1.134.3566 .

doi : 10.1007/BF01385654 .

MR 1098865 .

S2CID 13904356 .

Veselić, K. (1979). "On a class of Jacobi-like procedures for diagonalising arbitrary real matrices".

Numerische Mathematik .

33 (2): 157– 172.

doi : 10.1007/BF01399551 .

MR 0549446 .

S2CID 119919630 .

Veselić, K.; Wenzel, H. J. (1979). "A quadratically convergent Jacobi-like method for real matrices with complex eigenvalues".

Numerische Mathematik .

33 (4): 425– 435.

doi : 10.1007/BF01399324 .

MR 0553351 .

S2CID 119554420 .

Yousef Saad: "Revisiting the (block) Jacobi subspace rotation method for the symmetric eigenvalue problem", Numerical Algorithms, vol.92 (2023), pp.917-944.

https://doi.org/10.1007/s11075-022-01377-w .

External links [ edit ] Matlab implementation of Jacobi algorithm that avoids trigonometric functions C++11 implementation v t e Numerical linear algebra Key concepts Floating point Numerical stability Problems System of linear equations Matrix decompositions Matrix multiplication ( algorithms ) Matrix splitting Sparse problems Hardware CPU cache TLB Cache-oblivious algorithm SIMD Multiprocessing Software ATLAS MATLAB Basic Linear Algebra Subprograms (BLAS) LAPACK Specialized libraries General purpose software Retrieved from " https://en.wikipedia.org/w/index.php?title=Jacobi_eigenvalue_algorithm&oldid=1298049224 " Category : Numerical linear algebra Hidden categories: CS1 German-language sources (de) Articles with short description Short description is different from Wikidata Articles with example pseudocode This page was last edited on 30 June 2025, at 06:03 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Jacobi eigenvalue algorithm 9 languages Add topic

