Title: Framebuffer

URL Source: https://en.wikipedia.org/wiki/Framebuffer

Published Time: 2002-11-22T20:42:12Z

Markdown Content:
From Wikipedia, the free encyclopedia

[![Image 1](https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Sun_sbus_cgsix_framebuffer.jpg/250px-Sun_sbus_cgsix_framebuffer.jpg)](https://en.wikipedia.org/wiki/File:Sun_sbus_cgsix_framebuffer.jpg)

Sun TGX Framebuffer

A **framebuffer** (**frame buffer**, or sometimes **framestore**) is a portion of [random-access memory](https://en.wikipedia.org/wiki/Random-access_memory "Random-access memory") (RAM)[[1]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-1) containing a [bitmap](https://en.wikipedia.org/wiki/Bitmap "Bitmap") that drives a video display. It is a [memory buffer](https://en.wikipedia.org/wiki/Memory_buffer "Memory buffer") containing data representing all the [pixels](https://en.wikipedia.org/wiki/Pixel "Pixel") in a complete [video frame](https://en.wikipedia.org/wiki/Video_frame "Video frame").[[2]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-2) Modern [video cards](https://en.wikipedia.org/wiki/Video_card "Video card") contain framebuffer circuitry in their cores. This circuitry converts an in-memory bitmap into a [video signal](https://en.wikipedia.org/wiki/Video_signal "Video signal") that can be displayed on a computer monitor.

In [computing](https://en.wikipedia.org/wiki/Computing "Computing"), a **screen buffer** is a part of [computer memory](https://en.wikipedia.org/wiki/Computer_memory "Computer memory") used by a computer application for the representation of the content to be shown on the [computer display](https://en.wikipedia.org/wiki/Computer_display "Computer display").[[3]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-google-3) The screen buffer may also be called the **video buffer**, the **regeneration buffer**, or **regen buffer** for short.[[4]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-smartcomputing-4) Screen buffers should be distinguished from [video memory](https://en.wikipedia.org/wiki/Video_memory "Video memory"). To this end, the term **off-screen buffer** is also used.

The information in the buffer typically consists of color values for every pixel to be shown on the display. Color values are commonly stored in 1-bit [binary](https://en.wikipedia.org/wiki/Binary_image "Binary image") (monochrome), 4-bit [palettized](https://en.wikipedia.org/wiki/Palette_(computing) "Palette (computing)"), 8-bit palettized, 16-bit [high color](https://en.wikipedia.org/wiki/High_color "High color") and 24-bit [true color](https://en.wikipedia.org/wiki/Color_depth#True_color_.2824-bit.29 "Color depth") formats. An additional [alpha channel](https://en.wikipedia.org/wiki/Alpha_channel "Alpha channel") is sometimes used to retain information about pixel transparency. The total amount of memory required for the framebuffer depends on the [resolution](https://en.wikipedia.org/wiki/Display_resolution "Display resolution") of the output signal, and on the [color depth](https://en.wikipedia.org/wiki/Color_depth "Color depth") or palette size.

[![Image 2](https://upload.wikimedia.org/wikipedia/commons/thumb/3/36/SWAC_003.jpg/250px-SWAC_003.jpg)](https://en.wikipedia.org/wiki/File:SWAC_003.jpg)

Memory pattern on [SWAC](https://en.wikipedia.org/wiki/SWAC_(computer) "SWAC (computer)") Williams tube CRT in 1951

Computer researchers[_[who?](https://en.wikipedia.org/wiki/Wikipedia:Manual\_of\_Style/Words\_to\_watch#Unsupported\_attributions "Wikipedia:Manual of Style/Words to watch")_] had long discussed the theoretical advantages of a framebuffer but were unable to produce a machine with sufficient [memory](https://en.wikipedia.org/wiki/Computer_memory "Computer memory") at an economically practicable cost.[_[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation\_needed "Wikipedia:Citation needed")_][[5]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-Gaboury-5) In 1947, the [Manchester Baby](https://en.wikipedia.org/wiki/Manchester_Baby "Manchester Baby") computer used a [Williams tube](https://en.wikipedia.org/wiki/Williams_tube "Williams tube"), later the Williams-Kilburn tube, to store 1024 bits on a [cathode-ray tube (CRT)](https://en.wikipedia.org/wiki/Cathode-ray_tube "Cathode-ray tube") memory and displayed on a second CRT.[[6]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-6)[[7]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-7) Other research labs were exploring these techniques with [MIT Lincoln Laboratory](https://en.wikipedia.org/wiki/MIT_Lincoln_Laboratory "MIT Lincoln Laboratory") achieving a 4096 display in 1950.[[5]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-Gaboury-5)

A color-scanned display was implemented in the late 1960s, called the [Brookhaven](https://en.wikipedia.org/wiki/Brookhaven_National_Laboratory "Brookhaven National Laboratory") RAster Display (BRAD), which used a [drum memory](https://en.wikipedia.org/wiki/Drum_memory "Drum memory") and a television monitor.[[8]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-8) In 1969, A. Michael Noll of [Bell Telephone Laboratories, Inc.](https://en.wikipedia.org/wiki/Bell_Telephone_Laboratories,_Inc. "Bell Telephone Laboratories, Inc.") implemented a scanned display with a frame buffer, using [magnetic-core memory](https://en.wikipedia.org/wiki/Magnetic-core_memory "Magnetic-core memory").[[9]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-9) A year or so later, the Bell Labs system was expanded to display an image with a color depth of three bits on a standard color TV monitor. The vector graphics used in the computer had to be converted for the scanned graphics of a TV display.

In the early 1970s, the development of [MOS memory](https://en.wikipedia.org/wiki/MOS_memory "MOS memory") ([metal–oxide–semiconductor](https://en.wikipedia.org/wiki/Metal%E2%80%93oxide%E2%80%93semiconductor "Metal–oxide–semiconductor") memory) [integrated-circuit](https://en.wikipedia.org/wiki/Integrated_circuit "Integrated circuit") chips, particularly [high-density](https://en.wikipedia.org/wiki/Large-scale_integration "Large-scale integration")[DRAM](https://en.wikipedia.org/wiki/DRAM "DRAM") (dynamic [random-access memory](https://en.wikipedia.org/wiki/Random-access_memory "Random-access memory")) chips with at least 1[kb](https://en.wikipedia.org/wiki/Kibibit "Kibibit") memory, made it practical to create, for the first time, a [digital memory](https://en.wikipedia.org/wiki/Digital_memory "Digital memory") system with framebuffers capable of holding a standard video image.[[10]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-Shoup_SuperPaint-10)[[11]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-11) This led to the development of the [SuperPaint](https://en.wikipedia.org/wiki/SuperPaint "SuperPaint") system by [Richard Shoup](https://en.wikipedia.org/wiki/Richard_Shoup_(programmer) "Richard Shoup (programmer)") at [Xerox PARC](https://en.wikipedia.org/wiki/Xerox_PARC "Xerox PARC") in 1972.[[10]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-Shoup_SuperPaint-10) Shoup was able to use the SuperPaint framebuffer to create an early digital video-capture system. By synchronizing the output signal to the input signal, Shoup was able to overwrite each pixel of data as it shifted in. Shoup also experimented with modifying the output signal using color tables. These color tables allowed the SuperPaint system to produce a wide variety of colors outside the range of the limited 8-bit data it contained. This scheme would later become commonplace in computer framebuffers.

In 1974, [Evans & Sutherland](https://en.wikipedia.org/wiki/Evans_%26_Sutherland "Evans & Sutherland") released the first commercial framebuffer, the Picture System,[[12]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-12) costing about $15,000. It was capable of producing resolutions of up to 512 by 512 pixels in 8-bit [grayscale](https://en.wikipedia.org/wiki/Grayscale "Grayscale"), and became a boon for graphics researchers who did not have the resources to build their own framebuffer. The [New York Institute of Technology](https://en.wikipedia.org/wiki/New_York_Institute_of_Technology "New York Institute of Technology") would later create the first 24-bit color system using three of the Evans & Sutherland framebuffers.[[13]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-NYIT-History-13) Each framebuffer was connected to an [RGB](https://en.wikipedia.org/wiki/RGB "RGB") color output (one for red, one for green and one for blue), with a Digital Equipment Corporation PDP 11/04 [minicomputer](https://en.wikipedia.org/wiki/Minicomputer "Minicomputer") controlling the three devices as one.

In 1975, the UK company [Quantel](https://en.wikipedia.org/wiki/Quantel "Quantel") produced the first commercial full-color broadcast framebuffer, the Quantel DFS 3000. It was first used in TV coverage of the [1976 Montreal Olympics](https://en.wikipedia.org/wiki/1976_Montreal_Olympics "1976 Montreal Olympics") to generate a [picture-in-picture](https://en.wikipedia.org/wiki/Picture-in-picture "Picture-in-picture") inset of the Olympic flaming torch while the rest of the picture featured the runner entering the stadium.

The rapid improvement of integrated-circuit technology made it possible for many of the home computers of the late 1970s to contain low-color-depth framebuffers. Today, nearly all computers with graphical capabilities utilize a framebuffer for generating the video signal. [Amiga](https://en.wikipedia.org/wiki/Amiga "Amiga") computers, created in the 1980s, featured special design attention to graphics performance and included a unique [Hold-And-Modify](https://en.wikipedia.org/wiki/Hold-And-Modify "Hold-And-Modify") framebuffer capable of displaying 4096 colors.

Framebuffers also became popular in high-end workstations and [arcade system boards](https://en.wikipedia.org/wiki/Arcade_system_board "Arcade system board") throughout the 1980s. [SGI](https://en.wikipedia.org/wiki/Silicon_Graphics "Silicon Graphics"), [Sun Microsystems](https://en.wikipedia.org/wiki/Sun_Microsystems "Sun Microsystems"), [HP](https://en.wikipedia.org/wiki/Hewlett-Packard "Hewlett-Packard"), [DEC](https://en.wikipedia.org/wiki/Digital_Equipment_Corporation "Digital Equipment Corporation") and [IBM](https://en.wikipedia.org/wiki/IBM "IBM") all released framebuffers for their workstation computers in this period. These framebuffers were usually of a much higher quality than could be found in most home computers, and were regularly used in television, printing, computer modeling and 3D graphics. Framebuffers were also used by [Sega](https://en.wikipedia.org/wiki/Sega "Sega") for its high-end [arcade boards](https://en.wikipedia.org/wiki/List_of_Sega_arcade_system_boards "List of Sega arcade system boards"), which were also of a higher quality than on home computers.

[![Image 3](https://upload.wikimedia.org/wikipedia/commons/thumb/8/89/Sun_sbus_cgsix_framebuffer2.jpg/250px-Sun_sbus_cgsix_framebuffer2.jpg)](https://en.wikipedia.org/wiki/File:Sun_sbus_cgsix_framebuffer2.jpg)

A Sun cgsix framebuffer

Framebuffers used in personal and home computing often had sets of defined _modes_ under which the framebuffer can operate. These modes reconfigure the hardware to output different resolutions, color depths, memory layouts and [refresh rate](https://en.wikipedia.org/wiki/Refresh_rate "Refresh rate") timings.

In the world of [Unix](https://en.wikipedia.org/wiki/Unix "Unix") machines and operating systems, such conveniences were usually eschewed in favor of directly manipulating the hardware settings. This manipulation was far more flexible in that any resolution, color depth and refresh rate was attainable– limited only by the memory available to the framebuffer.

An unfortunate side-effect of this method was that the [display device](https://en.wikipedia.org/wiki/Display_device "Display device") could be driven beyond its capabilities. In some cases, this resulted in hardware damage to the display.[[14]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-14) More commonly, it simply produced garbled and unusable output. Modern CRT monitors fix this problem through the introduction of protection circuitry. When the display mode is changed, the monitor attempts to obtain a signal lock on the new refresh frequency. If the monitor is unable to obtain a signal lock or if the signal is outside the range of its design limitations, the monitor will ignore the framebuffer signal and possibly present the user with an error message.

LCD monitors tend to contain similar protection circuitry, but for different reasons. Since the LCD must digitally sample the display signal (thereby emulating an electron beam), any signal that is out of range cannot be physically displayed on the monitor.

Framebuffers have traditionally supported a wide variety of color modes. Due to the expense of memory, most early framebuffers used 1-bit (2 colors per pixel), 2-bit (4 colors), 4-bit (16 colors) or 8-bit (256 colors) color depths. The problem with such small color depths is that a full range of colors cannot be produced. The solution to this problem was [indexed color](https://en.wikipedia.org/wiki/Indexed_color "Indexed color"), which adds a [lookup table](https://en.wikipedia.org/wiki/Lookup_table "Lookup table") to the framebuffer. Each color stored in framebuffer memory acts as a color index. The lookup table serves as a palette with a limited number of different colors, while the rest is used as an index table.

Here is a typical indexed 256-color image and its own palette (shown as a rectangle of swatches):

In some designs it was also possible to write data to the lookup table (or switch between existing palettes) on the fly, allowing dividing the picture into horizontal bars with their own palette and thus render an image that had a far wider palette. For example, viewing an outdoor shot photograph, the picture could be divided into four bars: the top one with emphasis on sky tones, the next with foliage tones, the next with skin and clothing tones, and the bottom one with ground colors. This required each palette to have overlapping colors, but, carefully done, allowed great flexibility.

While framebuffers are commonly accessed via a [memory mapping](https://en.wikipedia.org/wiki/Memory-mapped_I/O "Memory-mapped I/O") directly to the CPU memory space, this is not the only method by which they may be accessed. Framebuffers have varied widely in the methods used to access memory. Some of the most common are:

*   Mapping the entire framebuffer to a given memory range.
*   Port commands to set each pixel, range of pixels or palette entry.
*   Mapping a memory range smaller than the framebuffer memory, then [bank switching](https://en.wikipedia.org/wiki/Bank_switching "Bank switching") as necessary.

The framebuffer organization may be [packed pixel](https://en.wikipedia.org/wiki/Packed_pixel "Packed pixel") or [planar](https://en.wikipedia.org/wiki/Planar_(computer_graphics) "Planar (computer graphics)"). The framebuffer may be [all points addressable](https://en.wikipedia.org/wiki/All_points_addressable "All points addressable") or have restrictions on how it can be updated.

RAM on the video card
---------------------

[[edit](https://en.wikipedia.org/w/index.php?title=Framebuffer&action=edit&section=5 "Edit section: RAM on the video card")]

Video cards always have a certain amount of RAM. A small portion of this RAM is where the bitmap of image data is "buffered" for display. The term _frame buffer_ is thus often used interchangeably when referring to this RAM.

The CPU sends image updates to the video card. The video processor on the card forms a picture of the screen image and stores it in the frame buffer as a large bitmap in RAM. The bitmap in RAM is used by the card to continually refresh the screen image.[[15]](https://en.wikipedia.org/wiki/Framebuffer#cite_note-15)

Virtual framebuffers
--------------------

[[edit](https://en.wikipedia.org/w/index.php?title=Framebuffer&action=edit&section=6 "Edit section: Virtual framebuffers")]

Many systems attempt to emulate the function of a framebuffer device, often for reasons of compatibility. The two most common [virtual](https://en.wikipedia.org/wiki/Virtualization "Virtualization") framebuffers are the [Linux framebuffer](https://en.wikipedia.org/wiki/Linux_framebuffer "Linux framebuffer") device (fbdev) and the X Virtual Framebuffer ([Xvfb](https://en.wikipedia.org/wiki/Xvfb "Xvfb")). Xvfb was added to the [X Window System](https://en.wikipedia.org/wiki/X_Window_System "X Window System") distribution to provide a method for running X without a graphical framebuffer. The Linux framebuffer device was developed to abstract the physical method for accessing the underlying framebuffer into a guaranteed memory map that is easy for programs to access. This increases portability, as programs are not required to deal with systems that have disjointed memory maps or require [bank switching](https://en.wikipedia.org/wiki/Bank_switching "Bank switching").

A frame buffer may be designed with enough memory to store two frames' worth of video data. In a technique known generally as [double buffering](https://en.wikipedia.org/wiki/Double_buffering "Double buffering") or more specifically as [page flipping](https://en.wikipedia.org/wiki/Page_flipping "Page flipping"), the framebuffer uses half of its memory to display the current frame. While that memory is being displayed, the other half of memory is filled with data for the next frame. Once the secondary buffer is filled, the framebuffer is instructed to display the secondary buffer instead. The primary buffer becomes the secondary buffer, and the secondary buffer becomes the primary. This switch is often done after the [vertical blanking interval](https://en.wikipedia.org/wiki/Vertical_blanking_interval "Vertical blanking interval") to avoid [screen tearing](https://en.wikipedia.org/wiki/Screen_tearing "Screen tearing") where half the old frame and half the new frame is shown together.

Page flipping has become a standard technique used by PC [game programmers](https://en.wikipedia.org/wiki/Game_programmer "Game programmer").

Graphics accelerators
---------------------

[[edit](https://en.wikipedia.org/w/index.php?title=Framebuffer&action=edit&section=8 "Edit section: Graphics accelerators")]

As the demand for better graphics increased, hardware manufacturers created a way to decrease the amount of [CPU](https://en.wikipedia.org/wiki/CPU "CPU") time required to fill the framebuffer. This is commonly called _graphics acceleration_. Common graphics drawing commands (many of them geometric) are sent to the graphics accelerator in their raw form. The accelerator then [rasterizes](https://en.wikipedia.org/wiki/Rasterisation "Rasterisation") the results of the command to the framebuffer. This method frees the CPU to do other work.

Early accelerators focused on improving the performance of 2D [GUI](https://en.wikipedia.org/wiki/GUI "GUI") systems. While retaining these 2D capabilities, most modern accelerators focus on producing 3D imagery in real time. A common design uses a [graphics library](https://en.wikipedia.org/wiki/Graphics_library "Graphics library") such as [OpenGL](https://en.wikipedia.org/wiki/OpenGL "OpenGL") or [Direct3D](https://en.wikipedia.org/wiki/Direct3D "Direct3D") which interfaces with the graphics driver to translate received commands to instructions for the accelerator's [graphics processing unit](https://en.wikipedia.org/wiki/Graphics_processing_unit "Graphics processing unit") (GPU). The GPU uses those instructions to compute the rasterized results and the results are [bit blitted](https://en.wikipedia.org/wiki/Bit_blit "Bit blit") to the framebuffer. The framebuffer's signal is then produced in combination with built-in video overlay devices (usually used to produce the mouse cursor without modifying the framebuffer's data) and any final special effects that are produced by modifying the output signal. An example of such final special effects was the [spatial anti-aliasing](https://en.wikipedia.org/wiki/Spatial_anti-aliasing "Spatial anti-aliasing") technique used by the [3dfx Voodoo](https://en.wikipedia.org/wiki/3dfx_Voodoo "3dfx Voodoo") cards. These cards add a slight blur to the output signal that makes aliasing of the rasterized graphics much less obvious.

At one time there were many manufacturers of graphics accelerators, including: [3dfx Interactive](https://en.wikipedia.org/wiki/3dfx_Interactive "3dfx Interactive"); [ATI](https://en.wikipedia.org/wiki/ATI_Technologies "ATI Technologies"); [Hercules](https://en.wikipedia.org/wiki/Hercules_Computer_Technology "Hercules Computer Technology"); [Trident](https://en.wikipedia.org/wiki/Trident_Microsystems "Trident Microsystems"); [Nvidia](https://en.wikipedia.org/wiki/Nvidia "Nvidia"); [Radius](https://en.wikipedia.org/wiki/Radius_(hardware_company) "Radius (hardware company)"); [S3 Graphics](https://en.wikipedia.org/wiki/S3_Graphics "S3 Graphics"); [SiS](https://en.wikipedia.org/wiki/Silicon_Integrated_Systems "Silicon Integrated Systems") and [Silicon Graphics](https://en.wikipedia.org/wiki/Silicon_Graphics "Silicon Graphics"). As of 2015 the market for graphics accelerators for x86-based systems is dominated by Nvidia (acquired 3dfx in 2002), [AMD](https://en.wikipedia.org/wiki/AMD "AMD") (who acquired ATI in 2006), and [Intel](https://en.wikipedia.org/wiki/Intel "Intel").

With a framebuffer, the electron beam (if the display technology uses one) is commanded to perform a [raster scan](https://en.wikipedia.org/wiki/Raster_scan "Raster scan"), the way a [television](https://en.wikipedia.org/wiki/Television "Television") renders a broadcast signal. The color information for each point thus displayed on the screen is pulled directly from the framebuffer during the scan, creating a set of discrete picture elements, i.e., pixels.

Framebuffers differ significantly from the [vector displays](https://en.wikipedia.org/wiki/Vector_display "Vector display") that were common prior to the advent of raster graphics (and, consequently, to the concept of a framebuffer). With a vector display, only the [vertices](https://en.wikipedia.org/wiki/Vertex_(geometry) "Vertex (geometry)") of the graphics primitives are stored. The [electron beam](https://en.wikipedia.org/wiki/Electron_beam "Electron beam") of the output display is then commanded to move from vertex to vertex, tracing a line across the area between these points.

Likewise, framebuffers differ from the technology used in early [text mode](https://en.wikipedia.org/wiki/Text_mode "Text mode") displays, where a buffer holds codes for characters, not individual pixels. The video display device performs the same raster scan as with a framebuffer but generates the pixels of each character in the buffer as it directs the beam.

*   [Bit plane](https://en.wikipedia.org/wiki/Bit_plane "Bit plane")
*   [Scanline rendering](https://en.wikipedia.org/wiki/Scanline_rendering "Scanline rendering")
*   [Swap chain](https://en.wikipedia.org/wiki/Swap_chain "Swap chain")
*   [Tile-based video game](https://en.wikipedia.org/wiki/Tile-based_video_game "Tile-based video game")
*   [Tiled rendering](https://en.wikipedia.org/wiki/Tiled_rendering "Tiled rendering")
*   [Tektronix 4050](https://en.wikipedia.org/wiki/Tektronix_4050 "Tektronix 4050") used a [storage tube](https://en.wikipedia.org/wiki/Storage_tube "Storage tube") to eliminate the need for framebuffer memory

1.   **[^](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-1 "Jump up")**["What is frame buffer? A Webopedia Definition"](http://www.webopedia.com/TERM/F/frame_buffer.html). _webopedia.com_. June 1998.
2.   **[^](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-2 "Jump up")**["Frame Buffer FAQ"](http://www.sunhelp.org/faq/FrameBuffer.html#00). Retrieved 14 May 2014.
3.   **[^](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-google_3-0 "Jump up")**Mueller, J. (2002). [_.NET Framework Solutions: In Search of the Lost Win32 API_](https://books.google.com/books?id=XYQruTc6_44C). Wiley. p.160. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[9780782141344](https://en.wikipedia.org/wiki/Special:BookSources/9780782141344 "Special:BookSources/9780782141344"). Retrieved 2015-04-21.
4.   **[^](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-smartcomputing_4-0 "Jump up")**["Smart Computing Dictionary Entry - video buffer"](https://web.archive.org/web/20120324192310/http://www.smartcomputing.com/editorial/dictionary/detail.asp?searchtype=2&DicID=10421&RefType=Dictionary&guid=). Archived from [the original](http://www.smartcomputing.com/editorial/dictionary/detail.asp?searchtype=2&DicID=10421&RefType=Dictionary&guid=) on 2012-03-24. Retrieved 2015-04-21.
5.   ^ [Jump up to: _**a**_](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-Gaboury_5-0)[_**b**_](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-Gaboury_5-1)Gaboury, J. (2018-03-01). ["The random-access image: Memory and the history of the computer screen"](https://escholarship.org/uc/item/0b3873pn). _Grey Room_. **70** (70): 24–53. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1162/GREY_a_00233](https://doi.org/10.1162%2FGREY_a_00233). [hdl](https://en.wikipedia.org/wiki/Hdl_(identifier) "Hdl (identifier)"):[21.11116/0000-0001-FA73-4](https://hdl.handle.net/21.11116%2F0000-0001-FA73-4). [ISSN](https://en.wikipedia.org/wiki/ISSN_(identifier) "ISSN (identifier)")[1526-3819](https://search.worldcat.org/issn/1526-3819). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)")[57565564](https://api.semanticscholar.org/CorpusID:57565564).
6.   **[^](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-6 "Jump up")**Williams, F. C.; Kilburn, T. (March 1949). ["A storage system for use with binary-digital computing machines"](https://web.archive.org/web/20190426011059/https://ieeexplore.ieee.org/document/5241129). _Proceedings of the IEE - Part III: Radio and Communication Engineering_. **96** (40): 81–. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1049/pi-3.1949.0018](https://doi.org/10.1049%2Fpi-3.1949.0018). Archived from [the original](https://ieeexplore.ieee.org/document/5241129) on April 26, 2019.
7.   **[^](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-7 "Jump up")**["Kilburn 1947 Report Cover Notes (Digital 60)"](http://curation.cs.manchester.ac.uk/digital60/www.digital60.org/birth/manchestercomputers/mark1/documents/report1947cover.html). _curation.cs.manchester.ac.uk_. Retrieved 2019-04-26.
8.   **[^](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-8 "Jump up")**D. Ophir; S. Rankowitz; B. J. Shepherd; R. J. Spinrad (June 1968), "BRAD: The Brookhave Raster Display", _Communications of the ACM_, vol.11, no.6, pp.415–416, [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1145/363347.363385](https://doi.org/10.1145%2F363347.363385), [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)")[11160780](https://api.semanticscholar.org/CorpusID:11160780)
9.   **[^](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-9 "Jump up")**Noll, A. Michael (March 1971). ["Scanned-Display Computer Graphics"](https://doi.org/10.1145%2F362566.362567). _Communications of the ACM_. **14** (3): 145–150. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1145/362566.362567](https://doi.org/10.1145%2F362566.362567). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)")[2210619](https://api.semanticscholar.org/CorpusID:2210619).
10.   ^ [Jump up to: _**a**_](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-Shoup_SuperPaint_10-0)[_**b**_](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-Shoup_SuperPaint_10-1)Richard Shoup (2001). ["SuperPaint: An Early Frame Buffer Graphics System"](https://web.archive.org/web/20040612215245/http://accad.osu.edu/~waynec/history/PDFs/Annals_final.pdf)(PDF). _Annals of the History of Computing_. IEEE. Archived from [the original](https://ohiostate.pressbooks.pub/app/uploads/sites/45/2017/09/Annals_final.pdf)(PDF) on 2004-06-12.
11.   **[^](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-11 "Jump up")**Goldwasser, S.M. (June 1983). [_Computer Architecture For Interactive Display Of Segmented Imagery_](https://books.google.com/books?id=8MuoCAAAQBAJ&pg=PA81). Computer Architectures for Spatially Distributed Data. [Springer Science & Business Media](https://en.wikipedia.org/wiki/Springer_Science_%26_Business_Media "Springer Science & Business Media"). pp.75–94 (81). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[9783642821509](https://en.wikipedia.org/wiki/Special:BookSources/9783642821509 "Special:BookSources/9783642821509").
12.   **[^](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-12 "Jump up")**[_Picture System_](http://s3data.computerhistory.org/brochures/evanssutherland.3d.1974.102646288.pdf)(PDF), Evans & Sutherland, retrieved 2017-12-31
13.   **[^](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-NYIT-History_13-0 "Jump up")**["History of the New York Institute of Technology Graphics Lab"](https://www.cs.cmu.edu/~ph/nyit/masson/nyit.html). Retrieved 2007-08-31.
14.   **[^](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-14 "Jump up")**[http://tldp.org/HOWTO/XFree86-Video-Timings-HOWTO/overd.html](http://tldp.org/HOWTO/XFree86-Video-Timings-HOWTO/overd.html) XFree86 Video Timings HOWTO: Overdriving Your Monitor
15.   **[^](https://en.wikipedia.org/wiki/Framebuffer#cite_ref-15 "Jump up")**["An illustrated Guide to the Video Cards"](http://karbosguide.com/hardware/module7b1.htm). _karbosguide.com_.

*   Alvy Ray Smith (May 30, 1997). ["Digital Paint Systems: Historical Overview"](https://web.archive.org/web/20120207124911/https://design.osu.edu/carlson/history/PDFs/14_paint.pdf)(PDF). _Microsoft Tech Memo 14_. Archived from [the original](http://accad.osu.edu/~waynec/history/PDFs/14_paint.pdf)(PDF) on February 7, 2012.
*   Wayne Carlson (2003). ["Hardware advancements"](https://web.archive.org/web/20120314015613/http://design.osu.edu/carlson/history/lesson15.html). _A Critical History of Computer Graphics and Animation_. The Ohio State University. Archived from [the original](http://accad.osu.edu/~waynec/history/lesson15.html) on 2012-03-14.
*   Alvy Ray Smith (2001). ["Digital Paint Systems: An Anecdotal and Historical Overview"](https://web.archive.org/web/20120205050230/https://design.osu.edu/carlson/history/PDFs/paint.pdf)(PDF). IEEE Annals of the History of Computing. Archived from [the original](http://accad.osu.edu/~waynec/history/PDFs/paint.pdf)(PDF) on 2012-02-05.

*   [Interview with NYIT researcher discussing the 24-bit system](https://web.archive.org/web/20060211051810/http://www.acid.org/radio/arts-ep05-transcript.txt)
*   [History of Sun Microsystems' Framebuffers](http://www.sunhelp.org/faq/FrameBufferHistory.html)
