Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Definition 2 Properties 3 Examples Toggle Examples subsection 3.1 Example 1: The bounded μ-operator is a primitive recursive function 3.2 Example 2: The unbounded μ-operator is not primitive-recursive 3.3 Example 3: Definition of the unbounded μ-operator in terms of an abstract machine 4 See also 5 Footnotes Toggle Footnotes subsection 5.1 Total function demonstration 5.2 Alternative abstract machine models of the unbounded μ-operator from Minsky (1967) and Boolos-Burgess-Jeffrey (2002) 6 References Toggle the table of contents μ operator 5 languages Esperanto Italiano Português Українська 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Concept in computability theory In computability theory , the μ-operator , minimization operator , or unbounded search operator searches for the least natural number with a given property. Adding the μ-operator to the primitive recursive functions makes it possible to define all computable functions .

Definition [ edit ] Suppose that R( y , x 1 , ..., x k ) is a fixed ( k +1)-ary relation on the natural numbers . The μ-operator "μ y ", in either the unbounded or bounded form, is a " number theoretic function " defined from the natural numbers to the natural numbers. However, "μ y " contains a predicate over the natural numbers, which can be thought of as a condition that evaluates to true when the predicate is satisfied and false when it is not.

The bounded μ-operator appears earlier in Kleene (1952) Chapter IX Primitive Recursive Functions, §45 Predicates, prime factor representation as: " μ μ y y < z R ( y ) .

The least y < z such that R ( y ) , if ( ∃ ∃ y ) y < z R ( y ) ; otherwise , z .

{\displaystyle \mu y_{y<z}R(y).\ \ {\mbox{The least}}\ y<z\ {\mbox{such that}}\ R(y),\ {\mbox{if}}\ (\exists y)_{y<z}R(y);\ {\mbox{otherwise}},\ z.} " (p. 225) Stephen Kleene notes that any of the six inequality restrictions on the range of the variable y is permitted, i.e.

y < z , y ≤ z , w < y < z , w < y ≤ z , w ≤ y < z and w ≤ y ≤ z . "When the indicated range contains no y such that R( y ) [is "true"], the value of the "μ y " expression is the cardinal number of the range" (p. 226); this is why the default " z " appears in the definition above. As shown below, the bounded μ-operator "μ y y < z " is defined in terms of two primitive recursive functions called the finite sum Σ and finite product Π, a predicate function that "does the test" and a representing function that converts {t, f} to { 0 , 1 }.

In Chapter XI §57 General Recursive Functions, Kleene defines the unbounded μ-operator over the variable y in the following manner, " ( ∃ ∃ y ) μ μ y R ( y ) = { the least (natural number) y such that R ( y ) } {\displaystyle (\exists y)\mu yR(y)=\{{\mbox{the least (natural number)}}\ y\ {\mbox{such that}}\ R(y)\}} " (p. 279, where " ( ∃ ∃ y ) {\displaystyle (\exists y)} " means " there exists a y such that...") In this instance R itself, or its representing function , delivers 0 when it is satisfied (i.e. delivers true ); the function then delivers the number y . No upper bound exists on y , hence no inequality expressions appear in its definition.

For a given R( y ) the unbounded μ-operator μ y R( y ) (note no requirement for " ( ∃ ∃ y ) {\displaystyle (\exists y)} " ) is a partial function . Kleene makes it as a total function instead (cf. p. 317): ε ε y R ( x , y ) = { the least y such that R ( x , y ) , if ( ∃ ∃ y ) R ( x , y ) 0 , otherwise .

{\displaystyle \varepsilon yR(x,y)={\begin{cases}{\text{the least }}y{\text{ such that }}R(x,y),&{\text{if }}(\exists y)R(x,y)\\0,&{\text{otherwise}}.\end{cases}}} The total version of the unbounded μ-operator is studied in higher-order reverse mathematics ( Kohlenbach (2005) ) in the following form: ( ∃ ∃ μ μ 2 ) ( ∀ ∀ f 1 ) ( ( ∃ ∃ n 0 ) ( f ( n ) = 0 ) → → f ( μ μ ( f ) ) = 0 ) , {\displaystyle (\exists \mu ^{2})(\forall f^{1}){\big (}(\exists n^{0})(f(n)=0)\rightarrow f(\mu (f))=0{\big )},} where the superscripts mean that n is zeroth-order, f is first-order, and μ is second-order. This axiom gives rise to the Big Five system ACA 0 when combined with the usual base theory of higher-order reverse mathematics.

[ citation needed ] Properties [ edit ] (i) In context of the primitive recursive functions , where the search variable y of the μ-operator is bounded, e.g.

y < z in the formula below, if the predicate R is primitive recursive (Kleene Proof #E p. 228), then μ y y < z R( y , x 1 , ..., x n ) is a primitive recursive function.

(ii) In the context of the (total) recursive functions , where the search variable y is unbounded but guaranteed to exist for all values x i of the total recursive predicate R's parameters, ( x 1 ),...,( x n ) ( ∃ ∃ y ) {\displaystyle (\exists y)} R( y , x i , ..., x n ) implies that μ y R( y , x i , ..., x n ) is a total recursive function .

Here ( x i ) means "for all x i " and ∃ ∃ y {\displaystyle \exists y} means "there exists at least one value of y such that..." (cf Kleene (1952) p. 279.) then the five primitive recursive operators plus the unbounded-but-total μ-operator give rise to what Kleene called the "general" recursive functions (i.e. total functions defined by the six recursion operators).

(iii) In the context of the partial recursive functions : Suppose that the relation R holds if and only if a partial recursive function converges to zero. And suppose that that partial recursive function converges (to something, not necessarily zero) whenever μ y R( y , x 1 , ..., x k ) is defined and y is μ y R( y , x 1 , ..., x k ) or smaller. Then the function μ y R( y , x 1 , ..., x k ) is also a partial recursive function.

The μ-operator is used in the characterization of the computable functions as the μ recursive functions .

In constructive mathematics , the unbounded search operator is related to Markov's principle .

Examples [ edit ] Example 1: The bounded μ-operator is a primitive recursive function [ edit ] In the following x represents the string x i , ..., x n .

The bounded μ-operator  can be expressed rather simply in terms of two primitive recursive functions (hereafter "prf") that also are used to define the CASE function—the product-of-terms Π and the sum-of-terms Σ (cf Kleene #B page 224). (As needed, any boundary for the variable such as s ≤ t or t < z , or 5 < x < 17 etc. is appropriate). For example: Π s ≤ t f s ( x , s ) = f 0 ( x , 0) × f 1 ( x , 1) × ... × f t ( x , t ) Σ t < z g t ( x , t ) = g 0 ( x , 0) + g 1 ( x , 1) + ... + g z-1 ( x , z -1) Before we proceed we need to introduce a function ψ called "the representing function " of predicate R. Function ψ is defined from inputs (t = "truth", f = "falsity") to outputs (0, 1) ( note the order!

). In this case the input to ψ. i.e. {t, f}. is coming from the output of R: ψ(R = t) = 0 ψ(R = f) = 1 Kleene demonstrates that μ y y < z R( y ) is defined as follows; we see the product function Π is acting like a Boolean OR operator, and the sum Σ is acting somewhat like a Boolean AND but is producing {Σ≠0, Σ=0} rather than just {1, 0}: μ y y < z R( y ) = Σ t < z Π s ≤ t ψ(R( x , t , s )) = [ψ( x , 0, 0)] + [ψ( x , 1, 0) × ψ( x , 1, 1)] + [ψ( x , 2, 0) × ψ( x , 2, 1) × ψ( x , 2, 2)] + ...

+ [ψ( x , z -1, 0) × ψ( x , z -1, 1) × ψ( x , z -1, 2) × . . . × ψ ( x , z -1, z -1)] Note that Σ is actually a primitive recursion with the base Σ( x , 0) = 0 and the induction step Σ( x , y +1) = Σ( x , y ) + Π( x , y ).

The product Π is also a primitive recursion with base step Π( x , 0) = ψ( x , 0) and induction step Π( x , y +1) = Π( x , y ) × ψ( x , y +1).

The equation is easier if observed with an example, as given by Kleene. He just made up the entries for the representing function ψ(R( y )). He designated the representing functions χ( y ) rather than ψ( x , y ): y 0 1 2 3 4 5 6 7= z χ( y ) 1 1 1 0 1 0 0 π( y ) = Π s ≤ y χ( s ) 1 1 1 0 0 0 0 0 σ( y ) = Σ t < y π( t ) 1 2 3 3 3 3 3 3 least y < z such that R( y ) is "true": φ( y ) = μ y y < z R( y ) 3 Example 2: The unbounded μ-operator is not primitive-recursive [ edit ] The unbounded μ-operator—the function μ y —is the one commonly defined in the texts. But the reader may wonder why the unbounded μ-operator is searching for a function R( x , y ) to yield zero , rather than some other natural number.

In a footnote Minsky does allow his operator to terminate when the function inside produces a match to the parameter " k "; this example is also useful because it shows another author's format: "For μ t [φ( t ) = k ]" (p. 210) The reason for zero is that the unbounded operator μ y will be defined in terms of the function "product" Π with its index y allowed to "grow" as the μ-operator searches. As noted in the example above, the product Π x < y of a string of numbers ψ( x , 0) *, ..., * ψ( x , y ) yields zero whenever one of its members ψ( x , i ) is zero: Π s < y = ψ( x , 0) * , ..., * ψ( x , y ) = 0 if any ψ( x , i ) = 0 where 0≤ i ≤ s . Thus the Π is acting like a Boolean AND.

The function μ y produces as "output" a single natural number y = {0, 1, 2, 3, ...}. However, inside the operator one of a couple "situations" can appear: (a) a "number-theoretic function" χ that produces a single natural number, or (b) a "predicate" R that produces either {t = true, f = false}. (And, in the context of partial recursive functions Kleene later admits a third outcome: "μ = undecided".

[ 1 ] ) Kleene splits his definition of the unbounded μ-operator to handle the two situations (a) and (b). For situation (b), before the predicate R( x , y ) can serve in an arithmetic capacity in the product Π, its output {t, f} must first be "operated on" by its representing function χ to yield {0, 1}. And for situation (a) if one definition is to be used then the number theoretic function χ must produce zero to "satisfy" the μ-operator. With this matter settled, he demonstrates with single "Proof III" that either types (a) or (b) together with the five primitive recursive operators yield the (total) recursive functions , with this proviso for a total function : For all parameters x , a demonstration must be provided to show that a y exists that satisfies (a) μ y ψ( x , y ) or (b) μ y R( x , y ).

Kleene also admits a third situation (c) that does not require the demonstration of "for all x a y exists such that ψ( x , y )." He uses this in his proof that more total recursive functions exist than can be enumerated; c.f. footnote Total function demonstration .

Kleene's proof is informal and uses an example similar to the first example, but first he casts the μ-operator into a different form that uses the "product-of-terms" Π operating on function χ that yields a natural number n , which can be any natural number, and 0 in the instance when the u-operator's test is "satisfied".

The definition recast with the Π-function: μ y y < z χ( y ) = (i): π( x , y ) = Π s < y χ( x , s ) (ii): φ( x ) = τ(π( x , y ), π( x , y' ), y ) (iii): τ( z' , 0, y ) = y ;τ( u , v , w ) is undefined for u = 0 or v > 0.

This is subtle. At first glance the equations seem to be using primitive recursion. But Kleene has not provided us with a base step and an induction step of the general form: base step: φ(0, x ) = φ( x ) induction step: φ(0, x ) = ψ(y, φ(0, x ), x ) To see what is going on, we first have to remind ourselves that we have assigned a parameter (a natural number) to every variable x i . Second, we do see a successor-operator at work iterating y (i.e. the y' ). And third, we see that the function μ y y < z χ( y , x ) is just producing instances of χ( y , x ) i.e. χ(0, x ), χ(1, x ), ... until an instance yields 0. Fourth, when an instance χ( n , x ) yields 0 it causes the middle term of τ, i.e. v = π( x , y' ) to yield 0. Finally, when the middle term v = 0, μ y y < z χ( y ) executes line (iii) and "exits". Kleene's presentation of equations (ii) and (iii) have been exchanged to make this point that line (iii) represents  an exit —an exit taken only when the search successfully finds a y to satisfy χ( y ) and the middle product-term π( x , y' ) is 0; the operator then terminates its search with τ( z' , 0, y ) = y .

τ(π( x , y ), π( x , y' ), y ), i.e.: τ(π( x , 0), π( x , 1), 0), τ(π( x , 1), π( x , 2), 1) τ(π( x , 2), π( x , 3), 2) τ(π( x , 3), π( x , 4), 3) ... until a match occurs at y = n and then: τ( z' , 0, y ) = τ( z' , 0, n ) = n and the μ-operator's search is done.

For the example Kleene "...consider[s] any fixed values of ( x i , ..., x n ) and write[s] simply 'χ( y )' for 'χ( x i , ..., x n ), y )'": y 0 1 2 3 4 5 6 7 etc.

χ( y ) 3 1 2 0 9 0 1 5 . . .

π( y ) = Π s ≤ y χ( s ) 1 3 3 6 0 0 0 0 . . .

↑ least y < z such that R( y ) is "true": φ( y ) = μ y y < z R( y ) 3 Example 3: Definition of the unbounded μ-operator in terms of an abstract machine [ edit ] Both Minsky (1967) p. 21 and Boolos-Burgess-Jeffrey (2002) p. 60-61 provide definitions of the μ-operator as an abstract machine; see footnote Alternative definitions of μ .

The following demonstration follows Minsky without the "peculiarity" mentioned in the footnote. The demonstration will use a "successor" counter machine model closely related to the Peano Axioms and the primitive recursive functions . The model consists of (i) a finite state machine with a TABLE of instructions and a so-called 'state register' that we will rename "the Instruction Register" (IR), (ii) a few "registers" each of which can contain only a single natural number, and (iii) an instruction set of four "commands" described in the following table: In the following, the symbolism " [ r ] "  means "the contents of", and " →r " indicates an action with respect to register r.

Instruction Mnemonic Action on register(s) "r" Action on Instruction Register, IR CLeaR register CLR ( r ) 0 → r [ IR ] + 1 → IR INCrement register INC ( r ) [ r ] + 1 → r [ IR ] + 1 → IR Jump if Equal JE (r 1 , r 2 , z) none IF [ r 1 ] = [ r 2 ] THEN z → IR ELSE [ IR ] + 1 → IR Halt H none [ IR ]  → IR The algorithm for the minimization operator μ y [φ( x , y )] will, in essence, create a sequence of instances of the function φ( x , y ) as the value of parameter y (a natural number) increases; the process will continue (see Note † below) until a match occurs between the output of function φ( x , y ) and some pre-established number (usually 0). Thus the evaluation of φ( x , y ) requires, at the outset, assignment of a natural number to each of its variables x and an assignment of a "match-number" (usually 0) to a register " w ", and a number (usually 0) to register y .

Note †: The unbounded μ-operator will continue this attempt-to-match process ad infinitum or until a match occurs. Thus the " y " register must be unbounded -- it must be able to "hold" a number of arbitrary size. Unlike a "real" computer model, abstract machine models allow this. In the case of a bounded μ-operator, a lower-bounded μ-operator would start with the contents of y set to a number other than zero. An upper-bounded μ-operator would require an additional register "ub" to contain the number that represents the upper bound plus an additional comparison operation; an algorithm could provide for both lower- and upper bounds.

In the following we are assuming that the Instruction Register (IR) encounters the μ y "routine" at instruction number " n ". Its first action will be to establish a number in a dedicated " w " register—an "example of" the number that function φ( x , y ) must produce before the algorithm can terminate (classically this is the number zero, but see the footnote about the use of numbers other than zero). The algorithm's next action at instructiton " n +1" will be to clear the " y " register -- " y " will act as an "up-counter" that starts from 0. Then at instruction " n +2" the algorithm evaluates its function φ( x , y ) -- we assume this takes j instructions to accomplish—and at the end of its evaluation φ( x , y) deposits its output in register "φ". At the ( n + j +3)rd instruction the algorithm compares the number in the " w " register (e.g. 0) to the number in the "φ" register—if they are the same the algorithm has succeeded and it escapes through exit ; otherwise it increments the contents of the " y " register and loops back with this new y-value to test function φ( x , y ) again.

IR Instruction Action on register Action on Instruction Register IR n μ y [φ( x , y )]: CLR ( w ) 0 → w [ IR ] + 1 → IR n +1 CLR ( y ) 0 → y [ IR ] + 1 → IR n +2 loop: φ( x , y ) φ([ x ], [ y ]) → φ [ IR ] + j + 1 → IR n + j +3 JE (φ, w , exit) none CASE: { IF [ φ ]=[ w ] THEN exit → IR ELSE [IR] + 1 → IR } n + j +4 INC ( y ) [ y ] + 1 → y [ IR ] + 1 → IR n + j +5 JE (0, 0, loop) Unconditional jump CASE: { IF [ r 0 ] =[ r 0 ] THEN loop → IR ELSE loop → IR } n + j +6 exit: etc.

See also [ edit ] While loop Primitive recursive function General recursive function McCarthy Formalism Footnotes [ edit ] Total function demonstration [ edit ] What is mandatory if the function is to be a total function is a demonstration by some other method (e.g.

induction ) that for each and every combination of values of its parameters x i some natural number y will satisfy the μ-operator so that the algorithm that represents the calculation can terminate: "...we must always hesitate to assume that a system of equations really defines a general-recursive (i.e. total) function. We normally require auxiliary evidence for this, e.g. in the form of an inductive proof that, for each argument value, the computation terminates with a unique value." (Minsky (1967) p.186) "In other words, we should not claim that a function is effectively calculable on the ground that it has been shown to be general (i.e. total) recursive, unless the demonstration that it is general recursive is effective."(Kleene (1952) p.319) For an example of what this means in practice see the examples at mu recursive functions —even the simplest truncated subtraction algorithm " x - y = d " can yield, for the undefined cases when x < y , (1) no termination, (2) no numbers (i.e. something wrong with the format so the yield is not considered a natural number), or (3) deceit: wrong numbers in the correct format. The "proper" subtraction algorithm requires careful attention to all the "cases" ( x , y ) = {(0, 0), ( a , 0), (0, b ), ( a ≥ b , b ), ( a = b , b ), ( a < b , b )}.

But even when the algorithm has been shown to produce the expected output in the instances {(0, 0), (1, 0), (0, 1), (2, 1), (1, 1), (1, 2)}, we are left with an uneasy feeling until we can devise a "convincing demonstration" that the cases ( x , y ) = ( n , m ) all yield the expected results. To Kleene's point: is our "demonstration" (i.e. the algorithm that is our demonstration) convincing enough to be considered effective ?

Alternative abstract machine models of the unbounded μ-operator from Minsky (1967) and Boolos-Burgess-Jeffrey (2002) [ edit ] The unbounded μ-operator is defined by Minsky (1967) p. 210 but with a peculiar flaw: the-operator will not yield t =0 when its predicate (the IF-THEN-ELSE test) is satisfied; rather it yields t =2. In Minsky's version the counter is " t ", and the function φ( t , x ) deposits its number in register φ. In the usual μ definition register w will contain 0, but Minsky observes that it can contain any number k . Minsky's instruction set is equivalent to the following where "JNE" = Jump to z if Not Equal: { CLR ( r ), INC ( r ), JNE ( r j , r k , z ) } IR Instruction Action on register Action on Instruction Register, IR n μ y φ( x ): CLR ( w ) 0 → w [ IR ] + 1 → IR n + 1 CLR ( t ) 0 → t [ IR ] + 1 → IR n +2 loop: φ ( y , x ) φ( [ t ], [ x ] ) → φ [ IR ] + j + 1 → IR n + j +3 INC ( t ) [ t ] + 1 → t [ IR ] + 1 → IR n + j +4 JNE (φ, w , loop) none CASE: {  IF [φ] ≠ [ w ] THEN "exit" → IR ELSE [IR] + 1 → IR } n + j +5 INC ( t ) [ t ] + 1 → t [ IR ] + 1 → IR n + j +6 exit: etc.

The unbounded μ-operator is also defined by Boolos-Burgess-Jeffrey (2002) p. 60-61 for a counter machine with an instruction set equivalent to the following: { CLR (r), INC (r), DEC (r), JZ (r, z), H } In this version the counter "y" is called "r2", and the function f( x , r2 ) deposits its number in register "r3". Perhaps the reason Boolos-Burgess-Jeffrey clear r3 is to facilitate an unconditional jump to loop ; this is often done by use of a dedicated register "0" that contains "0": IR Instruction Action on register Action on Instruction Register, IR n μ r 2 [f( x , r 2 )]: CLR ( r 2 ) 0 → r 2 [ IR ] + 1 → IR n +1 loop: f( y , x ) f( [ t ], [ x ] ) → r 3 [ IR ] + j + 1 → IR n +2 JZ ( r 3 , exit ) none IF [ r 3 ] = 0 THEN exit → IR ELSE [ IR ] + 1 → IR n + j +3 CLR ( r 3 ) 0 → r 3 [ IR ] + 1 → IR n + j +4 INC ( r 2 ) [ r 2 ] + 1 → r 2 [ IR ] + 1 → IR n + j +5 JZ ( r 3 , loop) CASE: { IF [ r 3 ] = 0 THEN loop → IR ELSE [IR] + 1 → IR } n + j +6 exit: etc.

References [ edit ] ^ pp. 332ff Kleene, Stephen (2009) [1952], Introduction to Metamathematics , North-Holland, ISBN 9780923891572 , OCLC 935015457 Kohlenbach, Ulrich (2005), Higher Order Reverse Mathematics, Reverse Mathematics 2001 , Lecture notes in Logic, Cambridge University Press , pp.

281– 295, CiteSeerX 10.1.1.643.551 , doi : 10.1017/9781316755846.018 , ISBN 9781316755846 Minsky, Marvin L.

(1972) [1967], Computation: Finite and Infinite Machines , Prentice-Hall, ISBN 9780131654495 , OCLC 974146753 On pages 210-215 Minsky shows how to create the μ-operator using the register machine model, thus demonstrating its equivalence to the general recursive functions .

Boolos, George ; Burgess, John ; Jeffrey, Richard (2002), "S6.2 Minimization" , Computability and Logic (4th ed.), Cambridge University Press, pp.

70– 71, ISBN 9780521701464 Retrieved from " https://en.wikipedia.org/w/index.php?title=Μ_operator&oldid=1264000951 " Category : Computability theory Hidden categories: Articles with short description Short description matches Wikidata All articles with unsourced statements Articles with unsourced statements from November 2022 This page was last edited on 19 December 2024, at 21:41 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents μ operator 5 languages Add topic

