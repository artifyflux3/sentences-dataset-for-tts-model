Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Equality Toggle Equality subsection 1.1 Usage 1.2 Location equality vs. content equality 1.3 Comparing values of different types 2 Ordering 3 Logical equivalence 4 Standard relational operators 5 Syntax Toggle Syntax subsection 5.1 Operator chaining 5.2 Confusion with assignment operators 5.2.1 B and C 5.2.2 Languages 6 See also 7 Notes and references Toggle the table of contents Relational operator 12 languages Azərbaycanca Deutsch Eesti Español فارسی 한국어 Қазақша 日本語 Polski Русский Suomi 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Programming language construct "Comparison (computer programming)" redirects here. For comparison of files, see File comparison .

"~=" redirects here. For the mathematical usage, see approximation . For abstract algebra, see Isomorphism .

This article needs additional citations for verification .

Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed.

Find sources: "Relational operator" – news · newspapers · books · scholar · JSTOR ( March 2022 ) ( Learn how and when to remove this message ) In computer science , a relational operator is a programming language construct or operator that tests or defines some kind of relationship between two entities. These include numerical equality (e.g., 5 = 5 ) and inequalities (e.g., 4 ≥ 3 ).

In programming languages that include a distinct boolean data type in their type system , like Pascal , Ada , Python or Java , these operators usually evaluate to true or false, depending on if the conditional relationship between the two operands holds or not.

In languages such as C , relational operators return the integers 0 or 1, where 0 stands for false and any non-zero value stands for true.

An expression created using a relational operator forms what is termed a relational expression or a condition . Relational operators can be seen as special cases of logical predicates .

Equality [ edit ] Usage [ edit ] Equality is used in many programming language constructs and data types. It is used to test if an element already exists in a set , or to access to a value through a key. It is used in switch statements to dispatch the control flow to the correct branch, and during the unification process in logic programming.

There can be multiple valid definitions of equality, and any particular language might adopt one or more of them, depending on various design aspects. One possible meaning of equality is that "if a equals b , then either a or b can be used interchangeably in any context without noticing any difference". But this statement does not necessarily hold, particularly when taking into account mutability together with content equality.

Location equality vs. content equality [ edit ] Sometimes, particularly in object-oriented programming , the comparison raises questions of data types and inheritance , equality , and identity . It is often necessary to distinguish between: two different objects of the same type, e.g., two hands two objects being equal but distinct, e.g., two $10 banknotes two objects being equal but having different representation, e.g., a $1 bill and a $1 coin two different references to the same object, e.g., two nicknames for the same person In many modern programming languages, objects and data structures are accessed through references . In such languages, there becomes a need to test for two different types of equality: Location equality (identity): if two references (A and B) reference the same object. Interactions with the object through A are indistinguishable from the same interactions through B, and in particular changes to the object through A are reflected through B.

Content equality: if the objects referenced by two references (A and B) are equivalent in some sense: Structural equality (that is, their contents are the same). which may be either shallow (testing only immediate subparts), or deep (testing for equality of subparts recursively). A simple way to achieve this is through representational equality: checking that the values have the same representation.

Some other tailor-made equality, preserving the external behavior. For example, 1/2 and 2/4 are considered equal when seen as a rational number. A possible requirement would be that "A = B if and only if all operations on objects A and B will have the same result", in addition to reflexivity , symmetry , and transitivity .

The first type of equality usually implies the second (except for things like not a number ( NaN ) which are unequal to themselves), but the converse is not necessarily true. For example, two string objects may be distinct objects (unequal in the first sense) but contain the same sequence of characters (equal in the second sense). See identity for more of this issue.

Real numbers, including many simple fractions , cannot be represented exactly in floating-point arithmetic , and it may be necessary to test for equality within a given tolerance. Such tolerance, however, can easily break desired properties such as transitivity, whereas reflexivity breaks too: the IEEE floating-point standard requires that NaN ≠ NaN holds. In contrast, the (2022) private standard for posit arithmetic (posit proponents mean to replace IEEE floats) has a similar concept, NaR (Not a Real), where NaR = NaR holds.

[ 1 ] Other programming elements such as computable functions, may either have no sense of equality, or an equality that is uncomputable. For these reasons, some languages define an explicit notion of "comparable", in the form of a base class, an interface, a trait or a protocol, which is used either explicitly, by declaration in source code, or implicitly, via the structure of the type involved.

Comparing values of different types [ edit ] In JavaScript , PHP , VBScript and a few other dynamically typed languages, the standard equality operator follows so-called loose typing , that is it evaluates to true even if two values are not equal and are of incompatible types, but can be coerced to each other by some set of language-specific rules, making the number 4 compare equal to the text string "4", for instance. Although such behaviour is typically meant to make the language easier, it can lead to surprising and difficult to predict consequences that many programmers are unaware of. For example, JavaScript's loose equality rules can cause equality to be intransitive (i.e., a == b and b == c , but a != c ), or make certain values be equal to their own negation.

[ 2 ] A strict equality operator is also often available in those languages, returning true only for values with identical or equivalent types (in PHP, 4 === "4" is false although 4 == "4" is true).

[ 3 ] [ 4 ] For languages where the number 0 may be interpreted as false , this operator may simplify things such as checking for zero (as x == 0 would be true for x being either 0 or "0" using the type agnostic equality operator).

Ordering [ edit ] Greater than and less than comparison of non-numeric data is performed according to a sort convention (such as, for text strings, lexicographical order ) which may be built into the programming language and/or configurable by a programmer.

When it is desired to associate a numeric value with the result of a comparison between two data items, say a and b , the usual convention is to assign −1 if a < b, 0 if a = b and 1 if a > b. For example, the C function strcmp performs a three-way comparison and returns −1, 0, or 1 according to this convention, and qsort expects the comparison function to return values according to this convention. In sorting algorithms , the efficiency of comparison code is critical since it is one of the major factors contributing to sorting performance.

Comparison of programmer-defined data types (data types for which the programming language has no in-built understanding) may be carried out by custom-written or library functions (such as strcmp mentioned above), or, in some languages, by overloading a comparison operator – that is, assigning a programmer-defined meaning that depends on the data types being compared. Another alternative is using some convention such as member-wise comparison.

Logical equivalence [ edit ] Though perhaps unobvious at first, like the boolean logical operators XOR, AND, OR, and NOT, relational operators can be designed to have logical equivalence , such that they can all be defined in terms of one another. The following four conditional statements all have the same logical equivalence E (either all true or all false) for any given x and y values: E = { x < y y > x x ≱ ≱ y y ≰ ≰ x {\displaystyle E={\begin{cases}x<y\\y>x\\x\ngeq y\\y\nleq x\end{cases}}} This relies on the domain being well ordered .

Standard relational operators [ edit ] The most common numerical relational operators used in programming languages are shown below. Standard SQL uses the same operators as BASIC, while many databases allow != in addition to <> from the standard. SQL follows strict boolean algebra , i.e. doesn't use short-circuit evaluation , which is common to most languages below. E.g.

PHP has it, but otherwise it has these same two operators defined as aliases, like many SQL databases.

Common relational operators Convention equal to not equal to greater than less than greater than or equal to less than or equal to In print = ≠ > < ≥ ≤ FORTRAN [ note 1 ] .EQ.

.NE.

.GT.

.LT.

.GE.

.LE.

ALGOL 68 [ note 2 ] = ≠ > < ≥ ≤ /= >= <= eq ne gt lt ge le APL = ≠ > < ≥ ≤ BASIC , ML , Pascal [ note 3 ] = <> [ note 4 ] > < >= <= C-like [ note 5 ] == != > < >= <= MUMPS = '= > < '< '> Lua == ~= > < >= <= Erlang == /= > < >= =< =:= =/= Bourne-like shells [ note 6 ] -eq -ne -gt -lt -ge -le Batch file EQU NEQ GTR LSS GEQ LEQ ooRexx , REXX = ¬= > < >= <= \= <> MATLAB [ note 7 ] == ~= > < >= <= eq(x,y) ne(x,y) gt(x,y) lt(x,y) ge(x,y) le(x,y) Fortran 90 , [ note 8 ] Haskell == /= > < >= <= Mathematica [ 5 ] == != > < >= <= Equal[x,y] Unequal[x,y] Greater[x,y] Less[x,y] GreaterEqual[x,y] LessEqual[x,y] ^ Including FORTRAN II, III, IV, 66 and 77.

^ ALGOL 68 : stropping regimes are used in code on platforms with limited character sets ( e.g.

, use >= or GE instead of ≥ ), platforms with no bold emphasis (use 'ge' ), or platforms with only UPPERCASE (use .GE or 'GE' ).

^ Including ALGOL , Simula , Modula-2 , Eiffel , SQL , spreadsheet formulas , and others.

^ Modula-2 also recognizes # ^ Including C , C++ , C# , Go , Java , JavaScript , Perl (numerical comparison only), PHP , Python , Ruby , and R .

^ Including Bourne shell , Bash , KornShell , and Windows PowerShell . The symbols < and > are usually used in a shell for redirection , so other symbols must be used. Without the hyphen, is used in Perl for string comparison.

^ MATLAB, although in other respects using similar syntax as C, does not use != , as !

in MATLAB sends the following text as a command line to the operating system . The first form is also used in Smalltalk , with the exception of equality, which is = .

^ Including FORTRAN 95, 2003, 2008 and 2015.

Other conventions are less common: Common Lisp and Macsyma / Maxima use Basic-like operators for numerical values, except for inequality, which is /= in Common Lisp and # in Macsyma/Maxima. Common Lisp has multiple other sets of equality and relational operators serving different purposes, including eq , eql , equal , equalp , and string= .

[ 6 ] Older Lisps used equal , greaterp , and lessp ; and negated them using not for the remaining operators.

Syntax [ edit ] Relational operators are also used in technical literature instead of words. Relational operators are usually written in infix notation , if supported by the programming language, which means that they appear between their operands (the two expressions being related). For example, an expression in Python will print the message if the x is less than y : if x < y : print ( "x is less than y in this example" ) Other programming languages, such as Lisp , use prefix notation , as follows: ( >= X Y ) Operator chaining [ edit ] In mathematics, it is common practice to chain relational operators, such as in 3 < x < y < 20 (meaning 3 < x and x < y and y < 20). The syntax is clear since these relational operators in mathematics are transitive.

However, many recent programming languages would see an expression like 3 < x < y as consisting of two left (or right-) associative operators, interpreting it as something like (3 < x) < y . If we say that x=4, we then get (3 < 4) < y , and evaluation will give true < y which generally does not make sense. However, it does compile in C/C++ and some other languages, yielding surprising result (as true would be represented by the number 1 here).

It is possible to give the expression x < y < z its familiar mathematical meaning, and some programming languages such as Python and Raku do that. Others, such as C# and Java, do not, partly because it would differ from the way most other infix operators work in C-like languages. The D programming language does not do that since it maintains some compatibility with C, and "Allowing C expressions but with subtly different semantics (albeit arguably in the right direction) would add more confusion than convenience".

[ 7 ] Some languages, like Common Lisp , use multiple argument predicates for this. In Lisp (<= 1 x 10) is true when x is between 1 and 10.

Confusion with assignment operators [ edit ] See also: Assignment (computer science) § Assignment versus equality Early FORTRAN (1956–57) was bounded by heavily restricted character sets where = was the only relational operator available. There were no < or > (and certainly no ≤ or ≥ ). This forced the designers to define symbols such as .GT.

, .LT.

, .GE.

, .EQ.

etc. and subsequently made it tempting to use the remaining = character for copying, despite the obvious incoherence with mathematical usage ( X=X+1 should be impossible).

International Algebraic Language (IAL, ALGOL 58 ) and ALGOL (1958 and 1960) thus introduced := for assignment, leaving the standard = available for equality, a convention followed by CPL , ALGOL W , ALGOL 68 , Basic Combined Programming Language ( BCPL ), Simula , SET Language ( SETL ), Pascal , Smalltalk , Modula-2 , Ada , Standard ML , OCaml , Eiffel , Object Pascal ( Delphi ), Oberon , Dylan , VHSIC Hardware Description Language ( VHDL ), and several other languages.

B and C [ edit ] This uniform de facto standard among most programming languages was eventually changed, indirectly, by a minimalist compiled language named B . Its sole intended application was as a vehicle for a first port of (a then very primitive) Unix , but it also evolved into the very influential C language.

B started off as a syntactically changed variant of the systems programming language BCPL , a simplified (and typeless) version of CPL . In what has been described as a "strip-down" process, the and and or operators of BCPL [ 8 ] were replaced with & and | (which would later become && and || , respectively.

[ 9 ] ). In the same process, the ALGOL style := of BCPL was replaced by = in B. The reason for all this being unknown.

[ 10 ] As variable updates had no special syntax in B (such as let or similar) and were allowed in expressions, this non standard meaning of the equal sign meant that the traditional semantics of the equal sign now had to be associated with another symbol.

Ken Thompson used the ad hoc == combination for this.

As a small type system was later introduced, B then became C. The popularity of this language along with its association with Unix, led to Java, C#, and many other languages following suit, syntactically, despite this needless conflict with the mathematical meaning of the equal sign.

Languages [ edit ] Assignments in C have a value and since any non-zero scalar value is interpreted as true in conditional expressions , [ 11 ] the code if (x = y) is legal, but has a very different meaning from if (x == y) . The former code fragment means "assign y to x , and if the new value of x is not zero, execute the following statement". The latter fragment means " if and only if x is equal to y , execute the following statement".

[ 12 ] int x = 1 ; int y = 2 ; if ( x = y ) { /* This code will always execute if y is anything but 0*/ printf ( "x is %d and y is %d \n " , x , y ); } Though Java and C# have the same operators as C, this mistake usually causes a compile error in these languages instead, because the if-condition must be of type boolean , and there is no implicit way to convert from other types ( e.g.

, numbers) into boolean s. So unless the variable that is assigned to has type boolean (or wrapper type Boolean ), there will be a compile error.

In ALGOL-like languages such as Pascal, Delphi, and Ada (in the sense that they allow nested function definitions ), and in Python , and many functional languages, among others, assignment operators cannot appear in an expression (including if clauses), thus precluding this class of error. Some compilers, such as GNU Compiler Collection (GCC), provide a warning when compiling code containing an assignment operator inside an if statement, though there are some legitimate uses of an assignment inside an if-condition. In such cases, the assignment must be wrapped in an extra pair of parentheses explicitly, to avoid the warning.

Similarly, some languages, such as BASIC use just the = symbol for both assignment and equality, as they are syntactically separate (as with Pascal, Ada, Python, etc., assignment operators cannot appear in expressions).

Some programmers get in the habit of writing comparisons against a constant in the reverse of the usual order: if ( 2 == a ) { /* Mistaken use of = versus == would be a compile-time error */ } If = is used accidentally, the resulting code is invalid because 2 is not a variable. The compiler will generate an error message, on which the proper operator can be substituted. This coding style is termed left-hand comparison, or Yoda conditions .

This table lists the different mechanisms to test for these two types of equality in various languages: Language Physical equality Structural equality Notes ALGOL 68 a :=: b or a is b a = b when a and b are pointers C , C++ a == b *a == *b when a and b are pointers C# object.ReferenceEquals(a, b) a.Equals(b) The == operator defaults to ReferenceEquals , but can be overloaded to perform Equals instead.

Common Lisp (eq a b) (equal a b) Erlang a =:= b a == b when a and b are numbers Go a == b reflect.DeepEqual(*a, *b) when a and b are pointers Java a == b a.equals(b) JavaScript a === b a == b when a and b are two string objects containing equivalent characters, the === operator will still return true.

OCaml , Smalltalk a == b a = b Pascal a^ = b^ a = b Perl $a == $b $$a == $$b when $a and $b are references to scalars PHP $a === $b $a == $b when $a and $b are objects Python a is b a == b Ruby a.equal?(b) a == b Scheme (eq? a b) (equal? a b) Swift a === b a == b when a and b have class type Visual Basic .NET [ inequality 1 ] a Is b or object.ReferenceEquals(a, b) a = b or a.Equals(b) Same as C# Objective-C ( Cocoa , GNUstep ) a == b [a isEqual:b] when a and b are pointers to objects that are instances of NSObject ^ Patent application: On May 14, 2003, US application 20,040,230,959 "IS NOT OPERATOR" was filed for the ISNOT operator by employees of Microsoft .  This patent was granted on November 18, 2004.

Ruby uses a === b to mean "b is a member of the set a", though the details of what it means to be a member vary considerably depending on the data types involved.

=== is here known as the "case equality" or "case subsumption" operator.

See also [ edit ] Binary relation Common operator notation Conditional (computer programming) Equality (mathematics) Equals sign Logical operator Operation (mathematics) Operator (mathematics) Operator (computer programming) Spaceship operator Triadic relation Notes and references [ edit ] ^ Standard for Posit Arithmetic (2022) ^ Denys, Dovhan.

"WTFJS" .

GitHub . Retrieved July 25, 2024 .

^ "Comparing Objects" .

PHP Manual . PHP Group . Retrieved June 29, 2014 .

^ "PHP: Comparison Operators - Manual" . Retrieved July 31, 2008 .

^ Relational and Logical Operators of Mathematica ^ "Why are there so many ways to compare for equality?" .

Stack Overflow . Retrieved July 25, 2024 .

^ Alexandrescu, Andrei (2010).

The D Programming Language . Addison Wesley. p. 58.

ISBN 978-0-321-63536-5 .

^ Used not only in ALGOL-like languages, but also in FORTRAN and BASIC ^ As some programmers were confused by the dual meanings (bitwise operator, and logical connective) of these new symbols (according to Dennis Ritchie ). Only the bitwise meaning of & and | were kept.

^ Although Dennis Ritchie has suggested that this may have had to do with "economy of typing" as updates of variables may be more frequent than comparisons in certain types of programs ^ A zero scalar value is interpreted as false while any non-zero scalar value is interpreted as true; this is typically used with integer types, similar to assembly language idioms.

^ Brian Kernighan and Dennis Ritchie (1988) [1978].

The C Programming Language (Second ed.). Prentice Hall.

, 19 NewPP limit report
Parsed by mw‐api‐ext.codfw.main‐5cf8f5fb49‐rspbz
Cached time: 20250812014425
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.257 seconds
Real time usage: 0.372 seconds
Preprocessor visited node count: 1362/1000000
Revision size: 28676/2097152 bytes
Post‐expand include size: 22052/2097152 bytes
Template argument size: 1242/2097152 bytes
Highest expansion depth: 12/100
Expensive parser function count: 13/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 35530/5000000 bytes
Lua time usage: 0.126/10.000 seconds
Lua memory usage: 5716030/52428800 bytes
Number of Wikibase entities loaded: 0/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  268.920      1 -total
 41.69%  112.114      3 Template:Reflist
 27.08%   72.833      4 Template:Cite_web
 21.54%   57.929      1 Template:Short_description
 17.38%   46.726      1 Template:More_citations_needed
 15.99%   43.001      1 Template:Ambox
 13.41%   36.049      2 Template:Pagetype
  8.98%   24.143      2 Template:Redirect
  4.82%   12.974      6 Template:Main_other
  4.40%   11.826      2 Template:Cite_book Saved in parser cache with key enwiki:pcache:1202168:|#|:idhash:canonical and timestamp 20250812014425 and revision id 1300603770. Rendering was triggered because: api-parse Retrieved from " https://en.wikipedia.org/w/index.php?title=Relational_operator&oldid=1300603770 " Categories : Operators (programming) Binary operations Comparison (mathematical) Hidden categories: Articles with short description Short description is different from Wikidata Articles needing additional references from March 2022 All articles needing additional references Use mdy dates from June 2014 Articles with example C code This page was last edited on 15 July 2025, at 09:18 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Relational operator 12 languages Add topic

