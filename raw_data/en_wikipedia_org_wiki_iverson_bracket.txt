Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Properties 2 Examples Toggle Examples subsection 2.1 Double-counting rule 2.2 Summation interchange 2.3 Counting 2.4 Simplification of special cases 2.5 Common functions 3 Formulation in terms of usual functions 4 Notational variations 5 See also 6 References Toggle the table of contents Iverson bracket 15 languages Deutsch Español Français Galego 한국어 Italiano עברית 日本語 Polski Português Русский Slovenčina Svenska Українська 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Mathematical notation In mathematics , the Iverson bracket , named after Kenneth E. Iverson , is a notation that generalises the Kronecker delta , which is the Iverson bracket of the statement x = y . It maps any statement to a function of the free variables in that statement. This function is defined to take the value 1 for the values of the variables for which the statement is true, and takes the value 0 otherwise. It is generally denoted by putting the statement inside square brackets: [ P ] = { 1 if P is true; 0 otherwise.

{\displaystyle [P]={\begin{cases}1&{\text{if }}P{\text{ is true;}}\\0&{\text{otherwise.}}\end{cases}}} In other words, the Iverson bracket of a statement is the indicator function of the set of values for which the statement is true.

The Iverson bracket allows using capital-sigma notation without restriction on the summation index. That is, for any property P ( k ) {\displaystyle P(k)} of the integer k {\displaystyle k} , one can rewrite the restricted sum ∑ ∑ k : P ( k ) f ( k ) {\displaystyle \sum _{k:P(k)}f(k)} in the unrestricted form ∑ ∑ k f ( k ) ⋅ ⋅ [ P ( k ) ] {\displaystyle \sum _{k}f(k)\cdot [P(k)]} .  With this convention, f ( k ) {\displaystyle f(k)} does not need to be defined for the values of k for which the Iverson bracket equals 0 ; that is, a summand f ( k ) [ false ] {\displaystyle f(k)[{\textbf {false}}]} must evaluate to 0 regardless of whether f ( k ) {\displaystyle f(k)} is defined.

The notation was originally introduced by Kenneth E. Iverson in his programming language APL , [ 1 ] [ 2 ] though restricted to single relational operators enclosed in parentheses, while the generalisation to arbitrary statements,  notational restriction to square brackets, and applications to summation, was advocated by Donald Knuth to avoid ambiguity in parenthesized logical expressions.

[ 3 ] Properties [ edit ] There is a direct correspondence between arithmetic involving Iverson brackets, logical expressions, and set operations. For instance, let A and B be sets, and let P ( k 1 , … … ) {\displaystyle P(k_{1},\dots )} and Q ( k 1 , … … ) {\displaystyle Q(k_{1},\dots )} be  properties of integers; then we have [ P ∧ ∧ Q ] = [ P ] [ Q ] ; [ P ∨ ∨ Q ] = [ P ] + [ Q ] − − [ P ] [ Q ] ; [ ¬ ¬ P ] = 1 − − [ P ] ; [ P XOR Q ] = | [ P ] − − [ Q ] | ; [ k ∈ ∈ A ] + [ k ∈ ∈ B ] = [ k ∈ ∈ A ∪ ∪ B ] + [ k ∈ ∈ A ∩ ∩ B ] ; [ x ∈ ∈ A ∩ ∩ B ] = [ x ∈ ∈ A ] [ x ∈ ∈ B ] ; [ ∀ ∀ m : P ( k , m ) ] = ∏ ∏ m [ P ( k , m ) ] ; [ ∃ ∃ m : P ( k , m ) ] = min { 1 , ∑ ∑ m [ P ( k , m ) ] } = 1 − − ∏ ∏ m [ ¬ ¬ P ( k , m ) ] ; # # { m | P ( k , m ) } = ∑ ∑ m [ P ( k , m ) ] .

{\displaystyle {\begin{aligned}[][\,P\land Q\,]~&=~[\,P\,]\,[\,Q\,]~~;\\[1em][\,P\lor Q\,]~&=~[\,P\,]\;+\;[\,Q\,]\;-\;[\,P\,]\,[\,Q\,]~~;\\[1em][\,\neg \,P\,]~&=~1-[\,P\,]~~;\\[1em][\,P{\scriptstyle {\mathsf {\text{ XOR }}}}Q\,]~&=~{\Bigl |}\,[\,P\,]\;-\;[\,Q\,]\,{\Bigr |}~~;\\[1em][\,k\in A\,]\;+\;[\,k\in B\,]~&=~[\,k\in A\cup B\,]\;+\;[\,k\in A\cap B\,]~~;\\[1em][\,x\in A\cap B\,]~&=~[\,x\in A\,]\,[\,x\in B\,]~~;\\[1em][\,\forall \,m\ :\,P(k,m)\,]~&=~\prod _{m}\,[\,P(k,m)\,]~~;\\[1em][\,\exists \,m\ :\,P(k,m)\,]~&=~\min {\Bigl \{}\;1\,,\,\sum _{m}\,[\,P(k,m)\,]\;{\Bigr \}}=1\;-\;\prod _{m}\,[\,\neg \,P(k,m)\,]~~;\\[1em]\#{\Bigl \{}\;m\,{\Big |}\,P(k,m)\;{\Bigr \}}~&=~\sum _{m}\,[\,P(k,m)\,]~~.\end{aligned}}} Examples [ edit ] The notation allows moving boundary conditions of summations (or integrals) as a separate factor into the summand, freeing up space around the summation operator, but more importantly allowing it to be manipulated algebraically.

Double-counting rule [ edit ] We mechanically derive a well-known sum manipulation rule using Iverson brackets: ∑ ∑ k ∈ ∈ A f ( k ) + ∑ ∑ k ∈ ∈ B f ( k ) = ∑ ∑ k f ( k ) [ k ∈ ∈ A ] + ∑ ∑ k f ( k ) [ k ∈ ∈ B ] = ∑ ∑ k f ( k ) ( [ k ∈ ∈ A ] + [ k ∈ ∈ B ] ) = ∑ ∑ k f ( k ) ( [ k ∈ ∈ A ∪ ∪ B ] + [ k ∈ ∈ A ∩ ∩ B ] ) = ∑ ∑ k ∈ ∈ A ∪ ∪ B f ( k ) + ∑ ∑ k ∈ ∈ A ∩ ∩ B f ( k ) .

{\displaystyle {\begin{aligned}\sum _{k\in A}f(k)+\sum _{k\in B}f(k)&=\sum _{k}f(k)\,[k\in A]+\sum _{k}f(k)\,[k\in B]\\&=\sum _{k}f(k)\,([k\in A]+[k\in B])\\&=\sum _{k}f(k)\,([k\in A\cup B]+[k\in A\cap B])\\&=\sum _{k\in A\cup B}f(k)\ +\sum _{k\in A\cap B}f(k).\end{aligned}}} Summation interchange [ edit ] The well-known rule ∑ ∑ j = 1 n ∑ ∑ k = 1 j f ( j , k ) = ∑ ∑ k = 1 n ∑ ∑ j = k n f ( j , k ) {\textstyle \sum _{j=1}^{n}\sum _{k=1}^{j}f(j,k)=\sum _{k=1}^{n}\sum _{j=k}^{n}f(j,k)} is likewise easily derived: ∑ ∑ j = 1 n ∑ ∑ k = 1 j f ( j , k ) = ∑ ∑ j , k f ( j , k ) [ 1 ≤ ≤ j ≤ ≤ n ] [ 1 ≤ ≤ k ≤ ≤ j ] = ∑ ∑ j , k f ( j , k ) [ 1 ≤ ≤ k ≤ ≤ j ≤ ≤ n ] = ∑ ∑ j , k f ( j , k ) [ 1 ≤ ≤ k ≤ ≤ n ] [ k ≤ ≤ j ≤ ≤ n ] = ∑ ∑ k = 1 n ∑ ∑ j = k n f ( j , k ) .

{\displaystyle {\begin{aligned}\sum _{j=1}^{n}\,\sum _{k=1}^{j}f(j,k)&=\sum _{j,k}f(j,k)\,[1\leq j\leq n]\,[1\leq k\leq j]\\&=\sum _{j,k}f(j,k)\,[1\leq k\leq j\leq n]\\&=\sum _{j,k}f(j,k)\,[1\leq k\leq n]\,[k\leq j\leq n]\\&=\sum _{k=1}^{n}\,\sum _{j=k}^{n}f(j,k).\end{aligned}}} Counting [ edit ] For instance, Euler's totient function that counts the number of positive integers up to n which are coprime to n can be expressed by φ φ ( n ) = ∑ ∑ i = 1 n [ gcd ( i , n ) = 1 ] , for n ∈ ∈ N + .

{\displaystyle \varphi (n)=\sum _{i=1}^{n}[\gcd(i,n)=1],\qquad {\text{for }}n\in \mathbb {N} ^{+}.} Simplification of special cases [ edit ] Another use of the Iverson bracket is to simplify equations with special cases. For example, the formula ∑ ∑ 1 ≤ ≤ k ≤ ≤ n gcd ( k , n ) = 1 k = 1 2 n φ φ ( n ) {\displaystyle \sum _{1\leq k\leq n \atop \gcd(k,n)=1}\!\!k={\frac {1}{2}}n\varphi (n)} is valid for n > 1 but is off by ⁠ 1 / 2 ⁠ for n = 1 . To get an identity valid for all positive integers n (i.e., all values for which φ φ ( n ) {\displaystyle \varphi (n)} is defined), a correction term involving the Iverson bracket may be added: ∑ ∑ 1 ≤ ≤ k ≤ ≤ n gcd ( k , n ) = 1 k = 1 2 n ( φ φ ( n ) + [ n = 1 ] ) {\displaystyle \sum _{1\leq k\leq n \atop \gcd(k,n)=1}\!\!k={\frac {1}{2}}n{\Big (}\varphi (n)+[n=1]{\Big )}} Common functions [ edit ] Many common functions, especially those with a natural piecewise definition, may be expressed in terms of the Iverson bracket.  The Kronecker delta notation is a specific case of Iverson notation when the condition is equality. That is, δ δ i j = [ i = j ] .

{\displaystyle \delta _{ij}=[i=j].} The indicator function of a set A {\displaystyle A} , often denoted 1 A ( x ) {\displaystyle \mathbf {1} _{A}(x)} , I A ( x ) {\displaystyle \mathbf {I} _{A}(x)} or χ χ A ( x ) {\displaystyle \chi _{A}(x)} , is an Iverson bracket with set membership as its condition: I A ( x ) = [ x ∈ ∈ A ] .

{\displaystyle \mathbf {I} _{A}(x)=[x\in A].} The Heaviside step function , sign function , [ 1 ] and absolute value function are also easily expressed in this notation: H ( x ) = [ x ≥ ≥ 0 ] , sgn ⁡ ⁡ ( x ) = [ x > 0 ] − − [ x < 0 ] , {\displaystyle {\begin{aligned}H(x)&=[x\geq 0],\\\operatorname {sgn}(x)&=[x>0]-[x<0],\end{aligned}}} and | x | = x [ x > 0 ] − − x [ x < 0 ] = x ( [ x > 0 ] − − [ x < 0 ] ) = x ⋅ ⋅ sgn ⁡ ⁡ ( x ) .

{\displaystyle {\begin{aligned}|x|&=x[x>0]-x[x<0]\\&=x([x>0]-[x<0])\\&=x\cdot \operatorname {sgn}(x).\end{aligned}}} The comparison functions max and min (returning the larger or smaller of two arguments) may be written as max ( x , y ) = x [ x > y ] + y [ x ≤ ≤ y ] {\displaystyle \max(x,y)=x[x>y]+y[x\leq y]} and min ( x , y ) = x [ x ≤ ≤ y ] + y [ x > y ] .

{\displaystyle \min(x,y)=x[x\leq y]+y[x>y].} The floor and ceiling functions can be expressed as ⌊ ⌊ x ⌋ ⌋ = ∑ ∑ n n ⋅ ⋅ [ n ≤ ≤ x < n + 1 ] {\displaystyle \lfloor x\rfloor =\sum _{n}n\cdot [n\leq x<n+1]} and ⌈ ⌈ x ⌉ ⌉ = ∑ ∑ n n ⋅ ⋅ [ n − − 1 < x ≤ ≤ n ] , {\displaystyle \lceil x\rceil =\sum _{n}n\cdot [n-1<x\leq n],} where the index n {\displaystyle n} of summation is understood to range over all the integers.

The ramp function can be expressed R ( x ) = x ⋅ ⋅ [ x ≥ ≥ 0 ] .

{\displaystyle R(x)=x\cdot [x\geq 0].} The trichotomy of the reals is equivalent to the following identity: [ a < b ] + [ a = b ] + [ a > b ] = 1.

{\displaystyle [a<b]+[a=b]+[a>b]=1.} The Möbius function has the property (and can be defined by recurrence as [ 4 ] ) ∑ ∑ d | n μ μ ( d ) = [ n = 1 ] .

{\displaystyle \sum _{d|n}\mu (d)\ =\ [n=1].} Formulation in terms of usual functions [ edit ] In the 1830s, Guglielmo dalla Sommaja used the expression 0 0 x {\displaystyle 0^{0^{x}}} to represent what now would be written [ x > 0 ] {\displaystyle [x>0]} ; he also used variants, such as ( 1 − − 0 0 − − x ) ( 1 − − 0 0 x − − a ) {\displaystyle \left(1-0^{0^{-x}}\right)\left(1-0^{0^{x-a}}\right)} for [ 0 ≤ ≤ x ≤ ≤ a ] {\displaystyle [0\leq x\leq a]} .

[ 3 ] Following one common convention (that 0 0 = 1 {\displaystyle 0^{0}=1} ), those quantities are equal where defined: 0 0 x {\displaystyle 0^{0^{x}}} is 1 if x > 0 , is 0 if x = 0 , and is undefined otherwise.

Notational variations [ edit ] In addition to the now-standard square brackets [ · ] , and the original parentheses (  ·  ) , blackboard bold brackets have also been used, e.g.

⟦ · ⟧ , as well as other unusual forms of bracketing marks available in the publisher's typeface, accompanied by a marginal note.

See also [ edit ] Boolean function Type conversion in computer programming: many languages allow numeric or pointer quantities to be used as boolean quantities Indicator function References [ edit ] ^ a b Kenneth E. Iverson (1962).

A Programming Language . Wiley. p. 11 . Retrieved 7 April 2016 .

^ Ronald Graham , Donald Knuth , and Oren Patashnik .

Concrete Mathematics , Section 2.1: Notation.

^ a b Donald Knuth, "Two Notes on Notation", American Mathematical Monthly , Volume 99, Number 5, May 1992, pp. 403–422. ( TeX Archived 2021-05-06 at the Wayback Machine , arXiv : math/9205211 ).

^ Ronald Graham , Donald Knuth , and Oren Patashnik .

Concrete Mathematics , Section 4.9: Phi and Mu.

Retrieved from " https://en.wikipedia.org/w/index.php?title=Iverson_bracket&oldid=1299517945 " Category : Mathematical notation Hidden categories: Webarchive template wayback links Articles with short description Short description is different from Wikidata This page was last edited on 8 July 2025, at 22:14 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Iverson bracket 15 languages Add topic

