Title: Boolean algebra

URL Source: https://en.wikipedia.org/wiki/Boolean_algebra_(logic)

Published Time: 2008-01-25T09:07:02Z

Markdown Content:
In [mathematics](https://en.wikipedia.org/wiki/Mathematics "Mathematics") and [mathematical logic](https://en.wikipedia.org/wiki/Mathematical_logic "Mathematical logic"), **Boolean algebra** is a branch of [algebra](https://en.wikipedia.org/wiki/Algebra "Algebra"). It differs from [elementary algebra](https://en.wikipedia.org/wiki/Elementary_algebra "Elementary algebra") in two ways. First, the values of the [variables](https://en.wikipedia.org/wiki/Variable_(mathematics) "Variable (mathematics)") are the [truth values](https://en.wikipedia.org/wiki/Truth_value "Truth value")_true_ and _false_, usually denoted by 1 and 0, whereas in elementary algebra the values of the variables are numbers. Second, Boolean algebra uses [logical operators](https://en.wikipedia.org/wiki/Logical_operator "Logical operator") such as [conjunction](https://en.wikipedia.org/wiki/Logical_conjunction "Logical conjunction") (_and_) denoted as ∧, [disjunction](https://en.wikipedia.org/wiki/Disjunction "Disjunction") (_or_) denoted as ∨, and [negation](https://en.wikipedia.org/wiki/Negation "Negation") (_not_) denoted as ¬. Elementary algebra, on the other hand, uses arithmetic operators such as addition, multiplication, subtraction, and division. Boolean algebra is therefore a formal way of describing [logical operations](https://en.wikipedia.org/wiki/Logical_operation "Logical operation") in the same way that elementary algebra describes numerical operations.

Boolean algebra was introduced by [George Boole](https://en.wikipedia.org/wiki/George_Boole "George Boole") in his first book _The Mathematical Analysis of Logic_ (1847),[[1]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Boole_2011-1) and set forth more fully in his _[An Investigation of the Laws of Thought](https://en.wikipedia.org/wiki/An\_Investigation\_of\_the\_Laws\_of\_Thought "An Investigation of the Laws of Thought")_ (1854).[[2]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Boole_1854-2) According to [Huntington](https://en.wikipedia.org/wiki/Edward_Vermilye_Huntington "Edward Vermilye Huntington"), the term _Boolean algebra_ was first suggested by [Henry M. Sheffer](https://en.wikipedia.org/wiki/Henry_M._Sheffer "Henry M. Sheffer") in 1913,[[3]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Huntington_1933-3) although [Charles Sanders Peirce](https://en.wikipedia.org/wiki/Charles_Sanders_Peirce "Charles Sanders Peirce") gave the title "A Boolian [_[sic](https://en.wikipedia.org/wiki/Sic "Sic")_] Algebra with One Constant" to the first chapter of his "The Simplest Mathematics" in 1880.[[4]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Peirce_1931-4) Boolean algebra has been fundamental in the development of [digital electronics](https://en.wikipedia.org/wiki/Digital_electronics "Digital electronics"), and is provided for in all modern [programming languages](https://en.wikipedia.org/wiki/Programming_language "Programming language"). It is also used in [set theory](https://en.wikipedia.org/wiki/Set_theory "Set theory") and [statistics](https://en.wikipedia.org/wiki/Statistics "Statistics").[[5]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Givant-Halmos_2009-5)

A precursor of Boolean algebra was [Gottfried Wilhelm Leibniz](https://en.wikipedia.org/wiki/Gottfried_Wilhelm_Leibniz "Gottfried Wilhelm Leibniz")'s algebra of concepts. The usage of binary in relation to the _[I Ching](https://en.wikipedia.org/wiki/I\_Ching "I Ching")_ was central to Leibniz's _[characteristica universalis](https://en.wikipedia.org/wiki/Characteristica\_universalis "Characteristica universalis")_. It eventually created the foundations of algebra of concepts.[[6]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-6) Leibniz's algebra of concepts is deductively equivalent to the Boolean algebra of sets.[[7]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Lenzen-7)

Boole's algebra predated the modern developments in [abstract algebra](https://en.wikipedia.org/wiki/Abstract_algebra "Abstract algebra") and [mathematical logic](https://en.wikipedia.org/wiki/Mathematical_logic "Mathematical logic"); it is however seen as connected to the origins of both fields.[[8]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Dunn-Hardegree_2001-8) In an abstract setting, Boolean algebra was perfected in the late 19th century by [Jevons](https://en.wikipedia.org/wiki/William_Stanley_Jevons "William Stanley Jevons"), [Schröder](https://en.wikipedia.org/wiki/Ernst_Schr%C3%B6der_(mathematician) "Ernst Schröder (mathematician)"), [Huntington](https://en.wikipedia.org/wiki/Edward_Vermilye_Huntington "Edward Vermilye Huntington") and others, until it reached the modern conception of an (abstract) [mathematical structure](https://en.wikipedia.org/wiki/Mathematical_structure "Mathematical structure").[[8]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Dunn-Hardegree_2001-8) For example, the empirical observation that one can manipulate expressions in the [algebra of sets](https://en.wikipedia.org/wiki/Algebra_of_sets "Algebra of sets"), by translating them into expressions in Boole's algebra, is explained in modern terms by saying that the algebra of sets is _a_[Boolean algebra](https://en.wikipedia.org/wiki/Boolean_algebra_(structure) "Boolean algebra (structure)") (note the [indefinite article](https://en.wikipedia.org/wiki/Indefinite_article "Indefinite article")). In fact, [M. H. Stone](https://en.wikipedia.org/wiki/M._H._Stone "M. H. Stone")[proved in 1936](https://en.wikipedia.org/wiki/Stone%27s_representation_theorem_for_Boolean_algebras "Stone's representation theorem for Boolean algebras") that every Boolean algebra is [isomorphic](https://en.wikipedia.org/wiki/Isomorphic "Isomorphic") to a [field of sets](https://en.wikipedia.org/wiki/Field_of_sets "Field of sets").[[9]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-9)[[10]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-10)

In the 1930s, while studying [switching circuits](https://en.wikipedia.org/wiki/Switching_circuit "Switching circuit"), [Claude Shannon](https://en.wikipedia.org/wiki/Claude_Shannon "Claude Shannon") observed that one could also apply the rules of Boole's algebra in this setting,[[11]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Weisstein-11) and he introduced _switching algebra_ as a way to analyze and design circuits by algebraic means in terms of [logic gates](https://en.wikipedia.org/wiki/Logic_gate "Logic gate"). Shannon already had at his disposal the abstract mathematical apparatus, thus he cast his switching algebra as the _[two-element Boolean algebra](https://en.wikipedia.org/wiki/Two-element\_Boolean\_algebra "Two-element Boolean algebra")_. In modern circuit engineering settings, there is little need to consider other Boolean algebras, thus "switching algebra" and "Boolean algebra" are often used interchangeably.[[12]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Balabanian-Carlson_2001-12)[[13]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Rajaraman-Radhakrishnan_2008-13)[[14]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Camara_2010-14)

[Efficient implementation](https://en.wikipedia.org/wiki/Logic_optimization "Logic optimization") of [Boolean functions](https://en.wikipedia.org/wiki/Boolean_function "Boolean function") is a fundamental problem in the [design](https://en.wikipedia.org/wiki/Logic_design "Logic design") of [combinational logic](https://en.wikipedia.org/wiki/Combinational_logic "Combinational logic") circuits. Modern [electronic design automation](https://en.wikipedia.org/wiki/Electronic_design_automation "Electronic design automation") tools for [very-large-scale integration](https://en.wikipedia.org/wiki/Very-large-scale_integration "Very-large-scale integration") (VLSI) circuits often rely on an efficient representation of Boolean functions known as (reduced ordered) [binary decision diagrams](https://en.wikipedia.org/wiki/Binary_decision_diagram "Binary decision diagram") (BDD) for [logic synthesis](https://en.wikipedia.org/wiki/Logic_synthesis "Logic synthesis") and [formal verification](https://en.wikipedia.org/wiki/Formal_verification "Formal verification").[[15]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Chen_2007-15)

Logic sentences that can be expressed in classical [propositional calculus](https://en.wikipedia.org/wiki/Propositional_calculus "Propositional calculus") have an [equivalent expression](https://en.wikipedia.org/wiki/Algebraic_semantics_(mathematical_logic) "Algebraic semantics (mathematical logic)") in Boolean algebra. Thus, _Boolean logic_ is sometimes used to denote propositional calculus performed in this way.[[16]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Parkes_2002-16)[[17]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Barwise-Etchemendy_1999-17)[[18]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Goertzel_1994-18) Boolean algebra is not sufficient to capture logic formulas using [quantifiers](https://en.wikipedia.org/wiki/Quantifier_(logic) "Quantifier (logic)"), like those from [first-order logic](https://en.wikipedia.org/wiki/First-order_logic "First-order logic").

Although the development of [mathematical logic](https://en.wikipedia.org/wiki/Mathematical_logic "Mathematical logic") did not follow Boole's program, the connection between his algebra and logic was later put on firm ground in the setting of [algebraic logic](https://en.wikipedia.org/wiki/Algebraic_logic "Algebraic logic"), which also studies the algebraic systems of many other logics.[[8]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Dunn-Hardegree_2001-8) The [problem of determining whether](https://en.wikipedia.org/wiki/Decision_problem "Decision problem") the variables of a given Boolean (propositional) formula can be assigned in such a way as to make the formula evaluate to true is called the [Boolean satisfiability problem](https://en.wikipedia.org/wiki/Boolean_satisfiability_problem "Boolean satisfiability problem") (SAT), and is of importance to [theoretical computer science](https://en.wikipedia.org/wiki/Theoretical_computer_science "Theoretical computer science"), being the first problem shown to be [NP-complete](https://en.wikipedia.org/wiki/NP-complete "NP-complete"). The closely related [model of computation](https://en.wikipedia.org/wiki/Model_of_computation "Model of computation") known as a _[Boolean circuit](https://en.wikipedia.org/wiki/Boolean\_circuit "Boolean circuit")_ relates [time complexity](https://en.wikipedia.org/wiki/Time_complexity "Time complexity") (of an [algorithm](https://en.wikipedia.org/wiki/Algorithm "Algorithm")) to [circuit complexity](https://en.wikipedia.org/wiki/Circuit_complexity "Circuit complexity").

Whereas expressions denote mainly [numbers](https://en.wikipedia.org/wiki/Number "Number") in elementary algebra, in Boolean algebra, they denote the [truth values](https://en.wikipedia.org/wiki/Truth_values "Truth values")_false_ and _true_. These values are represented with the [bits](https://en.wikipedia.org/wiki/Bit "Bit"), 0 and 1. They do not behave like the [integers](https://en.wikipedia.org/wiki/Integer "Integer") 0 and 1, for which 1 + 1 = 2, but may be identified with the elements of the [two-element field GF(2)](https://en.wikipedia.org/wiki/GF(2) "GF(2)"), that is, [integer arithmetic modulo 2](https://en.wikipedia.org/wiki/Modular_arithmetic "Modular arithmetic"), for which 1 + 1 = 0. Addition and multiplication then play the Boolean roles of XOR (exclusive-or) and AND (conjunction), respectively, with disjunction _x_ ∨ _y_ (inclusive-or) definable as _x_ + _y_ − _xy_ and negation ¬_x_ as 1 − _x_. In GF(2), − may be replaced by +, since they denote the same operation; however, this way of writing Boolean operations allows applying the usual arithmetic operations of integers (this may be useful when using a programming language in which GF(2) is not implemented).

Boolean algebra also deals with [functions](https://en.wikipedia.org/wiki/Function_(mathematics) "Function (mathematics)") which have their values in the set {0,1}. A [sequence of bits](https://en.wikipedia.org/wiki/Bit_vector "Bit vector") is a commonly used example of such a function. Another common example is the totality of subsets of a set _E_: to a subset _F_ of _E_, one can define the [indicator function](https://en.wikipedia.org/wiki/Indicator_function "Indicator function") that takes the value 1 on _F_, and 0 outside _F_. The most general example is the set elements of a [Boolean algebra](https://en.wikipedia.org/wiki/Boolean_algebra_(structure) "Boolean algebra (structure)"), with all of the foregoing being instances thereof.

As with elementary algebra, the purely equational part of the theory may be developed, without considering explicit values for the variables.[[19]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Halmos_1963-19)

While elementary algebra has four operations (addition, subtraction, multiplication, and division), the Boolean algebra has only three basic operations: [conjunction](https://en.wikipedia.org/wiki/Logical_conjunction "Logical conjunction"), [disjunction](https://en.wikipedia.org/wiki/Disjunction "Disjunction"), and [negation](https://en.wikipedia.org/wiki/Negation "Negation"), expressed with the corresponding [binary operators](https://en.wikipedia.org/wiki/Binary_operator "Binary operator")_AND_ (![Image 1: {\displaystyle \land }](https://wikimedia.org/api/rest_v1/media/math/render/svg/d6823e5a222eb3ca49672818ac3d13ec607052c4)) and OR (![Image 2: {\displaystyle \lor }](https://wikimedia.org/api/rest_v1/media/math/render/svg/ab47f6b1f589aedcf14638df1d63049d233d851a)) and the [unary operator](https://en.wikipedia.org/wiki/Unary_operator "Unary operator")_NOT_ (![Image 3: {\displaystyle \neg }](https://wikimedia.org/api/rest_v1/media/math/render/svg/fa78fd02085d39aa58c9e47a6d4033ce41e02fad)), collectively referred to as _Boolean operators_.[[20]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Bacon-20) Variables in Boolean algebra that store the logical value of 0 and 1 are called the _[Boolean variables](https://en.wikipedia.org/wiki/Boolean\_variable "Boolean variable")_. They are used to store either true or false values.[[21]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-21) The basic operations on Boolean variables _x_ and _y_ are defined as follows:

| Logical operation | Operator | Notation | Alternative notations | Definition |
| --- | --- | --- | --- | --- |
| **Conjunction** | **AND** | _x_ ∧ _y_ | _x_ AND _y_, K _xy_ | _x_ ∧ _y_ = 1 if _x_ = _y_ = 1, _x_ ∧ _y_ = 0 otherwise |
| **Disjunction** | **OR** | _x_ ∨ _y_ | _x_ OR _y_, A _xy_ | _x_ ∨ _y_ = 0 if _x_ = _y_ = 0, _x_ ∨ _y_ = 1 otherwise |
| **Negation** | **NOT** | ¬_x_ | NOT _x_, N _x_, _x̅_, _x'_,!_x_ | ¬_x_ = 0 if _x_ = 1, ¬_x_ = 1 if _x_ = 0 |

Alternatively, the values of _x_ ∧ _y_, _x_ ∨ _y_, and ¬_x_ can be expressed by tabulating their values with [truth tables](https://en.wikipedia.org/wiki/Truth_tables "Truth tables") as follows:[[22]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-22)

| ![Image 4: {\displaystyle x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4) | ![Image 5: {\displaystyle y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b8a6208ec717213d4317e666f1ae872e00620a0d) | ![Image 6: {\displaystyle x\wedge y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/5e39c22fab294b953b40e439378be357dea68150) | ![Image 7: {\displaystyle x\vee y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/304b00d1f1cf4a707c7863e8fae02a2dff7d5a8a) |
| --- | --- | --- | --- |
| 0 | 0 | 0 | 0 |
| 1 | 0 | 0 | 1 |
| 0 | 1 | 0 | 1 |
| 1 | 1 | 1 | 1 || ![Image 8: {\displaystyle x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4) | ![Image 9: {\displaystyle \neg x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f4737ada4f1bfb57e805dec52f6e30a82873304e) |
| --- | --- |
| 0 | 1 |
| 1 | 0 |

When used in expressions, the operators are applied according to the precedence rules. As with elementary algebra, expressions in parentheses are evaluated first, following the precedence rules.[[23]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-23)

If the truth values 0 and 1 are interpreted as integers, these operations may be expressed with the ordinary operations of arithmetic (where _x_ + _y_ uses addition and _xy_ uses multiplication), or by the minimum/maximum functions:

![Image 10: {\displaystyle {\begin{aligned}x\wedge y&=xy=\min(x,y)\\x\vee y&=x+y-xy=x+y(1-x)=\max(x,y)\\\neg x&=1-x\end{aligned}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/85021a38de902cb794787dd5e17ab55b30e4d638)
One might consider that only negation and one of the two other operations are basic because of the following identities that allow one to define conjunction in terms of negation and the disjunction, and vice versa ([De Morgan's laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws "De Morgan's laws")):[[24]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-24)

![Image 11: {\displaystyle {\begin{aligned}x\wedge y&=\neg (\neg x\vee \neg y)\\x\vee y&=\neg (\neg x\wedge \neg y)\end{aligned}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9a1628f610033d1ba2dff543ddf5aef5acc8fea3)

### Secondary operations

[[edit](https://en.wikipedia.org/w/index.php?title=Boolean_algebra&action=edit&section=5 "Edit section: Secondary operations")]

Operations composed from the basic operations include, among others, the following:

These definitions give rise to the following truth tables giving the values of these operations for all four possible inputs.

Secondary operations. Table 1 | ![Image 12: {\displaystyle x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4) | ![Image 13: {\displaystyle y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b8a6208ec717213d4317e666f1ae872e00620a0d) | ![Image 14: {\displaystyle x\rightarrow y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/fce077cec2b56644f63a641afc4266677f1238e7) | ![Image 15: {\displaystyle x\oplus y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/10fc94462e7622639c0c464161a1f0c8fc057999) | ![Image 16: {\displaystyle x\leftrightarrow y,x\equiv y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e9b3c81aa7e3499c2cef8f7227791d1ef2204f65) |
| --- | --- | --- | --- | --- |
| 0 | 0 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 |
| 0 | 1 | 1 | 1 | 0 |
| 1 | 1 | 1 | 0 | 1 |
**Material conditional**The first operation, _x_→_y_, or C _xy_, is called _material implication_. If _x_ is true, then the result of expression _x_→_y_ is taken to be that of _y_ (e.g. if _x_ is true and _y_ is false, then _x_→_y_ is also false). But if _x_ is false, then the value of _y_ can be ignored; however, the operation must return _some_ Boolean value and there are only two choices. So by definition, _x_→_y_ is _true_ when x is false ([relevance logic](https://en.wikipedia.org/wiki/Relevance_logic "Relevance logic") rejects this definition, by viewing an implication with a [false premise](https://en.wikipedia.org/wiki/False_premise "False premise") as something other than either true or false).**Exclusive OR** (**XOR**)The second operation, _x_⊕_y_, or J _xy_, is called _exclusive or_ (often abbreviated as XOR) to distinguish it from disjunction as the inclusive kind. It excludes the possibility of both _x_ and _y being_ true (e.g. see table): if both are true then result is false. Defined in terms of arithmetic it is addition where mod 2 is 1+1 =0.**Logical equivalence**The third operation, the complement of exclusive or, is _equivalence_ or Boolean equality: _x_≡_y_, or E _xy_, is true just when _x_ and _y_ have the same value. Hence _x_⊕_y_ as its complement can be understood as _x_≠_y_, being true just when _x_ and _y_ are different. Thus, its counterpart in arithmetic mod 2 is _x_ + _y_. Equivalence's counterpart in arithmetic mod 2 is _x_ + _y_ + 1.
A _law_ of Boolean algebra is an [identity](https://en.wikipedia.org/wiki/Identity_(mathematics) "Identity (mathematics)") such as _x_ ∨ (_y_ ∨ _z_) = (_x_ ∨ _y_) ∨ _z_ between two Boolean terms, where a _Boolean term_ is defined as an expression built up from variables and the constants 0 and 1 using the operations ∧, ∨, and ¬. The concept can be extended to terms involving other Boolean operations such as ⊕, →, and ≡, but such extensions are unnecessary for the purposes to which the laws are put. Such purposes include the definition of a [Boolean algebra](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#Boolean_algebras) as any [model](https://en.wikipedia.org/wiki/Model_(logic) "Model (logic)") of the Boolean laws, and as a means for deriving new laws from old as in the derivation of _x_ ∨ (_y_ ∧ _z_) = _x_ ∨ (_z_ ∧ _y_) from _y_ ∧ _z_ = _z_ ∧ _y_ (as treated in _[§Axiomatizing Boolean algebra](https://en.wikipedia.org/wiki/Boolean\_algebra\_(logic)#Axiomatizing\_Boolean\_algebra)_).

Boolean algebra satisfies many of the same laws as ordinary algebra when one matches up ∨ with addition and ∧ with multiplication. In particular the following laws are common to both kinds of algebra:[[25]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-ORegan_2008-25)[[26]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-EoBA-26)

Associativity of ∨:![Image 17: {\displaystyle x\vee (y\vee z)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e43f6b6bb6feceba01569e15016d6a8af4ada801)![Image 18: {\displaystyle =(x\vee y)\vee z}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d25a96fc01de59a76cfb5302b067b7f02da8f2ca)
Associativity of ∧:![Image 19: {\displaystyle x\wedge (y\wedge z)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f985d5acedc3560c9dfbe76622058a49bbb4cc2a)![Image 20: {\displaystyle =(x\wedge y)\wedge z}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c2ddbf9998bf875ecf6948b9b871cdd9a02fe015)
Commutativity of ∨:![Image 21: {\displaystyle x\vee y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/304b00d1f1cf4a707c7863e8fae02a2dff7d5a8a)![Image 22: {\displaystyle =y\vee x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/84a116ff6ae01fd596a4a2952803a8e5bb3b8571)
Commutativity of ∧:![Image 23: {\displaystyle x\wedge y}](https://wikimedia.org/api/rest_v1/media/math/render/svg/5e39c22fab294b953b40e439378be357dea68150)![Image 24: {\displaystyle =y\wedge x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/612e28d9c887bf17b78deeb8b6690827b6bf7dab)
Distributivity of ∧ over ∨:![Image 25: {\displaystyle x\wedge (y\vee z)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3acd78dcc7481cd258b13f2f22a13bf5894bfe19)![Image 26: {\displaystyle =(x\wedge y)\vee (x\wedge z)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/49e4bd21a491b4a9653a0636a36b1c4276e9a347)
Identity for ∨:![Image 27: {\displaystyle x\vee 0}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6cbf63019e961cfde4abddd64640ca3f7b712fe0)![Image 28: {\displaystyle =x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1c66e79d9cccef418849534769b5e3c6ffeb9d52)
Identity for ∧:![Image 29: {\displaystyle x\wedge 1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9e13cfe3c5eea983f9f6f14fa71ee27beee2f1d5)![Image 30: {\displaystyle =x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1c66e79d9cccef418849534769b5e3c6ffeb9d52)
Annihilator for ∧:![Image 31: {\displaystyle x\wedge 0}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f53bbfb4f7678ad702506b628799febe354f8a83)![Image 32: {\displaystyle =0}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6dc9e66de468806365c20e32e83456cc526ce29e)

The following laws hold in Boolean algebra, but not in ordinary algebra:

Annihilator for ∨:![Image 33: {\displaystyle x\vee 1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d179f5e174104545342b7ae195cabaebd31f86d8)![Image 34: {\displaystyle =1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/282a76fe69ce05e31352dfd19b7700eb784fb3f8)
Idempotence of ∨:![Image 35: {\displaystyle x\vee x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/18299516620d66d42505a46089684d22e18cae58)![Image 36: {\displaystyle =x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1c66e79d9cccef418849534769b5e3c6ffeb9d52)
Idempotence of ∧:![Image 37: {\displaystyle x\wedge x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/61c3e1f66a763d5a708485438e3f6d952e0bc4f4)![Image 38: {\displaystyle =x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1c66e79d9cccef418849534769b5e3c6ffeb9d52)
Absorption 1:![Image 39: {\displaystyle x\wedge (x\vee y)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/7317a18981f4f50ddd5281621860434d32a2055c)![Image 40: {\displaystyle =x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1c66e79d9cccef418849534769b5e3c6ffeb9d52)
Absorption 2:![Image 41: {\displaystyle x\vee (x\wedge y)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/da75106eaa322a67bccf2daf277d8e74eabbab36)![Image 42: {\displaystyle =x}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1c66e79d9cccef418849534769b5e3c6ffeb9d52)
Distributivity of ∨ over ∧:![Image 43: {\displaystyle x\vee (y\wedge z)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a6e9658b0b6387c317cfb8ad6da05af1095f6351)![Image 44: {\displaystyle =(x\vee y)\wedge (x\vee z)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c90090bce4eaa5a183fdb45215c63b98f2ed08e1)

Taking _x_ = 2 in the third law above shows that it is not an ordinary algebra law, since 2 × 2 = 4. The remaining five laws can be falsified in ordinary algebra by taking all variables to be 1. For example, in absorption law 1, the left hand side would be 1(1 + 1) = 2, while the right hand side would be 1 (and so on).

All of the laws treated thus far have been for conjunction and disjunction. These operations have the property that changing either argument either leaves the output unchanged, or the output changes in the same way as the input. Equivalently, changing any variable from 0 to 1 never results in the output changing from 1 to 0. Operations with this property are said to be _monotone_. Thus the axioms thus far have all been for monotonic Boolean logic. Nonmonotonicity enters via complement ¬ as follows.[[5]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Givant-Halmos_2009-5)

The complement operation is defined by the following two laws.

![Image 45: {\displaystyle {\begin{aligned}&{\text{Complementation 1}}&x\wedge \neg x&=0\\&{\text{Complementation 2}}&x\vee \neg x&=1\end{aligned}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/890da58e4b6645af3acf6620db71bda66737502c)
All properties of negation including the laws below follow from the above two laws alone.[[5]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Givant-Halmos_2009-5)

In both ordinary and Boolean algebra, negation works by exchanging pairs of elements, hence in both algebras it satisfies the double negation law (also called involution law)

![Image 46: {\displaystyle {\begin{aligned}&{\text{Double negation}}&\neg {(\neg {x})}&=x\end{aligned}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c56a5a07eca36ae6c78a36328d10a53f8172bb1e)
But whereas _ordinary algebra_ satisfies the two laws

![Image 47: {\displaystyle {\begin{aligned}(-x)(-y)&=xy\\(-x)+(-y)&=-(x+y)\end{aligned}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6818895e12c9da760588cb7e857a0541a29eb462)
Boolean algebra satisfies [De Morgan's laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws "De Morgan's laws"):

![Image 48: {\displaystyle {\begin{aligned}&{\text{De Morgan 1}}&\neg x\wedge \neg y&=\neg {(x\vee y)}\\&{\text{De Morgan 2}}&\neg x\vee \neg y&=\neg {(x\wedge y)}\end{aligned}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1060095f2a3b66ed2ad2e3da7d17b5f8f17f7740)
The laws listed above define Boolean algebra, in the sense that they entail the rest of the subject. The laws _complementation_ 1 and 2, together with the monotone laws, suffice for this purpose and can therefore be taken as one possible _complete_ set of laws or [axiomatization](https://en.wikipedia.org/wiki/Axiomatization "Axiomatization") of Boolean algebra. Every law of Boolean algebra follows logically from these axioms. Furthermore, Boolean algebras can then be defined as the [models](https://en.wikipedia.org/wiki/Model_(logic) "Model (logic)") of these axioms as treated in _[§Boolean algebras](https://en.wikipedia.org/wiki/Boolean\_algebra\_(logic)#Boolean\_algebras)_.

Writing down further laws of Boolean algebra cannot give rise to any new consequences of these axioms, nor can it rule out any model of them. In contrast, in a list of some but not all of the same laws, there could have been Boolean laws that did not follow from those on the list, and moreover there would have been models of the listed laws that were not Boolean algebras.

This axiomatization is by no means the only one, or even necessarily the most natural given that attention was not paid as to whether some of the axioms followed from others, but there was simply a choice to stop when enough laws had been noticed, treated further in _[§Axiomatizing Boolean algebra](https://en.wikipedia.org/wiki/Boolean\_algebra\_(logic)#Axiomatizing\_Boolean\_algebra)_. Or the intermediate notion of axiom can be sidestepped altogether by defining a Boolean law directly as any _tautology_, understood as an equation that holds for all values of its variables over 0 and 1.[[27]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-McGee_2005-27)[[28]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Goodstein_2012-28) All these definitions of Boolean algebra can be shown to be equivalent.

Principle: If {X, R} is a [partially ordered set](https://en.wikipedia.org/wiki/Partially_ordered_set "Partially ordered set"), then {X, R(inverse)} is also a partially ordered set.

There is nothing special about the choice of symbols for the values of Boolean algebra. 0 and 1 could be renamed to _α_ and _β_, and as long as it was done consistently throughout, it would still be Boolean algebra, albeit with some obvious cosmetic differences.

But suppose 0 and 1 were renamed 1 and 0 respectively. Then it would still be Boolean algebra, and moreover operating on the same values. However, it would not be identical to our original Boolean algebra because now ∨ behaves the way ∧ used to do and vice versa. So there are still some cosmetic differences to show that the notation has been changed, despite the fact that 0s and 1s are still being used.

But if in addition to interchanging the names of the values, the names of the two binary operations are also interchanged, _now_ there is no trace of what was done. The end product is completely indistinguishable from what was started with. The columns for _x_ ∧ _y_ and _x_ ∨ _y_ in the truth tables have changed places, but that switch is immaterial.

When values and operations can be paired up in a way that leaves everything important unchanged when all pairs are switched simultaneously, the members of each pair are called _dual_ to each other. Thus 0 and 1 are dual, and ∧ and ∨ are dual. The _duality principle_, also called [De Morgan duality](https://en.wikipedia.org/wiki/De_Morgan_duality "De Morgan duality"), asserts that Boolean algebra is unchanged when all dual pairs are interchanged.

One change not needed to make as part of this interchange was to complement. Complement is a _self-dual_ operation. The identity or do-nothing operation _x_ (copy the input to the output) is also self-dual. A more complicated example of a self-dual operation is (_x_ ∧ _y_) ∨ (_y_ ∧ _z_) ∨ (_z_ ∧ _x_). There is no self-dual binary operation that depends on both its arguments. A composition of self-dual operations is a self-dual operation. For example, if _f_(_x_, _y_, _z_) = (_x_ ∧ _y_) ∨ (_y_ ∧ _z_) ∨ (_z_ ∧ _x_), then _f_(_f_(_x_, _y_, _z_), _x_, _t_) is a self-dual operation of four arguments _x_, _y_, _z_, _t_.

The principle of duality can be explained from a [group theory](https://en.wikipedia.org/wiki/Group_theory "Group theory") perspective by the fact that there are exactly four functions that are one-to-one mappings ([automorphisms](https://en.wikipedia.org/wiki/Automorphism "Automorphism")) of the set of [Boolean polynomials](https://en.wikipedia.org/wiki/Boolean_polynomial "Boolean polynomial") back to itself: the identity function, the complement function, the dual function and the contradual function (complemented dual). These four functions form a [group](https://en.wikipedia.org/wiki/Group_(mathematics) "Group (mathematics)") under [function composition](https://en.wikipedia.org/wiki/Function_composition "Function composition"), isomorphic to the [Klein four-group](https://en.wikipedia.org/wiki/Klein_four-group "Klein four-group"), [acting](https://en.wikipedia.org/wiki/Group_action_(mathematics) "Group action (mathematics)") on the set of Boolean polynomials. [Walter Gottschalk](https://en.wikipedia.org/wiki/Walter_Gottschalk "Walter Gottschalk") remarked that consequently a more appropriate name for the phenomenon would be the _principle_ (or _square_) _of quaternality_.[[5]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Givant-Halmos_2009-5): 21–22

Diagrammatic representations
----------------------------

[[edit](https://en.wikipedia.org/w/index.php?title=Boolean_algebra&action=edit&section=11 "Edit section: Diagrammatic representations")]

A [Venn diagram](https://en.wikipedia.org/wiki/Venn_diagram "Venn diagram")[[29]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Venn_1880-29) can be used as a representation of a Boolean operation using shaded overlapping regions. There is one region for each variable, all circular in the examples here. The interior and exterior of region _x_ corresponds respectively to the values 1 (true) and 0 (false) for variable _x_. The shading indicates the value of the operation for each combination of regions, with dark denoting 1 and light 0 (some authors use the opposite convention).

The three Venn diagrams in the figure below represent respectively conjunction _x_ ∧ _y_, disjunction _x_ ∨ _y_, and complement ¬_x_.

[![Image 49](https://upload.wikimedia.org/wikipedia/commons/thumb/a/ae/Vennandornot.svg/500px-Vennandornot.svg.png)](https://en.wikipedia.org/wiki/File:Vennandornot.svg)

Figure 2. Venn diagrams for conjunction, disjunction, and complement

For conjunction, the region inside both circles is shaded to indicate that _x_ ∧ _y_ is 1 when both variables are 1. The other regions are left unshaded to indicate that _x_ ∧ _y_ is 0 for the other three combinations.

The second diagram represents disjunction _x_ ∨ _y_ by shading those regions that lie inside either or both circles. The third diagram represents complement ¬_x_ by shading the region _not_ inside the circle.

While we have not shown the Venn diagrams for the constants 0 and 1, they are trivial, being respectively a white box and a dark box, neither one containing a circle. However, we could put a circle for _x_ in those boxes, in which case each would denote a function of one argument, _x_, which returns the same value independently of _x_, called a constant function. As far as their outputs are concerned, constants and constant functions are indistinguishable; the difference is that a constant takes no arguments, called a _zeroary_ or _nullary_ operation, while a constant function takes one argument, which it ignores, and is a _unary_ operation.

Venn diagrams are helpful in visualizing laws. The commutativity laws for ∧ and ∨ can be seen from the symmetry of the diagrams: a binary operation that was not commutative would not have a symmetric diagram because interchanging _x_ and _y_ would have the effect of reflecting the diagram horizontally and any failure of commutativity would then appear as a failure of symmetry.

[Idempotence](https://en.wikipedia.org/wiki/Idempotence "Idempotence") of ∧ and ∨ can be visualized by sliding the two circles together and noting that the shaded area then becomes the whole circle, for both ∧ and ∨.

To see the first absorption law, _x_ ∧ (_x_ ∨ _y_) = _x_, start with the diagram in the middle for _x_ ∨ _y_ and note that the portion of the shaded area in common with the _x_ circle is the whole of the _x_ circle. For the second absorption law, _x_ ∨ (_x_ ∧ _y_) = _x_, start with the left diagram for _x_∧_y_ and note that shading the whole of the _x_ circle results in just the _x_ circle being shaded, since the previous shading was inside the _x_ circle.

The double negation law can be seen by complementing the shading in the third diagram for ¬_x_, which shades the _x_ circle.

To visualize the first De Morgan's law, (¬_x_) ∧ (¬_y_) = ¬(_x_ ∨ _y_), start with the middle diagram for _x_ ∨ _y_ and complement its shading so that only the region outside both circles is shaded, which is what the right hand side of the law describes. The result is the same as if we shaded that region which is both outside the _x_ circle _and_ outside the _y_ circle, i.e. the conjunction of their exteriors, which is what the left hand side of the law describes.

The second De Morgan's law, (¬_x_) ∨ (¬_y_) = ¬(_x_ ∧ _y_), works the same way with the two diagrams interchanged.

The first complement law, _x_ ∧ ¬_x_ = 0, says that the interior and exterior of the _x_ circle have no overlap. The second complement law, _x_ ∨ ¬_x_ = 1, says that everything is either inside or outside the _x_ circle.

### Digital logic gates

[[edit](https://en.wikipedia.org/w/index.php?title=Boolean_algebra&action=edit&section=13 "Edit section: Digital logic gates")]

Digital logic is the application of the Boolean algebra of 0 and 1 to electronic hardware consisting of [logic gates](https://en.wikipedia.org/wiki/Logic_gates "Logic gates") connected to form a [circuit diagram](https://en.wikipedia.org/wiki/Circuit_diagram "Circuit diagram"). Each gate implements a Boolean operation, and is depicted schematically by a shape indicating the operation. The shapes associated with the gates for conjunction (AND-gates), disjunction (OR-gates), and complement (inverters) are as follows:[[30]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Shannon_1949-30)

[![Image 50](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c1/LogicGates.svg/500px-LogicGates.svg.png)](https://en.wikipedia.org/wiki/File:LogicGates.svg)

From left to right: [AND](https://en.wikipedia.org/wiki/AND_gate "AND gate"), [OR](https://en.wikipedia.org/wiki/OR_gate "OR gate"), and [NOT](https://en.wikipedia.org/wiki/Inverter_(logic_gate) "Inverter (logic gate)") gates.

The lines on the left of each gate represent input wires or _ports_. The value of the input is represented by a voltage on the lead. For so-called "active-high" logic, 0 is represented by a voltage close to zero or "ground," while 1 is represented by a voltage close to the supply voltage; active-low reverses this. The line on the right of each gate represents the output port, which normally follows the same voltage conventions as the input ports.

Complement is implemented with an inverter gate. The triangle denotes the operation that simply copies the input to the output; the small circle on the output denotes the actual inversion complementing the input. The convention of putting such a circle on any port means that the signal passing through this port is complemented on the way through, whether it is an input or output port.

The [duality principle](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#Duality_principle), or [De Morgan's laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws "De Morgan's laws"), can be understood as asserting that complementing all three ports of an AND gate converts it to an OR gate and vice versa, as shown in Figure 4 below. Complementing both ports of an inverter however leaves the operation unchanged.

[![Image 51](https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/DeMorganGates.GIF/500px-DeMorganGates.GIF)](https://en.wikipedia.org/wiki/File:DeMorganGates.GIF)

More generally, one may complement any of the eight subsets of the three ports of either an AND or OR gate. The resulting sixteen possibilities give rise to only eight Boolean operations, namely those with an odd number of 1s in their truth table. There are eight such because the "odd-bit-out" can be either 0 or 1 and can go in any of four positions in the truth table. There being sixteen binary Boolean operations, this must leave eight operations with an even number of 1s in their truth tables. Two of these are the constants 0 and 1 (as binary operations that ignore both their inputs); four are the operations that depend nontrivially on exactly one of their two inputs, namely _x_, _y_, ¬_x_, and ¬_y_; and the remaining two are _x_ ⊕ _y_ (XOR) and its complement _x_ ≡ _y_.

The term "algebra" denotes both a subject, namely the subject of [algebra](https://en.wikipedia.org/wiki/Algebra "Algebra"), and an object, namely an [algebraic structure](https://en.wikipedia.org/wiki/Algebraic_structure "Algebraic structure"). Whereas the foregoing has addressed the subject of Boolean algebra, this section deals with mathematical objects called Boolean algebras, defined in full generality as any model of the Boolean laws. We begin with a special case of the notion definable without reference to the laws, namely concrete Boolean algebras, and then give [the formal definition](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#Boolean_algebras:_the_definition) of the general notion.

### Concrete Boolean algebras

[[edit](https://en.wikipedia.org/w/index.php?title=Boolean_algebra&action=edit&section=15 "Edit section: Concrete Boolean algebras")]

A _concrete Boolean algebra_ or [field of sets](https://en.wikipedia.org/wiki/Field_of_sets "Field of sets") is any nonempty set of subsets of a given set _X_ closed under the set operations of [union](https://en.wikipedia.org/wiki/Union_(set_theory) "Union (set theory)"), [intersection](https://en.wikipedia.org/wiki/Intersection_(set_theory) "Intersection (set theory)"), and [complement](https://en.wikipedia.org/wiki/Complement_(set_theory)#Relative_complement "Complement (set theory)") relative to _X_.[[5]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Givant-Halmos_2009-5)

(Historically _X_ itself was required to be nonempty as well to exclude the degenerate or one-element Boolean algebra, which is the one exception to the rule that all Boolean algebras satisfy the same equations since the degenerate algebra satisfies every equation. However, this exclusion conflicts with the preferred purely equational definition of "Boolean algebra", there being no way to rule out the one-element algebra using only equations—0≠1 does not count, being a negated equation. Hence modern authors allow the degenerate Boolean algebra and let _X_ be empty.)

_Example 1._ The [power set](https://en.wikipedia.org/wiki/Power_set "Power set") 2 _X_ of _X_, consisting of all [subsets](https://en.wikipedia.org/wiki/Subset "Subset") of _X_. Here _X_ may be any set: empty, finite, infinite, or even [uncountable](https://en.wikipedia.org/wiki/Uncountable "Uncountable").

_Example 2._ The empty set and _X_. This two-element algebra shows that a concrete Boolean algebra can be finite even when it consists of subsets of an infinite set. It can be seen that every field of subsets of _X_ must contain the empty set and _X_. Hence no smaller example is possible, other than the degenerate algebra obtained by taking _X_ to be empty so as to make the empty set and _X_ coincide.

_Example 3._ The set of finite and [cofinite](https://en.wikipedia.org/wiki/Cofinite "Cofinite") sets of integers, where a cofinite set is one omitting only finitely many integers. This is clearly closed under complement, and is closed under union because the union of a cofinite set with any set is cofinite, while the union of two finite sets is finite. Intersection behaves like union with "finite" and "cofinite" interchanged. This example is countably infinite because there are only countably many finite sets of integers.

_Example 4._ For a less trivial example of the point made by example 2, consider a [Venn diagram](https://en.wikipedia.org/wiki/Venn_diagram "Venn diagram") formed by _n_ closed curves [partitioning](https://en.wikipedia.org/wiki/Partition_of_a_set "Partition of a set") the diagram into 2 _n_ regions, and let _X_ be the (infinite) set of all points in the plane not on any curve but somewhere within the diagram. The interior of each region is thus an infinite subset of _X_, and every point in _X_ is in exactly one region. Then the set of all 2 2 _n_ possible unions of regions (including the empty set obtained as the union of the empty set of regions and _X_ obtained as the union of all 2 _n_ regions) is closed under union, intersection, and complement relative to _X_ and therefore forms a concrete Boolean algebra. Again, there are finitely many subsets of an infinite set forming a concrete Boolean algebra, with example 2 arising as the case _n_ = 0 of no curves.

### Subsets as bit vectors

[[edit](https://en.wikipedia.org/w/index.php?title=Boolean_algebra&action=edit&section=16 "Edit section: Subsets as bit vectors")]

A subset _Y_ of _X_ can be identified with an [indexed family](https://en.wikipedia.org/wiki/Indexed_family "Indexed family") of bits with [index set](https://en.wikipedia.org/wiki/Index_set "Index set")_X_, with the bit indexed by _x_ ∈ _X_ being 1 or 0 according to whether or not _x_ ∈ _Y_. (This is the so-called [characteristic function](https://en.wikipedia.org/wiki/Indicator_function "Indicator function") notion of a subset.) For example, a 32-bit computer word consists of 32 bits indexed by the set {0,1,2,...,31}, with 0 and 31 indexing the low and high order bits respectively. For a smaller example, if ⁠![Image 52: {\displaystyle X=\{a,b,c\}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/36964a6c0376aed739ef2645a5ff6a8d659744d9)⁠ where a, b, c are viewed as bit positions in that order from left to right, the eight subsets {}, {_c_}, {_b_}, {_b_,_c_}, {_a_}, {_a_,_c_}, {_a_,_b_}, and {_a_,_b_,_c_} of _X_ can be identified with the respective bit vectors 000, 001, 010, 011, 100, 101, 110, and 111. Bit vectors indexed by the set of natural numbers are infinite [sequences](https://en.wikipedia.org/wiki/Sequence "Sequence") of bits, while those indexed by the [reals](https://en.wikipedia.org/wiki/Real_number "Real number") in the [unit interval](https://en.wikipedia.org/wiki/Unit_interval "Unit interval") [0,1] are packed too densely to be able to write conventionally but nonetheless form well-defined indexed families (imagine coloring every point of the interval [0,1] either black or white independently; the black points then form an arbitrary subset of [0,1]).

From this bit vector viewpoint, a concrete Boolean algebra can be defined equivalently as a nonempty set of bit vectors all of the same length (more generally, indexed by the same set) and closed under the bit vector operations of [bitwise](https://en.wikipedia.org/wiki/Bitwise "Bitwise") ∧, ∨, and ¬, as in 1010∧0110 = 0010, 1010∨0110 = 1110, and ¬1010 = 0101, the bit vector realizations of intersection, union, and complement respectively.

### Prototypical Boolean algebra

[[edit](https://en.wikipedia.org/w/index.php?title=Boolean_algebra&action=edit&section=17 "Edit section: Prototypical Boolean algebra")]

The set {0,1} and its Boolean operations as treated above can be understood as the special case of bit vectors of length one, which by the identification of bit vectors with subsets can also be understood as the two subsets of a one-element set. This is called the _prototypical_ Boolean algebra, justified by the following observation.

The laws satisfied by all nondegenerate concrete Boolean algebras coincide with those satisfied by the prototypical Boolean algebra.
This observation is proved as follows. Certainly any law satisfied by all concrete Boolean algebras is satisfied by the prototypical one since it is concrete. Conversely any law that fails for some concrete Boolean algebra must have failed at a particular bit position, in which case that position by itself furnishes a one-bit counterexample to that law. Nondegeneracy ensures the existence of at least one bit position because there is only one empty bit vector.

The final goal of the next section can be understood as eliminating "concrete" from the above observation. That goal is reached via the stronger observation that, up to isomorphism, all Boolean algebras are concrete.

### Boolean algebras: the definition

[[edit](https://en.wikipedia.org/w/index.php?title=Boolean_algebra&action=edit&section=18 "Edit section: Boolean algebras: the definition")]

The Boolean algebras so far have all been concrete, consisting of bit vectors or equivalently of subsets of some set. Such a Boolean algebra consists of a set and operations on that set which can be _shown_ to satisfy the laws of Boolean algebra.

Instead of showing that the Boolean laws are satisfied, we can instead postulate a set _X_, two binary operations on _X_, and one unary operation, and _require_ that those operations satisfy the laws of Boolean algebra. The elements of _X_ need not be bit vectors or subsets but can be anything at all. This leads to the more general _abstract_ definition.

A _Boolean algebra_ is any set with binary operations ∧ and ∨ and a unary operation ¬ thereon satisfying the Boolean laws.[[31]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Koppelberg_1989-31)
For the purposes of this definition it is irrelevant how the operations came to satisfy the laws, whether by fiat or proof. All concrete Boolean algebras satisfy the laws (by proof rather than fiat), whence every concrete Boolean algebra is a Boolean algebra according to our definitions. This axiomatic definition of a Boolean algebra as a set and certain operations satisfying certain laws or axioms _by fiat_ is entirely analogous to the abstract definitions of [group](https://en.wikipedia.org/wiki/Group_(mathematics) "Group (mathematics)"), [ring](https://en.wikipedia.org/wiki/Ring_(mathematics) "Ring (mathematics)"), [field](https://en.wikipedia.org/wiki/Field_(mathematics) "Field (mathematics)") etc. characteristic of modern or [abstract algebra](https://en.wikipedia.org/wiki/Abstract_algebra "Abstract algebra").

Given any complete axiomatization of Boolean algebra, such as the axioms for a [complemented](https://en.wikipedia.org/wiki/Complemented_lattice "Complemented lattice")[distributive lattice](https://en.wikipedia.org/wiki/Distributive_lattice "Distributive lattice"), a sufficient condition for an [algebraic structure](https://en.wikipedia.org/wiki/Algebraic_structure "Algebraic structure") of this kind to satisfy all the Boolean laws is that it satisfy just those axioms. The following is therefore an equivalent definition.

A _Boolean algebra_ is a complemented distributive lattice.
The section on [axiomatization](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#Axiomatizing_Boolean_algebra) lists other axiomatizations, any of which can be made the basis of an equivalent definition.

### Representable Boolean algebras

[[edit](https://en.wikipedia.org/w/index.php?title=Boolean_algebra&action=edit&section=19 "Edit section: Representable Boolean algebras")]

Although every concrete Boolean algebra is a Boolean algebra, not every Boolean algebra need be concrete. Let _n_ be a [square-free](https://en.wikipedia.org/wiki/Square-free_integer "Square-free integer") positive integer, one not divisible by the square of an integer, for example 30 but not 12. The operations of [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor "Greatest common divisor"), [least common multiple](https://en.wikipedia.org/wiki/Least_common_multiple "Least common multiple"), and division into _n_ (that is, ¬_x_ = _n_/_x_), can be shown to satisfy all the Boolean laws when their arguments range over the positive divisors of _n_. Hence those divisors form a Boolean algebra. These divisors are not subsets of a set, making the divisors of _n_ a Boolean algebra that is not concrete according to our definitions.

However, if each divisor of _n_ is _represented_ by the set of its prime factors, this nonconcrete Boolean algebra is [isomorphic](https://en.wikipedia.org/wiki/Isomorphic "Isomorphic") to the concrete Boolean algebra consisting of all sets of prime factors of _n_, with union corresponding to least common multiple, intersection to greatest common divisor, and complement to division into _n_. So this example, while not technically concrete, is at least "morally" concrete via this representation, called an [isomorphism](https://en.wikipedia.org/wiki/Isomorphism "Isomorphism"). This example is an instance of the following notion.

A Boolean algebra is called _representable_ when it is isomorphic to a concrete Boolean algebra.
The next question is answered positively as follows.

Every Boolean algebra is representable.
That is, up to isomorphism, abstract and concrete Boolean algebras are the same thing. This result depends on the [Boolean prime ideal theorem](https://en.wikipedia.org/wiki/Boolean_prime_ideal_theorem "Boolean prime ideal theorem"), a choice principle slightly weaker than the [axiom of choice](https://en.wikipedia.org/wiki/Axiom_of_choice "Axiom of choice"). This strong relationship implies a weaker result strengthening the observation in the previous subsection to the following easy consequence of representability.

The laws satisfied by all Boolean algebras coincide with those satisfied by the prototypical Boolean algebra.
It is weaker in the sense that it does not of itself imply representability. Boolean algebras are special here, for example a [relation algebra](https://en.wikipedia.org/wiki/Relation_algebra "Relation algebra") is a Boolean algebra with additional structure but it is not the case that every relation algebra is representable in the sense appropriate to relation algebras.

Axiomatizing Boolean algebra
----------------------------

[[edit](https://en.wikipedia.org/w/index.php?title=Boolean_algebra&action=edit&section=20 "Edit section: Axiomatizing Boolean algebra")]

The above definition of an abstract Boolean algebra as a set together with operations satisfying "the" Boolean laws raises the question of what those laws are. A simplistic answer is "all Boolean laws", which can be defined as all equations that hold for the Boolean algebra of 0 and 1. However, since there are infinitely many such laws, this is not a satisfactory answer in practice, leading to the question of it suffices to require only finitely many laws to hold.

In the case of Boolean algebras, the answer is "yes": the finitely many equations listed above are sufficient. Thus, Boolean algebra is said to be _finitely axiomatizable_ or _finitely based_.

Moreover, the number of equations needed can be further reduced. To begin with, some of the above laws are implied by some of the others. A sufficient subset of the above laws consists of the pairs of associativity, commutativity, and absorption laws, distributivity of ∧ over ∨ (or the other distributivity law—one suffices), and the two complement laws. In fact, this is the traditional axiomatization of Boolean algebra as a [complemented](https://en.wikipedia.org/wiki/Complemented_lattice "Complemented lattice")[distributive lattice](https://en.wikipedia.org/wiki/Distributive_lattice "Distributive lattice").

By introducing additional laws not listed above, it becomes possible to shorten the list of needed equations yet further; for instance, with the vertical bar representing the [Sheffer stroke](https://en.wikipedia.org/wiki/Sheffer_stroke "Sheffer stroke") operation, the single axiom ![Image 53: {\displaystyle ((a\mid b)\mid c)\mid (a\mid ((a\mid c)\mid a))=c}](https://wikimedia.org/api/rest_v1/media/math/render/svg/463145ea214780d9c62f572a7f232ec584c7fe77) is sufficient to completely axiomatize Boolean algebra. It is also possible to find longer single axioms using more conventional operations; see [Minimal axioms for Boolean algebra](https://en.wikipedia.org/wiki/Minimal_axioms_for_Boolean_algebra "Minimal axioms for Boolean algebra").[[32]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-McCune_2002-32)

Propositional logic
-------------------

[[edit](https://en.wikipedia.org/w/index.php?title=Boolean_algebra&action=edit&section=21 "Edit section: Propositional logic")]

_[Propositional logic](https://en.wikipedia.org/wiki/Propositional\_logic "Propositional logic")_ is a [logical system](https://en.wikipedia.org/wiki/Logical_system "Logical system") that is intimately connected to Boolean algebra.[[5]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Givant-Halmos_2009-5) Many syntactic concepts of Boolean algebra carry over to propositional logic with only minor changes in notation and terminology, while the semantics of propositional logic are defined via Boolean algebras in a way that the tautologies (theorems) of propositional logic correspond to equational theorems of Boolean algebra.

Syntactically, every Boolean term corresponds to a _[propositional formula](https://en.wikipedia.org/wiki/Propositional\_formula "Propositional formula")_ of propositional logic. In this translation between Boolean algebra and propositional logic, Boolean variables _x, y,_ ... become _[propositional variables](https://en.wikipedia.org/wiki/Propositional\_variable "Propositional variable")_ (or _atoms_) _P, Q_, ... Boolean terms such as _x_ ∨ _y_ become propositional formulas _P_ ∨ _Q_; 0 becomes _false_ or **⊥**, and 1 becomes _true_ or **⊤**. It is convenient when referring to generic propositions to use Greek letters Φ, Ψ, ... as metavariables (variables outside the language of propositional calculus, used when talking _about_ propositional calculus) to denote propositions.

The semantics of propositional logic rely on _[truth assignments](https://en.wikipedia.org/wiki/Truth\_assignment "Truth assignment")_. The essential idea of a truth assignment is that the propositional variables are mapped to elements of a fixed Boolean algebra, and then the _[truth value](https://en.wikipedia.org/wiki/Truth\_value "Truth value")_ of a propositional formula using these letters is the element of the Boolean algebra that is obtained by computing the value of the Boolean term corresponding to the formula. In classical semantics, only the two-element Boolean algebra is used, while in [Boolean-valued semantics](https://en.wikipedia.org/wiki/Boolean-valued_semantics "Boolean-valued semantics") arbitrary Boolean algebras are considered. A _[tautology](https://en.wikipedia.org/wiki/Tautology\_(logic) "Tautology (logic)")_ is a propositional formula that is assigned truth value _1_ by every truth assignment of its propositional variables to an arbitrary Boolean algebra (or, equivalently, every truth assignment to the two element Boolean algebra).

These semantics permit a translation between tautologies of propositional logic and equational theorems of Boolean algebra. Every tautology Φ of propositional logic can be expressed as the Boolean equation Φ = 1, which will be a theorem of Boolean algebra. Conversely, every theorem Φ = Ψ of Boolean algebra corresponds to the tautologies (Φ ∨ ¬Ψ) ∧ (¬Φ ∨ Ψ) and (Φ ∧ Ψ) ∨ (¬Φ ∧ ¬Ψ). If → is in the language, these last tautologies can also be written as (Φ → Ψ) ∧ (Ψ → Φ), or as two separate theorems Φ → Ψ and Ψ → Φ; if ≡ is available, then the single tautology Φ ≡ Ψ can be used.

One motivating application of propositional calculus is the analysis of propositions and deductive arguments in natural language.[[33]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Allwood_1977-33) Whereas the proposition "if _x_ = 3, then _x_ + 1 = 4" depends on the meanings of such symbols as + and 1, the proposition "if _x_ = 3, then _x_ = 3" does not; it is true merely by virtue of its structure, and remains true whether "_x_ = 3" is replaced by "_x_ = 4" or "the moon is made of green cheese." The generic or abstract form of this tautology is "if _P_, then _P_," or in the language of Boolean algebra, _P_ → _P_.[_[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation\_needed "Wikipedia:Citation needed")_]

Replacing _P_ by _x_ = 3 or any other proposition is called _instantiation_ of _P_ by that proposition. The result of instantiating _P_ in an abstract proposition is called an _instance_ of the proposition. Thus, _x_ = 3 → _x_ = 3 is a tautology by virtue of being an instance of the abstract tautology _P_ → _P_. All occurrences of the instantiated variable must be instantiated with the same proposition, to avoid such nonsense as _P_ → _x_ = 3 or _x_ = 3 → _x_ = 4.

Propositional calculus restricts attention to abstract propositions, those built up from propositional variables using Boolean operations. Instantiation is still possible within propositional calculus, but only by instantiating propositional variables by abstract propositions, such as instantiating _Q_ by _Q_ → _P_ in _P_ → (_Q_ → _P_) to yield the instance _P_ → ((_Q_ → _P_) → _P_).

(The availability of instantiation as part of the machinery of propositional calculus avoids the need for metavariables within the language of propositional calculus, since ordinary propositional variables can be considered within the language to denote arbitrary propositions. The metavariables themselves are outside the reach of instantiation, not being part of the language of propositional calculus but rather part of the same language for talking about it that this sentence is written in, where there is a need to be able to distinguish propositional variables and their instantiations as being distinct syntactic entities.)

### Deductive systems for propositional logic

[[edit](https://en.wikipedia.org/w/index.php?title=Boolean_algebra&action=edit&section=23 "Edit section: Deductive systems for propositional logic")]

An axiomatization of propositional calculus is a set of tautologies called _[axioms](https://en.wikipedia.org/wiki/Axioms "Axioms")_ and one or more inference rules for producing new tautologies from old. A _proof_ in an axiom system _A_ is a finite nonempty sequence of propositions each of which is either an instance of an axiom of _A_ or follows by some rule of _A_ from propositions appearing earlier in the proof (thereby disallowing circular reasoning). The last proposition is the _theorem_ proved by the proof. Every nonempty initial segment of a proof is itself a proof, whence every proposition in a proof is itself a theorem. An axiomatization is _sound_ when every theorem is a tautology, and _complete_ when every tautology is a theorem.[[34]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Hausman-Tidman_2007-34)

Propositional calculus is commonly organized as a [Hilbert system](https://en.wikipedia.org/wiki/Hilbert_system "Hilbert system"), whose operations are just those of Boolean algebra and whose theorems are Boolean tautologies, those Boolean terms equal to the Boolean constant 1. Another form is [sequent calculus](https://en.wikipedia.org/wiki/Sequent_calculus "Sequent calculus"), which has two sorts, propositions as in ordinary propositional calculus, and pairs of lists of propositions called _[sequents](https://en.wikipedia.org/wiki/Sequent "Sequent")_, such as _A_ ∨ _B_, _A_ ∧ _C_, ... ⊢ _A_, _B_ → _C_, .... The two halves of a sequent are called the antecedent and the succedent respectively. The customary metavariable denoting an antecedent or part thereof is Γ, and for a succedent Δ; thus Γ, _A_ ⊢ Δ would denote a sequent whose succedent is a list Δ and whose antecedent is a list Γ with an additional proposition _A_ appended after it. The antecedent is interpreted as the conjunction of its propositions, the succedent as the disjunction of its propositions, and the sequent itself as the [entailment](https://en.wikipedia.org/wiki/Entailment "Entailment") of the succedent by the antecedent.

Entailment differs from implication in that whereas the latter is a binary _operation_ that returns a value in a Boolean algebra, the former is a binary _relation_ which either holds or does not hold. In this sense, entailment is an _external_ form of implication, meaning external to the Boolean algebra, thinking of the reader of the sequent as also being external and interpreting and comparing antecedents and succedents in some Boolean algebra. The natural interpretation of ⊢ is as ≤ in the partial order of the Boolean algebra defined by _x_ ≤ _y_ just when _x_ ∨ _y_ = _y_. This ability to mix external implication ⊢ and internal implication → in the one logic is among the essential differences between sequent calculus and propositional calculus.[[35]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Girard-Tylor-Lafont_1989-35)

Boolean algebra as the calculus of two values is fundamental to computer circuits, computer programming, and mathematical logic, and is also used in other areas of mathematics such as set theory and statistics.[[5]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-Givant-Halmos_2009-5)

In the early 20th century, several electrical engineers[_[who?](https://en.wikipedia.org/wiki/Wikipedia:Manual\_of\_Style/Words\_to\_watch#Unsupported\_attributions "Wikipedia:Manual of Style/Words to watch")_] intuitively recognized that Boolean algebra was analogous to the behavior of certain types of electrical circuits. [Claude Shannon](https://en.wikipedia.org/wiki/Claude_Shannon "Claude Shannon") formally proved such behavior was logically equivalent to Boolean algebra in his 1937 master's thesis, _[A Symbolic Analysis of Relay and Switching Circuits](https://en.wikipedia.org/wiki/A\_Symbolic\_Analysis\_of\_Relay\_and\_Switching\_Circuits "A Symbolic Analysis of Relay and Switching Circuits")_.

Today, all modern general-purpose [computers](https://en.wikipedia.org/wiki/Computer "Computer") perform their functions using two-value Boolean logic; that is, their electrical circuits are a physical manifestation of two-value Boolean logic. They achieve this in various ways: as [voltages on wires](https://en.wikipedia.org/wiki/Digital_signal "Digital signal") in high-speed circuits and capacitive storage devices, as orientations of a [magnetic domain](https://en.wikipedia.org/wiki/Magnetic_storage "Magnetic storage") in ferromagnetic storage devices, as holes in [punched cards](https://en.wikipedia.org/wiki/Punched_card "Punched card") or [paper tape](https://en.wikipedia.org/wiki/Paper_tape "Paper tape"), and so on. (Some early computers used decimal circuits or mechanisms instead of two-valued logic circuits.)

Of course, it is possible to code more than two symbols in any given medium. For example, one might use respectively 0, 1, 2, and 3 volts to code a four-symbol alphabet on a wire, or holes of different sizes in a punched card. In practice, the tight constraints of high speed, small size, and low power combine to make noise a major factor. This makes it hard to distinguish between symbols when there are several possible symbols that could occur at a single site. Rather than attempting to distinguish between four voltages on one wire, digital designers have settled on two voltages per wire, high and low.

Computers use two-value Boolean circuits for the above reasons. The most common computer architectures use ordered sequences of Boolean values, called bits, of 32 or 64 values, e.g. 01101000110101100101010101001011. When programming in [machine code](https://en.wikipedia.org/wiki/Machine_code "Machine code"), [assembly language](https://en.wikipedia.org/wiki/Assembly_language "Assembly language"), and certain other [programming languages](https://en.wikipedia.org/wiki/Programming_languages "Programming languages"), programmers work with the low-level digital structure of the [data registers](https://en.wikipedia.org/wiki/Word_(data_type) "Word (data type)"). These registers operate on voltages, where zero volts represents Boolean 0, and a reference voltage (often +5 V, +3.3 V, or +1.8 V) represents Boolean 1. Such languages support both numeric operations and logical operations. In this context, "numeric" means that the computer treats sequences of bits as [binary numbers](https://en.wikipedia.org/wiki/Binary_number "Binary number") (base two numbers) and executes arithmetic operations like add, subtract, multiply, or divide. "Logical" refers to the Boolean logical operations of disjunction, conjunction, and negation between two sequences of bits, in which each bit in one sequence is simply compared to its counterpart in the other sequence. Programmers therefore have the option of working in and applying the rules of either numeric algebra or Boolean algebra as needed. A core differentiating feature between these families of operations is the existence of the [carry](https://en.wikipedia.org/wiki/Carry_(arithmetic) "Carry (arithmetic)") operation in the first but not the second.

Other areas where two values is a good choice are the law and mathematics. In everyday relaxed conversation, nuanced or complex answers such as "maybe" or "only on the weekend" are acceptable. In more focused situations such as a court of law or theorem-based mathematics, however, it is deemed advantageous to frame questions so as to admit a simple yes-or-no answer—is the defendant guilty or not guilty, is the proposition true or false—and to disallow any other answer. However, limiting this might prove in practice for the respondent, the principle of the simple yes–no question has become a central feature of both judicial and mathematical logic, making [two-valued logic](https://en.wikipedia.org/wiki/Two-valued_logic "Two-valued logic") deserving of organization and study in its own right.

A central concept of set theory is membership. An organization may permit multiple degrees of membership, such as novice, associate, and full. With sets, however, an element is either in or out. The candidates for membership in a set work just like the wires in a digital computer: each candidate is either a member or a nonmember, just as each wire is either high or low.

Algebra being a fundamental tool in any area amenable to mathematical treatment, these considerations combine to make the algebra of two values of fundamental importance to computer hardware, mathematical logic, and set theory.

Two-valued logic can be extended to [multi-valued logic](https://en.wikipedia.org/wiki/Multi-valued_logic "Multi-valued logic"), notably by replacing the Boolean domain {0,1} with the unit interval [0,1], in which case rather than only taking values 0 or 1, any value between and including 0 and 1 can be assumed. Algebraically, negation (NOT) is replaced with 1−_x_, conjunction (AND) is replaced with multiplication (_xy_), and disjunction (OR) is defined via [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_law "De Morgan's law"). Interpreting these values as logical [truth values](https://en.wikipedia.org/wiki/Truth_value "Truth value") yields a multi-valued logic, which forms the basis for [fuzzy logic](https://en.wikipedia.org/wiki/Fuzzy_logic "Fuzzy logic") and [probabilistic logic](https://en.wikipedia.org/wiki/Probabilistic_logic "Probabilistic logic"). In these interpretations, a value is interpreted as the "degree" of truth – to what extent a proposition is true, or the probability that the proposition is true.

The original application for Boolean operations was [mathematical logic](https://en.wikipedia.org/wiki/Mathematical_logic "Mathematical logic"), where it combines the truth values, true or false, of individual formulas.

Natural languages such as English have words for several Boolean operations, in particular conjunction (_and_), disjunction (_or_), negation (_not_), and implication (_implies_). _But not_ is synonymous with _and not_. When used to combine situational assertions such as "the block is on the table" and "cats drink milk", which naïvely are either true or false, the meanings of these [logical connectives](https://en.wikipedia.org/wiki/Logical_connective "Logical connective") often have the meaning of their logical counterparts. However, with descriptions of behavior such as "Jim walked through the door", one starts to notice differences such as failure of commutativity, for example, the conjunction of "Jim opened the door" with "Jim walked through the door" in that order is not equivalent to their conjunction in the other order, since _and_ usually means _and then_ in such cases. Questions can be similar: the order "Is the sky blue, and why is the sky blue?" makes more sense than the reverse order. Conjunctive commands about behavior are like behavioral assertions, as in _get dressed and go to school_. Disjunctive commands such _love me or leave me_ or _fish or cut bait_ tend to be asymmetric via the implication that one alternative is less preferable. Conjoined nouns such as _tea and milk_ generally describe aggregation as with set union while _tea or milk_ is a choice. However, context can reverse these senses, as in _your choices are coffee and tea_ which usually means the same as _your choices are coffee or tea_ (alternatives). Double negation, as in "I don't not like milk", rarely means literally "I do like milk" but rather conveys some sort of hedging, as though to imply that there is a third possibility. "Not not P" can be loosely interpreted as "surely P", and although _P_ necessarily implies "not not _P_," the converse is suspect in English, much as with [intuitionistic logic](https://en.wikipedia.org/wiki/Intuitionistic_logic "Intuitionistic logic"). In view of the highly idiosyncratic usage of conjunctions in natural languages, Boolean algebra cannot be considered a reliable framework for interpreting them.

Boolean operations are used in [digital logic](https://en.wikipedia.org/wiki/Digital_logic "Digital logic") to combine the bits carried on individual wires, thereby interpreting them over {0,1}. When a vector of _n_ identical binary gates are used to combine two bit vectors each of _n_ bits, the individual bit operations can be understood collectively as a single operation on values from a [Boolean algebra](https://en.wikipedia.org/wiki/Boolean_algebra_(structure) "Boolean algebra (structure)") with 2 _n_ elements.

[Naive set theory](https://en.wikipedia.org/wiki/Naive_set_theory "Naive set theory") interprets Boolean operations as acting on subsets of a given set _X_. As we saw earlier this behavior exactly parallels the coordinate-wise combinations of bit vectors, with the union of two sets corresponding to the disjunction of two bit vectors and so on.

The 256-element free Boolean algebra on three generators is deployed in [computer displays](https://en.wikipedia.org/wiki/Computer_displays "Computer displays") based on [raster graphics](https://en.wikipedia.org/wiki/Raster_graphics "Raster graphics"), which use [bit blit](https://en.wikipedia.org/wiki/Bit_blit "Bit blit") to manipulate whole regions consisting of [pixels](https://en.wikipedia.org/wiki/Pixels "Pixels"), relying on Boolean operations to specify how the source region should be combined with the destination, typically with the help of a third region called the [mask](https://en.wikipedia.org/wiki/Mask_(computing) "Mask (computing)"). Modern [video cards](https://en.wikipedia.org/wiki/Video_cards "Video cards") offer all 2 2 3 = 256 ternary operations for this purpose, with the choice of operation being a one-byte (8-bit) parameter. The constants SRC = 0xaa or 0b10101010, DST = 0xcc or 0b11001100, and MSK = 0xf0 or 0b11110000 allow Boolean operations such as `(SRC^DST)&MSK` (meaning XOR the source and destination and then AND the result with the mask) to be written directly as a constant denoting a byte calculated at compile time, 0x80 in the `(SRC^DST)&MSK` example, 0x88 if just `SRC^DST`, etc. At run time the video card interprets the byte as the raster operation indicated by the original expression in a uniform way that requires remarkably little hardware and which takes time completely independent of the complexity of the expression.

[Solid modeling](https://en.wikipedia.org/wiki/Solid_modeling "Solid modeling") systems for [computer aided design](https://en.wikipedia.org/wiki/Computer_aided_design "Computer aided design") offer a variety of methods for building objects from other objects, combination by Boolean operations being one of them. In this method the space in which objects exist is understood as a set _S_ of [voxels](https://en.wikipedia.org/wiki/Voxel "Voxel") (the three-dimensional analogue of pixels in two-dimensional graphics) and shapes are defined as subsets of _S_, allowing objects to be combined as sets via union, intersection, etc. One obvious use is in building a complex shape from simple shapes simply as the union of the latter. Another use is in sculpting understood as removal of material: any grinding, milling, routing, or drilling operation that can be performed with physical machinery on physical materials can be simulated on the computer with the Boolean operation _x_ ∧ ¬_y_ or _x_ − _y_, which in set theory is set difference, remove the elements of _y_ from those of _x_. Thus given two shapes one to be machined and the other the material to be removed, the result of machining the former to remove the latter is described simply as their set difference.

Search engine queries also employ Boolean logic. For this application, each web page on the Internet may be considered to be an "element" of a "set." The following examples use a syntax supported by [Google](https://en.wikipedia.org/wiki/Google "Google").[[NB 1]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-NB2-36)

*   Doublequotes are used to combine whitespace-separated words into a single search term.[[NB 2]](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_note-NB3-37)
*   Whitespace is used to specify logical AND, as it is the default operator for joining search terms:

"Search term 1" "Search term 2"

*   The OR keyword is used for logical OR:

"Search term 1" OR "Search term 2"

*   A prefixed minus sign is used for logical NOT:

"Search term 1" −"Search term 2"

*   [Boolean algebras canonically defined](https://en.wikipedia.org/wiki/Boolean_algebras_canonically_defined "Boolean algebras canonically defined")
*   [Boolean differential calculus](https://en.wikipedia.org/wiki/Boolean_differential_calculus "Boolean differential calculus")
*   [Booleo](https://en.wikipedia.org/wiki/Booleo "Booleo")
*   [Cantor algebra](https://en.wikipedia.org/wiki/Cantor_algebra "Cantor algebra")
*   [Heyting algebra](https://en.wikipedia.org/wiki/Heyting_algebra "Heyting algebra")
*   [List of Boolean algebra topics](https://en.wikipedia.org/wiki/List_of_Boolean_algebra_topics "List of Boolean algebra topics")
*   [Logic design](https://en.wikipedia.org/wiki/Logic_design "Logic design")
*   _[Principia Mathematica](https://en.wikipedia.org/wiki/Principia\_Mathematica "Principia Mathematica")_
*   [Three-valued logic](https://en.wikipedia.org/wiki/Three-valued_logic "Three-valued logic")
*   [Vector logic](https://en.wikipedia.org/wiki/Vector_logic "Vector logic")

1.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-NB2_36-0)**Not all search engines support the same query syntax. Additionally, some organizations (such as Google) provide "specialized" search engines that support alternate or extended syntax. (See, [Syntax cheatsheet](https://www.google.com/help/cheatsheet.html).) The now-defunct Google code search used to support regular expressions but no longer exists.
2.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-NB3_37-0)**Doublequote-delimited search terms are called "exact phrase" searches in the Google documentation.

1.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Boole_2011_1-0)**[Boole, George](https://en.wikipedia.org/wiki/George_Boole "George Boole") (2011-07-28). [_The Mathematical Analysis of Logic - Being an Essay Towards a Calculus of Deductive Reasoning_](https://www.gutenberg.org/ebooks/36884).
2.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Boole_1854_2-0)**[Boole, George](https://en.wikipedia.org/wiki/George_Boole "George Boole") (2003) [1854]. _An Investigation of the Laws of Thought_. [Prometheus Books](https://en.wikipedia.org/wiki/Prometheus_Books "Prometheus Books"). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-1-59102-089-9](https://en.wikipedia.org/wiki/Special:BookSources/978-1-59102-089-9 "Special:BookSources/978-1-59102-089-9").
3.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Huntington_1933_3-0)**"The name Boolean algebra (or Boolean 'algebras') for the calculus originated by Boole, extended by Schröder, and perfected by Whitehead seems to have been first suggested by Sheffer, in 1913." [Edward Vermilye Huntington](https://en.wikipedia.org/wiki/Edward_Vermilye_Huntington "Edward Vermilye Huntington"), "[New sets of independent postulates for the algebra of logic, with special reference to Whitehead and Russell's _Principia mathematica_](https://www.ams.org/journals/tran/1933-035-01/S0002-9947-1933-1501684-X/S0002-9947-1933-1501684-X.pdf)", in _[Transactions of the American Mathematical Society](https://en.wikipedia.org/wiki/Transactions\_of\_the\_American\_Mathematical\_Society "Transactions of the American Mathematical Society")_**35** (1933), 274-304; footnote, page 278.
4.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Peirce_1931_4-0)**[Peirce, Charles S.](https://en.wikipedia.org/wiki/Charles_Sanders_Peirce "Charles Sanders Peirce") (1931). [_Collected Papers_](https://books.google.com/books?id=3JJgOkGmnjEC&pg=RA1-PA13). Vol.3. [Harvard University Press](https://en.wikipedia.org/wiki/Harvard_University_Press "Harvard University Press"). p.13. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-674-13801-8](https://en.wikipedia.org/wiki/Special:BookSources/978-0-674-13801-8 "Special:BookSources/978-0-674-13801-8").
5.   ^ [_**a**_](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Givant-Halmos_2009_5-0)[_**b**_](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Givant-Halmos_2009_5-1)[_**c**_](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Givant-Halmos_2009_5-2)[_**d**_](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Givant-Halmos_2009_5-3)[_**e**_](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Givant-Halmos_2009_5-4)[_**f**_](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Givant-Halmos_2009_5-5)[_**g**_](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Givant-Halmos_2009_5-6)Givant, Steven R.; [Halmos, Paul Richard](https://en.wikipedia.org/wiki/Paul_Richard_Halmos "Paul Richard Halmos") (2009). [_Introduction to Boolean Algebras_](https://books.google.com/books?id=ORILyf8sF2sC&pg=PA22). Undergraduate Texts in Mathematics, [Springer](https://en.wikipedia.org/wiki/Springer_Science%2BBusiness_Media "Springer Science+Business Media"). pp.21–22. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-387-40293-2](https://en.wikipedia.org/wiki/Special:BookSources/978-0-387-40293-2 "Special:BookSources/978-0-387-40293-2").
6.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-6)**Nelson, Eric S. (2011). ["The Yijing and Philosophy: From Leibniz to Derrida"](https://philpapers.org/rec/NELTYA). _Journal of Chinese Philosophy_. **38** (3): 377–396. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1111/j.1540-6253.2011.01661.x](https://doi.org/10.1111%2Fj.1540-6253.2011.01661.x).
7.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Lenzen_7-0)**Lenzen, Wolfgang. ["Leibniz: Logic"](https://iep.utm.edu/leib-log). _[Internet Encyclopedia of Philosophy](https://en.wikipedia.org/wiki/Internet\_Encyclopedia\_of\_Philosophy "Internet Encyclopedia of Philosophy")_.
8.   ^ [_**a**_](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Dunn-Hardegree_2001_8-0)[_**b**_](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Dunn-Hardegree_2001_8-1)[_**c**_](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Dunn-Hardegree_2001_8-2)Dunn, J. Michael; Hardegree, Gary M. (2001). [_Algebraic methods in philosophical logic_](https://books.google.com/books?id=-AokWhbILUIC&pg=PA2). [Oxford University Press](https://en.wikipedia.org/wiki/Oxford_University_Press "Oxford University Press"). p.2. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-19-853192-0](https://en.wikipedia.org/wiki/Special:BookSources/978-0-19-853192-0 "Special:BookSources/978-0-19-853192-0").
9.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-9)**Bimbó, Katalin; Dunn, J. Michael (2008). [_Generalized Galois Logics: Relational Semantics of Nonclassical Logical Calculi_](https://www.google.com/books/edition/Generalized_Galois_Logics/Vu3uAAAAMAAJ?hl=en&gbpv=1&bsq=mh+stone+boolean+algebra+iso+proved&dq=mh+stone+boolean+algebra+iso+proved&printsec=frontcover). CSLI Publications. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-1-57586-573-7](https://en.wikipedia.org/wiki/Special:BookSources/978-1-57586-573-7 "Special:BookSources/978-1-57586-573-7").
10.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-10)**Stone, M. H. (1936). ["The Theory of Representation for Boolean Algebras"](https://www.jstor.org/stable/1989664). _Transactions of the American Mathematical Society_. **40** (1): 37–111. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.2307/1989664](https://doi.org/10.2307%2F1989664). [ISSN](https://en.wikipedia.org/wiki/ISSN_(identifier) "ISSN (identifier)")[0002-9947](https://search.worldcat.org/issn/0002-9947).
11.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Weisstein_11-0)**Weisstein, Eric W. ["Boolean Algebra"](https://mathworld.wolfram.com/BooleanAlgebra.html). _mathworld.wolfram.com_. Retrieved 2020-09-02.
12.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Balabanian-Carlson_2001_12-0)**Balabanian, Norman; Carlson, Bradley (2001). _Digital logic design principles_. John Wiley. pp.39–40. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-471-29351-4](https://en.wikipedia.org/wiki/Special:BookSources/978-0-471-29351-4 "Special:BookSources/978-0-471-29351-4")., [online sample](http://www.wiley.com/college/engin/balabanian293512/pdf/ch02.pdf)
13.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Rajaraman-Radhakrishnan_2008_13-0)**Rajaraman; Radhakrishnan (2008-03-01). [_Introduction To Digital Computer Design_](https://books.google.com/books?id=-8MvcOgsSjcC&pg=PA65). PHI Learning Pvt. Ltd. p.65. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-81-203-3409-0](https://en.wikipedia.org/wiki/Special:BookSources/978-81-203-3409-0 "Special:BookSources/978-81-203-3409-0").
14.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Camara_2010_14-0)**Camara, John A. (2010). [_Electrical and Electronics Reference Manual for the Electrical and Computer PE Exam_](https://books.google.com/books?id=rfHWHeU0jfsC&pg=SA41-PA3). www.ppi2pass.com. p.41. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-1-59126-166-7](https://en.wikipedia.org/wiki/Special:BookSources/978-1-59126-166-7 "Special:BookSources/978-1-59126-166-7").
15.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Chen_2007_15-0)**Shin-ichi Minato, Saburo Muroga (2007). "Chapter 29: Binary Decision Diagrams". In Chen, Wai-Kai (ed.). _The VLSI handbook_ (2 ed.). [CRC Press](https://en.wikipedia.org/wiki/CRC_Press "CRC Press"). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-8493-4199-1](https://en.wikipedia.org/wiki/Special:BookSources/978-0-8493-4199-1 "Special:BookSources/978-0-8493-4199-1").
16.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Parkes_2002_16-0)**Parkes, Alan (2002). [_Introduction to languages, machines and logic: computable languages, abstract machines and formal logic_](https://books.google.com/books?id=sUQXKy8KPcQC&pg=PA276). Springer. p.276. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-1-85233-464-2](https://en.wikipedia.org/wiki/Special:BookSources/978-1-85233-464-2 "Special:BookSources/978-1-85233-464-2").
17.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Barwise-Etchemendy_1999_17-0)**[Barwise, Jon](https://en.wikipedia.org/wiki/Jon_Barwise "Jon Barwise"); [Etchemendy, John](https://en.wikipedia.org/wiki/John_Etchemendy "John Etchemendy"); Allwein, Gerard; Barker-Plummer, Dave; Liu, Albert (1999). [_Language, proof, and logic_](https://archive.org/details/languageprooflog00barw). CSLI Publications. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-1-889119-08-3](https://en.wikipedia.org/wiki/Special:BookSources/978-1-889119-08-3 "Special:BookSources/978-1-889119-08-3").
18.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Goertzel_1994_18-0)**Goertzel, Ben (1994). [_Chaotic logic: language, thought, and reality from the perspective of complex systems science_](https://books.google.com/books?id=zVOWoXDunp8C&pg=PA48). Springer. p.48. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-306-44690-0](https://en.wikipedia.org/wiki/Special:BookSources/978-0-306-44690-0 "Special:BookSources/978-0-306-44690-0").
19.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Halmos_1963_19-0)**[Halmos, Paul Richard](https://en.wikipedia.org/wiki/Paul_Richard_Halmos "Paul Richard Halmos") (1963). Lectures on Boolean Algebras. van Nostrand.
20.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Bacon_20-0)**Bacon, Jason W. (2011). ["Computer Science 315 Lecture Notes"](https://web.archive.org/web/20211002001321/http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch13s02.html). Archived from [the original](http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch13s02.html) on 2021-10-02. Retrieved 2021-10-01.
21.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-21)**["Boolean Algebra - Expression, Rules, Theorems, and Examples"](https://www.geeksforgeeks.org/boolean-algebra/). _GeeksforGeeks_. 2021-09-24. Retrieved 2024-06-03.
22.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-22)**["Boolean Logical Operations"](https://www.uobabylon.edu.iq/eprints/publication_12_3018_1456.pdf)(PDF).
23.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-23)**["Boolean Algebra Operations"](https://bob.cs.sonoma.edu/IntroCompOrg-RPi/sec-balgebra.html). _bob.cs.sonoma.edu_. Retrieved 2024-06-03.
24.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-24)**["Boolean Algebra"](https://www2.seas.gwu.edu/~ayoussef/cs1311/BooleanAlgebra.pdf)(PDF).
25.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-ORegan_2008_25-0)**O'Regan, Gerard (2008). [_A brief history of computing_](https://books.google.com/books?id=081H96F1enMC&pg=PA33). Springer. p.33. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-1-84800-083-4](https://en.wikipedia.org/wiki/Special:BookSources/978-1-84800-083-4 "Special:BookSources/978-1-84800-083-4").
26.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-EoBA_26-0)**["Elements of Boolean Algebra"](http://www.ee.surrey.ac.uk/Projects/Labview/boolalgebra/). _www.ee.surrey.ac.uk_. Retrieved 2020-09-02.
27.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-McGee_2005_27-0)**McGee, Vann, [_Sentential Calculus Revisited: Boolean Algebra_](https://ocw.mit.edu/courses/linguistics-and-philosophy/24-241-logic-i-fall-2005/readings/chp24.pdf)(PDF)
28.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Goodstein_2012_28-0)**[Goodstein, Reuben Louis](https://en.wikipedia.org/wiki/Reuben_Louis_Goodstein "Reuben Louis Goodstein") (2012), "Chapter 4: Sentence Logic", _Boolean Algebra_, Courier Dover Publications, [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-48615497-8](https://en.wikipedia.org/wiki/Special:BookSources/978-0-48615497-8 "Special:BookSources/978-0-48615497-8")
29.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Venn_1880_29-0)**[Venn, John](https://en.wikipedia.org/wiki/John_Venn "John Venn") (July 1880). ["I. On the Diagrammatic and Mechanical Representation of Propositions and Reasonings"](https://www.cis.upenn.edu/~bhusnur4/cit592_fall2014/venn%20diagrams.pdf)(PDF). _[The London, Edinburgh, and Dublin Philosophical Magazine and Journal of Science](https://en.wikipedia.org/wiki/The\_London,\_Edinburgh,\_and\_Dublin\_Philosophical\_Magazine\_and\_Journal\_of\_Science "The London, Edinburgh, and Dublin Philosophical Magazine and Journal of Science")_. 5. **10** (59): 1–18. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1080/14786448008626877](https://doi.org/10.1080%2F14786448008626877). [Archived](https://web.archive.org/web/20170516204620/https://www.cis.upenn.edu/~bhusnur4/cit592_fall2014/venn%20diagrams.pdf)(PDF) from the original on 2017-05-16.[[1]](http://www.tandfonline.com/doi/abs/10.1080/14786448008626877)[[2]](https://books.google.com/books?id=k68vAQAAIAAJ&pg=PA1)
30.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Shannon_1949_30-0)**[Shannon, Claude](https://en.wikipedia.org/wiki/Claude_Shannon "Claude Shannon") (1949). "The Synthesis of Two-Terminal Switching Circuits". _[Bell System Technical Journal](https://en.wikipedia.org/wiki/Bell\_System\_Technical\_Journal "Bell System Technical Journal")_. **28**: 59–98. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1002/j.1538-7305.1949.tb03624.x](https://doi.org/10.1002%2Fj.1538-7305.1949.tb03624.x).
31.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Koppelberg_1989_31-0)**Koppelberg, Sabine (1989). "General Theory of Boolean Algebras". _Handbook of Boolean Algebras, Vol. 1 (ed. J. Donald Monk with Robert Bonnet)_. Amsterdam, Netherlands: [North Holland](https://en.wikipedia.org/wiki/North_Holland "North Holland"). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-444-70261-6](https://en.wikipedia.org/wiki/Special:BookSources/978-0-444-70261-6 "Special:BookSources/978-0-444-70261-6").
32.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-McCune_2002_32-0)**[McCune, William](https://en.wikipedia.org/wiki/William_McCune "William McCune"); Veroff, Robert; [Fitelson, Branden](https://en.wikipedia.org/wiki/Branden_Fitelson "Branden Fitelson"); Harris, Kenneth; Feist, Andrew; [Wos, Larry](https://en.wikipedia.org/wiki/Larry_Wos "Larry Wos") (2002), "Short single axioms for Boolean algebra", _[Journal of Automated Reasoning](https://en.wikipedia.org/wiki/Journal\_of\_Automated\_Reasoning "Journal of Automated Reasoning")_, **29** (1): 1–16, [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1023/A:1020542009983](https://doi.org/10.1023%2FA%3A1020542009983), [MR](https://en.wikipedia.org/wiki/MR_(identifier) "MR (identifier)")[1940227](https://mathscinet.ams.org/mathscinet-getitem?mr=1940227), [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)")[207582048](https://api.semanticscholar.org/CorpusID:207582048)
33.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Allwood_1977_33-0)**Allwood, Jens; Andersson, Gunnar-Gunnar; Andersson, Lars-Gunnar; Dahl, Osten (1977-09-15). [_Logic in Linguistics_](https://books.google.com/books?id=hXIpFPttDjgC&q=%22propositional+logic%22). [Cambridge University Press](https://en.wikipedia.org/wiki/Cambridge_University_Press "Cambridge University Press"). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-521-29174-3](https://en.wikipedia.org/wiki/Special:BookSources/978-0-521-29174-3 "Special:BookSources/978-0-521-29174-3").
34.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Hausman-Tidman_2007_34-0)**Hausman, Alan; Kahane, Howard; Tidman, Paul (2010) [2007]. _Logic and Philosophy: A Modern Introduction_. Wadsworth Cengage Learning. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-495-60158-6](https://en.wikipedia.org/wiki/Special:BookSources/978-0-495-60158-6 "Special:BookSources/978-0-495-60158-6").
35.   **[^](https://en.wikipedia.org/wiki/Boolean_algebra_(logic)#cite_ref-Girard-Tylor-Lafont_1989_35-0)**[Girard, Jean-Yves](https://en.wikipedia.org/wiki/Jean-Yves_Girard "Jean-Yves Girard"); Taylor, Paul; Lafont, Yves (1990) [1989]. [_Proofs and Types_](https://archive.org/details/proofstypes0000gira). [Cambridge University Press](https://en.wikipedia.org/wiki/Cambridge_University_Press "Cambridge University Press") (Cambridge Tracts in Theoretical Computer Science, 7). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-521-37181-0](https://en.wikipedia.org/wiki/Special:BookSources/978-0-521-37181-0 "Special:BookSources/978-0-521-37181-0").

*   Mano, Morris; Ciletti, Michael D. (2013). _Digital Design_. Pearson. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-13-277420-8](https://en.wikipedia.org/wiki/Special:BookSources/978-0-13-277420-8 "Special:BookSources/978-0-13-277420-8").
*   Whitesitt, J. Eldon (1995). _Boolean algebra and its applications_. [Courier Dover Publications](https://en.wikipedia.org/wiki/Courier_Dover_Publications "Courier Dover Publications"). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-486-68483-3](https://en.wikipedia.org/wiki/Special:BookSources/978-0-486-68483-3 "Special:BookSources/978-0-486-68483-3").
*   Dwinger, Philip (1971). _Introduction to Boolean algebras_. Würzburg, Germany: Physica Verlag.
*   [Sikorski, Roman](https://en.wikipedia.org/wiki/Roman_Sikorski "Roman Sikorski") (1969). _Boolean Algebras_ (3 ed.). Berlin, Germany: [Springer-Verlag](https://en.wikipedia.org/wiki/Springer-Verlag "Springer-Verlag"). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-387-04469-9](https://en.wikipedia.org/wiki/Special:BookSources/978-0-387-04469-9 "Special:BookSources/978-0-387-04469-9").
*   [Bocheński, Józef Maria](https://en.wikipedia.org/wiki/Boche%C5%84ski,_J%C3%B3zef_Maria "Bocheński, Józef Maria") (1959). _A Précis of Mathematical Logic_. Translated from the French and German editions by Otto Bird. Dordrecht, South Holland: D. Reidel.

### Historical perspective

[[edit](https://en.wikipedia.org/w/index.php?title=Boolean_algebra&action=edit&section=39 "Edit section: Historical perspective")]

*   [Boole, George](https://en.wikipedia.org/wiki/George_Boole "George Boole") (1848). ["The Calculus of Logic"](http://www.maths.tcd.ie/pub/HistMath/People/Boole/CalcLogic/CalcLogic.html). _[Cambridge and Dublin Mathematical Journal](https://en.wikipedia.org/wiki/Cambridge\_and\_Dublin\_Mathematical\_Journal "Cambridge and Dublin Mathematical Journal")_. **III**: 183–198.
*   Hailperin, Theodore (1986). _Boole's logic and probability: a critical exposition from the standpoint of contemporary algebra, logic, and probability theory_ (2 ed.). [Elsevier](https://en.wikipedia.org/wiki/Elsevier "Elsevier"). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-444-87952-3](https://en.wikipedia.org/wiki/Special:BookSources/978-0-444-87952-3 "Special:BookSources/978-0-444-87952-3").
*   Gabbay, Dov M.; Woods, John, eds. (2004). _The rise of modern logic: from Leibniz to Frege_. Handbook of the History of Logic. Vol.3. [Elsevier](https://en.wikipedia.org/wiki/Elsevier "Elsevier"). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-444-51611-4](https://en.wikipedia.org/wiki/Special:BookSources/978-0-444-51611-4 "Special:BookSources/978-0-444-51611-4")., several relevant chapters by Hailperin, Valencia, and Grattan-Guinness
*   Badesa, Calixto (2004). "Chapter 1. Algebra of Classes and Propositional Calculus". _The birth of model theory: Löwenheim's theorem in the frame of the theory of relatives_. [Princeton University Press](https://en.wikipedia.org/wiki/Princeton_University_Press "Princeton University Press"). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-0-691-05853-5](https://en.wikipedia.org/wiki/Special:BookSources/978-0-691-05853-5 "Special:BookSources/978-0-691-05853-5").
*   [Stanković, Radomir S.](https://de.wikipedia.org/wiki/Radomir_S._Stankovi%C4%87 "de:Radomir S. Stanković")[in German]; [Astola, Jaakko Tapio](https://fi.wikipedia.org/wiki/Jaakko_Tapio_Astola "fi:Jaakko Tapio Astola")[in Finnish] (2011). Written at Niš, Serbia & Tampere, Finland. [_From Boolean Logic to Switching Circuits and Automata: Towards Modern Information Technology_](https://books.google.com/books?id=ZuHwCAAAQBAJ). Studies in Computational Intelligence. Vol.335 (1 ed.). Berlin & Heidelberg, Germany: [Springer-Verlag](https://en.wikipedia.org/wiki/Springer-Verlag "Springer-Verlag"). pp.xviii + 212. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1007/978-3-642-11682-7](https://doi.org/10.1007%2F978-3-642-11682-7). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)")[978-3-642-11681-0](https://en.wikipedia.org/wiki/Special:BookSources/978-3-642-11681-0 "Special:BookSources/978-3-642-11681-0"). [ISSN](https://en.wikipedia.org/wiki/ISSN_(identifier) "ISSN (identifier)")[1860-949X](https://search.worldcat.org/issn/1860-949X). [LCCN](https://en.wikipedia.org/wiki/LCCN_(identifier) "LCCN (identifier)")[2011921126](https://lccn.loc.gov/2011921126). Retrieved 2022-10-25.
*   ["The Algebra of Logic Tradition"](https://plato.stanford.edu/entries/algebra-logic-tradition/) entry by Burris, Stanley in the _[Stanford Encyclopedia of Philosophy](https://en.wikipedia.org/wiki/Stanford\_Encyclopedia\_of\_Philosophy "Stanford Encyclopedia of Philosophy")_, 21 February 2012
