Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Concepts Toggle Concepts subsection 1.1 Corresponding days 1.2 Corresponding months 1.3 Corresponding years 1.4 Corresponding centuries 2 Tabular methods to calculate the day of the week Toggle Tabular methods to calculate the day of the week subsection 2.1 Complete table: Julian and Gregorian calendars 2.2 Revised Julian calendar 2.3 Dominical letter 2.4 The Doomsday 2.5 Result 2.5.1 The Sunday letter method 3 Mathematical algorithms Toggle Mathematical algorithms subsection 3.1 Rata Die 3.2 Gauss's algorithm 3.2.1 Worked example 3.2.2 Explanation and notes 3.2.3 Disparate variation 3.3 Zeller's algorithm 3.4 Wang's algorithm 4 Other algorithms Toggle Other algorithms subsection 4.1 Schwerdtfeger's method 4.2 Lewis Carroll's method 4.3 Methods in computer code 4.3.1 Keith 4.3.2 Sakamoto's methods 4.4 Gauss's method in MATLAB 4.5 Gauss's method for Gregorian calendar in Python 5 See also 6 References Toggle References subsection 6.1 Notes 6.2 Citations 6.3 Further reading 7 External links Toggle the table of contents Determination of the day of the week 15 languages العربية Asturianu Català Čeština Deutsch Español Français Nederlands Norsk bokmål Русский Slovenčina Српски / srpski Tagalog Українська 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Methods to calculate the day of the week The determination of the day of the week for any date may be performed with a variety of algorithms . In addition, perpetual calendars require no calculation by the user, and are essentially lookup tables.
A typical application is to calculate the day of the week on which someone was born or a specific event occurred.

Concepts [ edit ] In numerical calculation, the days of the week are represented as weekday numbers. If Monday is the first day of the week, the days may be coded 1 to 7, for Monday through Sunday, as is practiced in ISO 8601 . The day designated with 7 may also be counted as 0 , by applying the arithmetic modulo 7, which calculates the remainder of a number after division by 7. Thus, the number 7 is treated as 0, the number 8 as 1, the number 9 as 2, the number 18 as 4, and so on. If Sunday is counted as day 1, then 7 days later (i.e.

day 8) is also a Sunday, and day 18 is the same as day 4, which is a Wednesday since this falls three days after Sunday (i.e.

18 mod 7 = 4 ).

[ a ] Standard Monday Tuesday Wednesday Thursday Friday Saturday Sunday Usage examples ISO 8601 1 2 3 4 5 6 7 %_ISODOWI%, %@ISODOWI[]% ( 4DOS ); [ 1 ] DAYOFWEEK() ( HP Prime ) [ 2 ] 0 1 2 3 4 5 6 2 3 4 5 6 7 1 %NDAY OF WEEK% ( NetWare , DR-DOS [ 3 ] ); %_DOWI%, %@DOWI[]% ( 4DOS ) [ 1 ] 1 2 3 4 5 6 0 HP financial calculators The basic approach of nearly all of the methods to calculate the day of the week begins by starting from an "anchor date": a known pair (such as 1 January 1800 as a Wednesday), determining the number of days between the known day and the day to determine, and using arithmetic modulo 7 to find a new numerical day of the week.

One standard approach is to look up (or calculate, using a known rule) the value of the first day of the week of a given century, look up (or calculate, using a method of congruence) an adjustment for the month, calculate the number of leap years since the start of the century, and then add these together along with the number of years since the start of the century, and the day number of the month. Eventually, applying modulo 7 to the day count allows determining the day of the week of that date.

[ 4 ] Some methods do all the additions first and then cast out sevens, whereas others cast them out at each step, as in Lewis Carroll's method . Either way can have practical use: the former is easier for calculators and computer programs, whereas the latter is easier for mental calculation. None of the methods given here perform range checks, so unreasonable dates will produce erroneous results.

Corresponding days [ edit ] Every seventh day in a month has the same name as the previous: Day of the month d 00 07 14 21 28 0 01 08 15 22 29 1 02 09 16 23 30 2 03 10 17 24 31 3 04 11 18 25 4 05 12 19 26 5 06 13 20 27 6 Corresponding months [ edit ] "Corresponding months" are those months within the calendar year that start on the same day of the week. For example, September and December correspond, because 1 September falls on the same day as 1 December (as there are precisely thirteen 7-day weeks between the two dates). Months can only correspond if the number of days between their first days is divisible by 7, or in other words, if their first days are a whole number of weeks apart. For example, February of a common year corresponds to March because February has 28 days, a number divisible by 7, 28 days being exactly four weeks.
In a leap year , January and February correspond to different months than in a common year, since adding 29 February means each subsequent month starts a day later.

January corresponds to October in common years and April and July in leap years. February corresponds to March and November in common years and August in leap years. March always corresponds to November, April always corresponds to July, and September always corresponds to December. August does not correspond to any other month in a common year. October doesn't correspond to any other month in a leap year. May and June never correspond to any other month.

In the months table below, corresponding months have the same number, a fact which follows directly from the definition.

Common years Leap years All years m Jan Oct 0 May 1 Feb Aug 2 Feb Mar Nov 3 Jun 4 Sept Dec 5 Jan Apr July 6 Corresponding years [ edit ] This section may contain unverified or indiscriminate information in embedded lists .

Please help clean up the lists by removing items or incorporating them into the text of the article.

( March 2021 ) There are seven possible days that a year can start on, and leap years will alter the day of the week after 29 February. This means that there are 14 configurations that a year can have. All the configurations can be referenced by a dominical letter , but as 29 February has no letter allocated to it, a leap year has two dominical letters, one for January and February and the other (one step back in the alphabetical sequence) for March to December.

2021 is a common year starting on Friday, which means that it corresponds to the 2010 calendar year. The first two months of 2021 correspond to the first two months of 2016. 2022 is a common year starting on Saturday, which means that it corresponds to the 2011 calendar year. The last ten months of 2022 correspond to the last ten months of 2016. 2023 is a common year starting on Sunday, which means that it corresponds to the 2017 calendar year. 2024 is a leap year starting on Monday, which means that it corresponds to the 1996 calendar year. The first two months of 2024 correspond to the first two months of 2018. The last ten months of 2024 correspond to the last ten months of 2019.

Each leap year repeats once every 28 years, and every common year repeats once every 6 years and twice every 11 years. For instance, the last occurrence of a leap year starting on Wednesday was 2020 and the next occurrence will be 2048. Likewise, the next common years starting on Friday will be 2027, 2038, and then 2049. Both of these statements are true unless a leap year is skipped, of which will not happen until 2100.

For details, see the table below: Year of the century mod 28 y 00 06 12 17 23 0 01 07 12 18 24 1 02 08 13 19 24 2 03 08 14 20 25 3 04 09 15 20 26 4 04 10 16 21 27 5 05 11 16 22 00 6 Notes: Black means all the months of a common year Red means the first two months of a leap year Blue means the last ten months of a leap year Corresponding centuries [ edit ] Julian century mod 700 Gregorian century mod 400 [ b ] Day 400: 1100 1800 ...

300: 1500 1900 ...

Sun 300: 1000 1700 ...

Mon 200  0900 1600 ...

200: 1800 2200 ...

Tue 100  0800 1500 ...

Wed 700: 1400 2100 ...

100: 1700 2100 ...

Thu [ c ] 600: 1300 2000 ...

Fri 500: 1200 1900 ...

000: 1600 2000 ...

Sat "Year 000" is, in normal chronology, the year 1 BC (which precedes AD 1). In astronomical year numbering the year 0 comes between 1 BC and AD 1. In the proleptic Julian calendar , (that is, the Julian calendar as it would have been if it had been operated correctly from the start), 1 BC starts on Thursday. In the proleptic Gregorian calendar , (called such because it wasn't devised until 1582), 1 BC starts on Saturday.

Tabular methods to calculate the day of the week [ edit ] Complete table: Julian and Gregorian calendars [ edit ] For Julian dates before 1300 and after 1999 the year in the table which differs by an exact multiple of 700 years should be used. For Gregorian dates after 2299, the year in the table which differs by an exact multiple of 400 years should be used. The values " r0 " through " r6 " indicate the remainder when the Hundreds value is divided by 7 and 4 respectively, indicating how the series extend in either direction. Both Julian and Gregorian values are shown 1500–1999 for convenience. Bold figures (e.g., 04 ) denote leap year. If a year ends in 00 and its hundreds are in bold it is a leap year. Thus 19 indicates that 1900 is not a Gregorian leap year, (but 19 in the Julian column indicates that it is a Julian leap year, as are all Julian x 00 years).

20 indicates that 2000 is a leap year. Use Jan and Feb only in leap years.

Hundreds of years Remaining year digits Month DoW # Julian (r ÷ 7) Gregorian (r ÷ 4) r5 19 16 20 r0 00 06   17 23 28 34   45 51 56 62   73 79 84 90 Jan Oct Sa 0 r4 18 15 19 r3 01 07 12 18 29 35 40 46 57 63 68 74 85 91 96 May Su 1 r3 17 — 02   13 19 24 30   41 47 52 58   69 75 80 86   97 Feb Aug M 2 r2 16 18 22 r2 03 08 14   25 31 36 42   53 59 64 70   81 87 92 98 Feb Mar Nov Tu 3 r1 15 — 09 15 20 26 37 43 48 54 65 71 76 82 93 99 Jun W 4 r0 14 17 21 r1 04 10   21 27 32 38   49 55 60 66   77 83 88 94 Sep Dec Th 5 r6 13 — 05 11 16 22 33 39 44 50 61 67 72 78 89 95 Jan Apr Jul F 6 For determination of the day of the week (1 January 2000, Saturday) the day of the month: 1 ~ 31 (1) the month: (6) the year: (0) the century mod 4 for the Gregorian calendar and mod 7 for the Julian calendar (0) .

adding 1+6+0+0=7. Dividing by 7 leaves a remainder of 0, so the day of the week is Saturday.

The formula is w = (d + m + y + c) mod 7.

Revised Julian calendar [ edit ] Note that the date (and hence the day of the week) in the Revised Julian and Gregorian calendars is the same from 14 October 1923 to 28 February AD 2800 inclusive and that for large years it may be possible to subtract 6300 or a multiple thereof before starting so as to reach a year which is within or closer to the table.

To look up the weekday of any date for any year using the table, subtract 100 from the year, divide the difference by 100, multiply the resulting quotient (omitting fractions) by seven and divide the product by nine. Note the quotient (omitting fractions). Enter the table with the Julian year, and just before the final division add 50 and subtract the quotient noted above.

The following is an example of calculating the day of the week for 27 January 8315: 8315 − 6300 = 2015, 2015 − 100 = 1915, 1915 ÷ 100 = 19 remainder 15, 19 × 7 = 133, 133 ÷ 9 = 14 remainder }. 2015 is 700 years ahead of 1315, so 1315 is used. From table: for hundreds (13): 6. For remaining digits (15): 4. For month (January): 0. For date (27): 27.

{{{1}}} .

{{{1}}} . Thus, the day of the week is Thursday.

Dominical letter [ edit ] To find the dominical letter , calculate the day of the week for either 1 January or 1 October, and assign a letter with Sunday corresponding to A, Saturday corresponding to B, ... and Monday corresponding to G.

Leap years have two Sunday letters, so for January and February calculate the day of the week for 1 January; and for March to December calculate the day of the week for 1 October.

Leap years are all years which divide exactly by four with the following exceptions: In the Gregorian calendar – all years which divide exactly by 100 (other than those which divide exactly by 400).

In the Revised Julian calendar – all years which divide exactly by 100 (other than those which give remainder 200 or 600 when divided by 900).

The Doomsday [ edit ] Main article: Doomsday rule This section needs expansion . You can help by adding to it .

( July 2025 ) The Doomsday algorithm is an artefact of recreational mathematics.

Result [ edit ] The following is a table for finding the day of the week without calculation.

Index Mon A Tue B Wed C Thu D Fri E Sat F Sun G Perpetual Gregorian and Julian calendar Use Jan and Feb for leap years Date letter in year row for the letter in century row All the C days are doomsdays Julian century Gregorian century Date 01 08 15 22 29 02 09 16 23 30 03 10 17 24 31 04 11 18 25 05 12 19 26 06 13 20 27 07 14 21 28 12 19 16 20 Apr Jul Jan G A B C D E F 01 07 12 18 29 35 40 46 57 63 68 74 85 91 96 13 20 Sep Dec F G A B C D E 02 13 19 24 30 41 47 52 58 69 75 80 86 97 14 21 17 21 Jun E F G A B C D 03 08 14 25 31 36 42 53 59 64 70 81 87 92 98 15 22 Feb Mar Nov D E F G A B C 09 15 20 26 37 43 48 54 65 71 76 82 93 99 16 23 18 22 Aug Feb C D E F G A B 04 10 21 27 32 38 49 55 60 66 77 83 88 94 17 24 May B C D E F G A 05 11 16 22 33 39 44 50 61 67 72 78 89 95 18 25 19 23 Jan Oct A B C D E F G 06 17 23 28 34 45 51 56 62 73 79 84 90 0 0 [Year/100] Gregorian century 20 16 21 17 22 18 23 19 Year mod 100 Julian century 19 12 20 13 21 14 22 15 23 16 24 17 25 18 Examples: For common method 26 December 1893 (GD) December is in row F and 26 is in column E , so the letter for the date is C located in row F and column E . 93 (year mod 100) is in row D (year row) and the letter C in the year row is located in column G . 18 ([year/100] in the Gregorian century column) is in row C (century row) and the letter in the century row and column G is B, so the day of the week is Tuesday.

13 October 1307 (JD) October 13 is a F day. The letter F in the year row (07) is located in column G . The letter in the century row (13) and column G is E, so the day of the week is Friday.

1 January 2000 (GD) January 1 corresponds to G, G in the year row ( 0 0) corresponds to F in the century row ( 20 ), and F corresponds to Saturday.

A pithy formula for the method: "Date letter (G), letter (G) is in year row ( 0 0) for the letter (F) in century row ( 20 ), and for the day, the letter (F) become weekday (Saturday)" .

The Sunday letter method [ edit ] Each day of the year (other than 29 February) has a letter allocated to it in the recurring sequence ABCDEFG. The series begins with A on 1 January and continues to A again on 31 December. The Sunday letter is the one which stands against all the Sundays in the year. Since 29 February has no letter, this means that the Sunday letter for March to December is one step back in the sequence compared to that for January and February. The letter for any date will be found where the row containing the month (in black) at the left of the "Latin square" meets the column containing the date above the "Latin square". The Sunday letter will be found where the column containing the century (below the "Latin square") meets the row containing the year's last two digits to the right of the "Latin square". For a leap year, the Sunday letter thus found is the one which applies to March to December.

So, for example, to find the weekday of 16 June 2020: Column "20" meets row "20" at "D". Row "June" meets column "16" at "F". As F is two letters on from D, so the weekday is two days on from Sunday, i.e. Tuesday.

Mathematical algorithms [ edit ] Note on notation: In the following text, the backslash \ is used to indicate a "flooring integer division", and the percent sign % is used to indicate the remainder of such operation .

Rata Die [ edit ] The Rata Die method works by adding up the number of days d that has passed since a date of known day of the week D . The day of-the-week is then given by ( D + d ) mod 7 , conforming to whatever convention was used to encode D .

For example, the date of 13 August 2009 is 733632 days from 1 January AD 1. Taking the number mod 7 yields 4, hence a Thursday.

Gauss's algorithm [ edit ] Carl Friedrich Gauss described a method for calculating the day of the week for 1 January in any given year in a handwritten note in a collection of astronomical tables.

[ 5 ] He never published it. It was finally included in his collected works in 1927.

[ 6 ] Compared to Rata Die, the result helps simplify the counting of years.

Gauss's method was applicable to the Gregorian calendar. He numbered the weekdays from 0 to 6 starting with Sunday. He defined the following operation.

Inputs Year number A , month number M , date number D .

Output Day of year.

Procedure First determine the day-of-week d 1 of 1 January.

For a Gregorian calendar, the weekday is [ 5 ] (1 + 5(( A −1) % 4) + 4(( A −1) % 100) + 6(( A −1) % 400)) % 7.

Alternatively, set C = A \ 100 , Y = A % 100 , and the value is (1 + 5(( Y −1)%4) + 3( Y −1) + 5(C%4)) % 7.

For a Julian calendar, the weekday is (6 + 5(( A −1)%4) + 3( A −1)) % 7 or (6 + 5(( Y −1) % 4) + 3( Y −1) + 6C) % 7 .

Now determine the month-related offset m by using the lookup table with M .

Return d = ( d 1 + m + D ) % 7 .

Table of month offsets Months Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec Common years 0 3 3 6 1 4 6 2 5 0 3 5 Leap years 4 0 2 5 0 3 6 1 4 6 The above procedure can be condensed into a single expression for the Gregorian case: (D + m + 5(( A −1)%4) + 4(( A −1)%100) + 6(( A −1)%400))%7 Worked example [ edit ] For year number 2000, A − 1 = 1999 , Y − 1 = 99 and C = 19 , the weekday of 1 January is = (1 + 5(1999%4) + 4(1999%100) + 6(1999%400))%7 = (1 + 1 + 4 + 0) % 7 = 6 = (1 + 5(99%4) + 3 × 99 + 5(19%4))%7 = (1 + 1 + 3 + 1)%7 = 6 = Saturday.

For example, the weekdays for 30 April 1777 and 23 February 1855 are = (30 + 6 + 5(1776%4) + 4(1776%100) + 6(1776%400))%7 = (2 + 6 + 0 + 3 + 6)%7 = 3 =Wednesday and = (6 + 23 + ⌈ 2.6 × 12 ⌉ + 5(1854%4) + 4(1854%100) + 6(1854%400))%7 = (6 + 2 + 4 + 3 + 6 + 5)%7 = 5 = Friday.

Explanation and notes [ edit ] The algorithm for the day-of-week of 1 Jan can be proven using modulo arithmetic. The main point is that because 365 % 7 = 1 , each year adds 1 day to the progression. The rest is adjustment for leap year. The century-based versions have 36525 % 7 = 6 .

The table of month offsets show a divergence in February due to the leap year. A common technique (later used by Zeller) is to shift the month to start with March, so that the leap day is at the tail of the counting. In addition, as later shown by Zeller, the table can be replaced with an arithmetic expression.

This formula was also converted into graphical and tabular methods for calculating any day of the week by Kraitchik and Schwerdtfeger.

[ 6 ] [ 7 ] Disparate variation [ edit ] The following formula is an example of a version without a lookup table. The year is assumed to begin in March, meaning dates in January and February should be treated as being part of the preceding year. The formula for the Gregorian calendar is [ 8 ] w = ( d + ⌊ ⌊ 2.6 m − − 0.2 ⌋ ⌋ + y + ⌊ y 4 ⌋ + ⌊ c 4 ⌋ − − 2 c ) mod 7 , {\displaystyle w=\left(d+\lfloor 2.6m-0.2\rfloor +y+\left\lfloor {\frac {y}{4}}\right\rfloor +\left\lfloor {\frac {c}{4}}\right\rfloor -2c\right){\bmod {7}},} where d is the day of the month (1 to 31) m is the shifted month (March = 1,...,February = 12) Y is the year unless m is 11 = January or 12 = February which are considered part of the preceding year, giving Y = year − 1 c is the century given by c = ⌊ ⌊ Y / 100 ⌋ ⌋ {\displaystyle c=\lfloor Y/100\rfloor } y is the year relative to the century, given by y = Y − − 100 c {\displaystyle y=Y-100c} , or simply the last 2 digits of Y w is the day of the week (0 = Sunday,...,6 = Saturday) Table of month offsets ( ⌊ ⌊ 2.6 m − − 0.2 ⌋ ⌋ {\displaystyle \lfloor 2.6m-0.2\rfloor } ) Months Mar Apr May Jun Jul Aug Sep Oct Nov Dec Jan Feb Offset 2 5 7 10 12 15 18 20 23 25 28 31 Zeller's algorithm [ edit ] Main article: Zeller's congruence In Zeller's algorithm, the months are numbered from 3 for March to 14 for February. The year is assumed to begin in March; this means, for example, that January 1995 is to be treated as month 13 of 1994.

[ 9 ] The formula for the Gregorian calendar is w ≡ ≡ ( ⌊ 13 ( m + 1 ) 5 ⌋ + ⌊ y 4 ⌋ + ⌊ c 4 ⌋ + d + y − − 2 c ) mod 7 {\displaystyle w\equiv \left(\left\lfloor {\frac {13(m+1)}{5}}\right\rfloor +\left\lfloor {\frac {y}{4}}\right\rfloor +\left\lfloor {\frac {c}{4}}\right\rfloor +d+y-2c\right){\bmod {7}}} where d {\displaystyle d} is the day of the month (1 to 31) m {\displaystyle m} is the shifted month (March=3,...January = 13, February=14) Y {\displaystyle Y} is the year unless m {\displaystyle m} is 13 = January or 14 = February which are considered part of the preceding year giving Y = year − − 1 {\displaystyle Y={\textit {year}}-1} c {\displaystyle c} is the century given by c = ⌊ ⌊ Y / 100 ⌋ ⌋ {\displaystyle c=\lfloor Y/100\rfloor } y {\displaystyle y} is the year relative to the century, given by y = Y − − 100 c {\displaystyle y=Y-100c} , or simply the last 2 digits of Y {\displaystyle Y} w {\displaystyle w} is the day of week (1 = Sunday,..0 = Saturday) Table of month offsets ( ⌊ ⌊ 2.6 ( m + 1 ) ⌋ ⌋ {\displaystyle \lfloor 2.6(m+1)\rfloor } ) Months Mar Apr May Jun Jul Aug Sep Oct Nov Dec Jan Feb Offset 10 13 15 18 20 23 26 28 31 33 36 39 The only difference is one between Zeller's algorithm ( Z ) and the Disparate Gaussian algorithm ( G ), that is Z − G = 1 = Sunday .

( d + ⌊ ⌊ ( m + 1 ) 2.6 ⌋ ⌋ + y + ⌊ ⌊ y / 4 ⌋ ⌋ + ⌊ ⌊ c / 4 ⌋ ⌋ − − 2 c ) mod 7 − − ( d + ⌊ ⌊ 2.6 m − − 0.2 ⌋ ⌋ + y + ⌊ ⌊ y / 4 ⌋ ⌋ + ⌊ ⌊ c / 4 ⌋ ⌋ − − 2 c ) mod 7 {\displaystyle (d+\lfloor (m+1)2.6\rfloor +y+\lfloor y/4\rfloor +\lfloor c/4\rfloor -2c){\bmod {7}}-(d+\lfloor 2.6m-0.2\rfloor +y+\lfloor y/4\rfloor +\lfloor c/4\rfloor -2c){\bmod {7}}} = ( ⌊ ⌊ ( m + 2 + 1 ) 2.6 − − ( 2.6 m − − 0.2 ) ⌋ ⌋ ) mod 7 {\displaystyle =(\lfloor (m+2+1)2.6-(2.6m-0.2)\rfloor ){\bmod {7}}} (March = 3 in Z but March = 1 in G ) = ( ⌊ ⌊ 2.6 m + 7.8 − − 2.6 m + 0.2 ⌋ ⌋ ) mod 7 {\displaystyle =(\lfloor 2.6m+7.8-2.6m+0.2\rfloor ){\bmod {7}}} = 8 mod 7 = 1 {\displaystyle =8{\bmod {7}}=1} Wang's algorithm [ edit ] Wang's algorithm [ 10 ] for human calculation of the Gregorian calendar is (the formula should be subtracted by 1 if m is 1 or 2 if the year is a leap year) w = ( d − − d 0 ( m ) + y 0 − − y 1 + ⌊ y 0 / 4 − − y 1 / 2 ⌋ − − 2 ( c mod 4 ) ) mod 7 , {\displaystyle w=\left(d-d_{0}(m)+y_{0}-y_{1}+\left\lfloor y_{0}/4-y_{1}/2\right\rfloor -2\left(c{\bmod {4}}\right)\right){\bmod {7}},} where ⁠ y 0 {\displaystyle y_{0}} ⁠ is the last digit of the year ( units) ⁠ y 1 {\displaystyle y_{1}} ⁠ is the second last digit of the year ( tens ) ⁠ c {\displaystyle c} ⁠ is the century, given by c = ⌊ ⌊ year / 100 ⌋ ⌋ {\displaystyle c=\lfloor {\textit {year}}/100\rfloor } ⁠ d {\displaystyle d} ⁠ is the day of the month (1 to 31) ⁠ m {\displaystyle m} ⁠ is the month (January=1,...,December=12) ⁠ w {\displaystyle w} ⁠ is the day of the week (0=Sunday,...,6=Saturday) ⁠ d 0 ( m ) {\displaystyle d_{0}(m)} ⁠ is the null-days function (month offset) with values listed in the following table m ⁠ d 0 ( m ) {\displaystyle d_{0}(m)} ⁠ 1 1 A day 3 5 m + 2 5 7 7 9 9 3 m + 1 11 12 2 12 m + 3 4 2 m − 2 6 4 8 6 10 8 12 10 An algorithm for the Julian calendar can be derived from the algorithm above w = ( d − − d 0 ( m ) + y 0 − − y 1 + ⌊ y 0 / 4 − − y 1 / 2 ⌋ − − c ) mod 7 , {\displaystyle w=\left(d-d_{0}(m)+y_{0}-y_{1}+\left\lfloor y_{0}/4-y_{1}/2\right\rfloor -c\right){\bmod {7}},} where ⁠ d 0 ( m ) {\displaystyle d_{0}(m)} ⁠ is a doomsday.

m ⁠ d 0 ( m ) {\displaystyle d_{0}(m)} ⁠ 1 3 C day 3 7 m + 4 5 9 7 11 9 5 m − 4 11 7 2 0 m − 2 4 4 m 6 6 8 8 10 10 12 12 Other algorithms [ edit ] Schwerdtfeger's method [ edit ] In a partly tabular method by Schwerdtfeger, the year is split into the century and the two digit year within the century. The approach depends on the month. For m ≥ 3 , c = ⌊ y 100 ⌋ and g = y − − 100 c , {\displaystyle c=\left\lfloor {\frac {y}{100}}\right\rfloor \quad {\text{and}}\quad g=y-100c,} so g is between 0 and 99. For m = 1,2 , c = ⌊ y − − 1 100 ⌋ and g = y − − 1 − − 100 c .

{\displaystyle c=\left\lfloor {\frac {y-1}{100}}\right\rfloor \quad {\text{and}}\quad g=y-1-100c.} The formula for the day of the week is [ 6 ] w = ( d + e + f + g + ⌊ g 4 ⌋ ) mod 7 , {\displaystyle w=\left(d+e+f+g+\left\lfloor {\frac {g}{4}}\right\rfloor \right){\bmod {7}},} where the positive modulus is chosen.

[ 6 ] The value of e is obtained from the following table: m 1 2 3 4 5 6 7 8 9 10 11 12 e 0 3 2 5 0 3 5 1 4 6 2 4 The value of f is obtained from the following table, which depends on the calendar. For the Gregorian calendar, [ 6 ] c mod 4 0 1 2 3 f 0 5 3 1 For the Julian calendar, [ 6 ] c mod 7 0 1 2 3 4 5 6 f 5 4 3 2 1 0 6 Lewis Carroll's method [ edit ] This section is missing information about transcription in mathematical expressions for easier comparison.

Please expand the section to include this information. Further details may exist on the talk page .

( March 2021 ) Charles Lutwidge Dodgson ( Lewis Carroll ) devised a method resembling a puzzle, yet partly tabular in using the same index numbers for the months as in the "Complete table: Julian and Gregorian calendars" above. He lists the same three adjustments for the first three months of non-leap years, one 7 higher for the last, and gives cryptic instructions for finding the rest; his adjustments for centuries are to be determined using formulas similar to those for the centuries table. Although explicit in asserting that his method also works for Old Style dates, his example reproduced below to determine that "1676, February 23" is a Wednesday only works on a Julian calendar which starts the year on January 1, instead of March 25 as on the "Old Style" Julian calendar .

Algorithm: [ 11 ] Take the given date in 4 portions, viz. the number of centuries, the number of years over, the month, the day of the month.

Compute the following 4 items, adding each, when found, to the total of the previous items. When an item or total exceeds 7, divide by 7, and keep the remainder only.

Century-item: For ' Old Style ' (which ended 2 September 1752) subtract from 18. For ' New Style ' (which began 14 September 1752) divide by 4, take overplus [surplus] from 3, multiply remainder by 2.

Year-item: Add together the number of dozens, the overplus, and the number of 4s in the overplus.

Month-item: If it begins or ends with a vowel, subtract the number, denoting its place in the year, from 10. This, plus its number of days, gives the item for the following month. The item for January is "0"; for February or March, "3"; for December, "12".

Day-item: The total, thus reached, must be corrected, by deducting "1" (first adding 7, if the total be "0"), if the date be January or February in a leap year, remembering that every year, divisible by 4, is a Leap Year, excepting only the century-years, in 'New Style', when the number of centuries is not so divisible (e.g. 1800).

The final result gives the day of the week, "0" meaning Sunday, "1" Monday, and so on.

Examples: [ 11 ] 1783, September 18 17, divided by 4, leaves "1" over; 1 from 3 gives "2"; twice 2 is "4".
83 is 6 dozen and 11, giving 17; plus 2 gives 19, i.e. (dividing by 7) "5". Total 9, i.e. "2"
The item for August is "8 from 10", i.e. "2"; so, for September, it is "2 plus 31", i.e. "5" Total 7, i.e. "0", which goes out.
18 gives "4". Answer, "Thursday".

1676, February 23 16 from 18 gives "2"
76 is 6 dozen and 4, giving 10; plus 1 gives 11, i.e. "4".
Total "6"
The item for February is "3". Total 9, i.e. "2"
23 gives "2". Total "4"
Correction for Leap Year gives "3". Answer, "Wednesday".

Dates before 1752 would in England be given Old Style with 25 March as the first day of the new year . Carroll's method however assumes 1 January as the first day of the year, thus he fails to arrive at the correct answer, namely "Friday".

Had he noticed that 1676, February 23 (with 25 March as New Year's Day) is actually 1677, February 23 (with 1 January as New Year's Day), he would have accounted for differing year numbers—just like George Washington 's birthday differs—between the two calendars. Then his method yields: 1677 (corrected), February 23 16 from 18 gives "2" 77 is 6 dozen and 5, giving 11; plus 1 gives 12, i.e. "5". Total "7" The item for February is "3". Total 10, i.e. "3" 23 gives "2". Total "5". Answer, "Friday".

It is noteworthy that those who have republished Carroll's method have failed to point out his error, most notably Martin Gardner .

[ 12 ] In 1752, the British Empire abandoned its use of the Old Style Julian calendar upon adopting the Gregorian calendar , which has become today's standard in most countries of the world. For more background, see Old Style and New Style dates .

Methods in computer code [ edit ] Keith [ edit ] In the C language expressions below, y , m and d are, respectively, integer variables representing the year (e.g., 1988), month (1–12) and day of the month (1-31).

( d += m < 3 ?

y -- : y -2 , 23 * m / 9 + d + 4 + y / 4 - y / 100 + y / 400 ) % 7 In 1990, Michael Keith and Tom Craver published the foregoing expression that seeks to minimize the number of keystrokes needed to enter a self-contained function for converting a Gregorian date into a numerical day of the week.

[ 13 ] It returns 0 = Sunday, 1 = Monday, etc. This expression uses a less cumbersome month component than does Zeller's algorithm.

Shortly afterwards, Hans Lachman streamlined their algorithm for ease of use on low-end devices. As designed originally for four-function calculators, his method needs fewer keypad entries by limiting its range either to A.D. 1905–2099, or to historical Julian dates. It was later modified to convert any Gregorian date, even on an abacus . On Motorola 68000 -based devices, there is similarly less need of either processor registers or opcodes , depending on the intended design objective.

[ 14 ] Sakamoto's methods [ edit ] The tabular forerunner to Tøndering's algorithm is embodied in the following K&R C function.

[ 15 ] With minor changes, it was adapted for other high level programming languages such as APL2 .

[ 16 ] Posted by Tomohiko Sakamoto on the comp.lang.c Usenet newsgroup in 1992, it is accurate for any Gregorian date.

[ 17 ] [ 18 ] dayofweek ( y , m , d ) /* 1 <= m <= 12, y > 1752 (in the U.K.) */ { static int t [] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 }; if ( m < 3 ) { y -= 1 ; } return ( y + y / 4 - y / 100 + y / 400 + t [ m -1 ] + d ) % 7 ; } It returns 0 = Sunday, 1 = Monday, etc.

Sakamoto also simultaneously posted a more obfuscated version: dow ( m , d , y ) { y -= m < 3 ; return ( y + y / 4 - y / 100 + y / 400 + "-bed=pen+mad." [ m ] + d ) % 7 ; } This version encodes the month offsets in the string and as a result requires a computer that uses standard ASCII to run the algorithm correctly, reducing its portability . In addition, both algorithms omit int type declarations , which is allowed in the original K&R C but not allowed in ANSI C .

(Tøndering's algorithm is, again, similar in structure to Zeller's congruence and Keith's short code, except that the month-related component is 31*m/12 . Sakamoto's is somewhere between the Disparate Gaussian and the Schwerdtfeger's algorithm, apparently unaware of the expression form.) Gauss's method in MATLAB [ edit ] % example date input y1 = 2022 ; m1 = 1 ; d1 = 1 ; month_offset = [ 0 3 3 6 1 4 6 2 5 0 3 5 ]; % common year % offset if y1 leap year if mod ( y1 , 4 ) == 0 && mod ( y1 , 100 ) == 0 && mod ( y1 , 400 ) == 0 month_offset =[ 0 3 4 0 2 5 0 3 6 1 4 6 ]; % leap year end % Gregor weekday_gregor = rem ( d1 + month_offset ( m1 ) + 5 * rem ( y1 - 1 , 4 ) + 4 * rem ( y1 - 1 , 100 ) + 6 * rem ( y1 - 1 , 400 ), 7 ) % Julian weekday_julian = rem ( 6 + 5 * rem ( y1 - 1 , 4 ) + 3 * ( y1 - 1 ), 7 ) 0: Sunday 1: Monday .. 6: Saturday Gauss's method for Gregorian calendar in Python [ edit ] from numpy import remainder as rem def is_leap_year ( year : int ) -> bool : """Determine whether a year is a leap year.""" return year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) def day_of_week ( y : int , m : int , d : int ) -> str : """Return day of week of given date as string, using Gauss's algorithm to find it.""" if is_leap_year ( y ): month_offset = ( 0 , 3 , 4 , 0 , 2 , 5 , 0 , 3 , 6 , 1 , 4 , 6 )[ m - 1 ] else : month_offset = ( 0 , 3 , 3 , 6 , 1 , 4 , 6 , 2 , 5 , 0 , 3 , 5 )[ m - 1 ] y -= 1 wd = int ( rem ( d + month_offset + 5 * rem ( y , 4 ) + 4 * rem ( y , 100 ) \ + 6 * rem ( y , 400 ) , 7 )) return ( "Sun" , "Mon" , "Tue" , "Wed" , "Thu" , "Fri" , "Sat" )[ wd ] See also [ edit ] Doomsday rule Julian day Mental Calculation World Cup (Has a calendar calculation contest) Perpetual calendar Buddhist calendar References [ edit ] Notes [ edit ] ^ To illustrate this in detail it is useful to visualise a calendar depicting a month beginning on a Sunday, i.e.

the 1st of the month is a Sunday). Counting forward seven days brings us to the 8th, which is also a Sunday. Counting forward another ten days brings us to the 18th, which is a Wednesday. If instead we were to start on Wednesday the 4th (three days after Sunday the 1st), count forward seven days to Wednesday the 11th (three days after Sunday the 8th), then count forward another seven days, we would end up on Wednesday the 18th – again – three days after Sunday the 15th, which itself falls exactly two weeks (two Sundays) after Sunday the 1st.

^ The numbers in the first column are proleptic – the Gregorian calendar was not devised till 1582. See the note beneath the table.

^ The Julian century beginning 1 BC would also appear on this line of the table (to the left of 700) but there is no space to include it.

Citations [ edit ] ^ a b Brothers, Hardin; Rawson, Tom ; Conn, Rex C.

; Paul, Matthias R.; Dye, Charles E.; Georgiev, Luchezar I. (2002-02-27).

4DOS 8.00 online help .

^ "HP Prime - Portal: Firmware update" (in German). Moravia Education. 2015-05-15.

Archived from the original on 2016-11-05 . Retrieved 2015-08-28 .

^ Paul, Matthias R. (1997-07-30).

NWDOS-TIPs — Tips & Tricks rund um Novell DOS 7, mit Blick auf undokumentierte Details, Bugs und Workarounds . Release 157 (in German) (3rd ed.).

Archived from the original on 2016-11-04 . Retrieved 2014-08-06 .

(NB.

NWDOSTIP.TXT is a comprehensive work on Novell DOS 7 and OpenDOS 7.01 , including the description of many undocumented features and internals. It is part of the author's yet larger MPDOSTIP.ZIP collection maintained up to 2001 and distributed on many sites at the time. The provided link points to a HTML-converted older version of the NWDOSTIP.TXT file.) ^ Richards, E. G. (1999).

Mapping Time: The Calendar and Its History .

Oxford University Press .

ISBN 978-0-19-850413-9 .

^ a b Gauss, Carl F. (1981). "Den Wochentag des 1. Januar eines Jahres zu finden. Gueldene Zahl. Epakte. Ostergrenze.".

Werke. herausgegeben von der Koeniglichen Gesellschaft der Wissenschaften zu Goettingen (2nd ed.). Hildesheim: Georg Olms Verlag. pp.

206– 207.

ISBN 978-3-48704643-3 .

^ a b c d e f Schwerdtfeger, Berndt E. (2010-05-07).

"Gauss' calendar formula for the day of the week" (PDF) (1.4.26 ed.) . Retrieved 2012-12-23 .

^ Kraitchik, Maurice (2006). "Chapter 5: The calendar".

Mathematical recreations (2nd revised [Dover] ed.). Mineola: Dover Publications . pp.

109– 116.

ISBN 978-0-48645358-3 .

^ Rosen, Kenneth H. (2011).

Elementary Number Theory and Its Applications . Addison Wesley. pp.

134– 137.

ISBN 978-0321500311 .

^ Stockton, J. R. (2010-03-19).

"The Calendrical Works of Rektor Chr. Zeller: The Day-of-Week and Easter Formulae" .

Merlyn . Archived from the original on 2013-07-29 . Retrieved 2012-12-19 .

^ Wang, Xiang-Sheng (March 2015).

"Calculating the day of the week: null-days algorithm" (PDF) .

Recreational Mathematics Magazine . No. 3. p. 5.

^ a b Dodgson, C.L. ( Lewis Carroll ). (1887). "To find the day of the week for any given date".

Nature , 31 March 1887. Reprinted in Mapping Time , pp. 299-301.

^ Martin Gardner. (1996).

The Universe in a Handkerchief: Lewis Carroll's Mathematical Recreations, Games, Puzzles, and Word Plays , pages 24-26. Springer-Verlag.

^ Michael Keith; Tom Craver. (1990).

The ultimate perpetual calendar?

Journal of Recreational Mathematics, 22:4, pp.280-282.

^ The 4-function Calculator; The Assembly of Motorola 68000 Orphans; The Abacus.

gopher://sdf.org/1/users/retroburrowers/TemporalRetrology ^ "Day-of-week algorithm NEEDED!" news:1993Apr20.075917.16920@sm.sony.co.jp ^ APL2 IDIOMS workspace: Date and Time Algorithms, line 15.

https://www.ibm.com/support/pages/system/files/support/swg/swgdocs.nsf/0/819cd2373bb755d98525716c004c108e/$FILE/APL2IDIOMS.pdf (2002) ^ "Date -> Day of week conversion" .

Google newsgroups:comp.lang.c . December 1992 . Retrieved 2020-06-21 .

^ "DOW algorithm" .

Google newsgroups:comp.lang.c . 1994 . Retrieved 2020-06-21 .

Further reading [ edit ] Hale-Evans, Ron (2006).

"Hack #43: Calculate any weekday" .

Mind performance hacks (1st ed.). Beijing: O'Reilly. pp.

164–169 .

ISBN 9780596101534 .

Thioux, Marc; Stark, David E.; Klaiman, Cheryl; Schultz, Robert T. (2006). "The day of the week when you were born in 700 ms: Calendar computation in an autistic savant".

Journal of Experimental Psychology: Human Perception and Performance .

32 (5): 1155– 1168.

doi : 10.1037/0096-1523.32.5.1155 .

PMID 17002528 .

Treffert, Darold A. (2011-10-12). "Why calendar calculating?".

Islands of genius : the bountiful mind of the autistic, acquired, and sudden savant (1. publ., [repr.]. ed.). London: Jessica Kingsley. pp.

63– 66.

ISBN 9781849058735 .

External links [ edit ] Tøndering's algorithm for both Gregorian and Julian calendars "Key Day" method used so as to reduce computation & memorization Compact tabular method for memorisation, also for the Julian calendar When countries changed from the Julian calendar World records for mentally calculating the day of the week in the Gregorian Calendar National records for finding Calendar Dates World Ranking of Memoriad Mental Calendar Dates (all competitions combined) Identify the year by given month, day, day of week.

Archived 2018-01-04 at the Wayback Machine v t e Time measurement and standards Chronometry Orders of magnitude Metrology International standards Coordinated Universal Time offset UT ΔT DUT1 International Earth Rotation and Reference Systems Service ISO 31-1 ISO 8601 International Atomic Time 12-hour clock 24-hour clock Barycentric Coordinate Time Barycentric Dynamical Time Civil time Daylight saving time Geocentric Coordinate Time International Date Line IERS Reference Meridian Leap second Solar time Terrestrial Time Time zone 180th meridian Obsolete standards Ephemeris time Greenwich Mean Time Prime meridian Time in physics Absolute space and time Spacetime Chronon Continuous signal Coordinate time Cosmological decade Discrete time and continuous time Proper time Theory of relativity Time dilation Gravitational time dilation Time domain Time-translation symmetry T-symmetry Horology Clock Astrarium Atomic clock Complication History of timekeeping devices Hourglass Marine chronometer Marine sandglass Radio clock Watch stopwatch Water clock Sundial Dialing scales Equation of time History of sundials Sundial markup schema Calendar Gregorian Hebrew Hindu Holocene Islamic (lunar Hijri) Julian Solar Hijri Astronomical Dominical letter Epact Equinox Intercalation Julian day Leap year Lunar Lunisolar Solar Solstice Tropical year Weekday determination Weekday names Archaeology and geology Chronological dating Geologic time scale International Commission on Stratigraphy Astronomical chronology Galactic year Nuclear timescale Precession Sidereal time Other units of time Instant Flick Shake Jiffy Second Minute Moment Hour Day Week Fortnight Month Year Olympiad Lustrum Decade Century Saeculum Millennium Related topics Chronology Duration music Mental chronometry Decimal time Metric time System time Time metrology Time value of money Timekeeper NewPP limit report
Parsed by mw‐web.codfw.main‐6cc77c66b8‐9k626
Cached time: 20250812015344
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.610 seconds
Real time usage: 0.984 seconds
Preprocessor visited node count: 4656/1000000
Revision size: 48650/2097152 bytes
Post‐expand include size: 69153/2097152 bytes
Template argument size: 6582/2097152 bytes
Highest expansion depth: 12/100
Expensive parser function count: 17/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 92856/5000000 bytes
Lua time usage: 0.296/10.000 seconds
Lua memory usage: 6388292/52428800 bytes
Number of Wikibase entities loaded: 0/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  725.664      1 -total
 23.05%  167.278      2 Template:Reflist
 16.76%  121.649      8 Template:Cite_book
 10.60%   76.895      1 Template:Short_description
  9.76%   70.848      1 Template:Time_measurement_and_standards
  6.34%   45.987      2 Template:Pagetype
  6.02%   43.710      3 Template:Ambox
  5.44%   39.508      1 Template:Cleanup_list
  5.20%   37.721     35 Template:Math
  3.83%   27.784     43 Template:Main_other Saved in parser cache with key enwiki:pcache:443439:|#|:idhash:canonical and timestamp 20250812015344 and revision id 1302156444. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Determination_of_the_day_of_the_week&oldid=1302156444 " Categories : Days of the week Gregorian calendar Julian calendar Calendar algorithms Hidden categories: CS1 German-language sources (de) Articles with short description Short description matches Wikidata Use dmy dates from July 2019 Articles needing cleanup from March 2021 All pages needing cleanup Wikipedia list cleanup from March 2021 Articles to be expanded from July 2025 All articles to be expanded Articles to be expanded from March 2021 Webarchive template wayback links Articles with example C code This page was last edited on 23 July 2025, at 18:24 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Determination of the day of the week 15 languages Add topic

