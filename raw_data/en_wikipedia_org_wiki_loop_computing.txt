Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Categories 2 Primitives Toggle Primitives subsection 2.1 Labels 2.2 Goto 2.3 Subroutines 2.4 Sequence 3 Minimal structured control flow 4 Control structures in practice 5 Choice Toggle Choice subsection 5.1 If-then-(else) statements 5.2 Case and switch statements 6 Loops Toggle Loops subsection 6.1 Count-controlled loops 6.2 Condition-controlled loops 6.3 Collection-controlled loops 6.4 General iteration 6.5 Infinite loops 6.6 Continuation with next iteration 6.7 Redo current iteration 6.8 Restart loop 6.9 Loop-and-a-half 6.10 Early exit from loops 6.10.1 Multi-level breaks 6.11 Loop with test in the middle 6.12 Loop variants and invariants 6.13 Loop sublanguage 6.14 Loop system cross-reference table 7 Structured non-local control flow Toggle Structured non-local control flow subsection 7.1 Conditions 7.2 Exceptions 7.3 Continuations 7.4 Async 7.5 Generators 7.6 Coroutines 7.7 Non-local control flow cross reference 8 Proposed control structures Toggle Proposed control structures subsection 8.1 COMEFROM 8.2 Event-based early exit from nested loops 9 Security 10 See also 11 Notes 12 References 13 Further reading 14 External links Toggle the table of contents Control flow 33 languages العربية Azərbaycanca Català Čeština Deutsch Español Esperanto Euskara فارسی Français 한국어 Hrvatski Íslenska Italiano עברית Қазақша Bahasa Melayu Nederlands 日本語 Norsk bokmål Polski Português Русский Српски / srpski Srpskohrvatski / српскохрватски Svenska தமிழ் ไทย Українська اردو Tiếng Việt 粵語 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia (Redirected from Loop (computing) ) Execution order of computer commands Not to be confused with Flow control (data) .

Loop constructs Do while loop While loop For loop Foreach loop Infinite loop Control flow v t e In computer science , control flow (or flow of control ) is the order in which individual statements , instructions or function calls of an imperative program are executed or evaluated. The emphasis on explicit control flow distinguishes an imperative programming language from a declarative programming language.

Within an imperative programming language , a control flow statement is a statement that results in a choice being made as to which of two or more paths to follow. For non-strict functional languages, functions and language constructs exist to achieve the same result, but they are usually not termed control flow statements.

A set of statements is in turn generally structured as a block , which in addition to grouping, also defines a lexical scope .

Interrupts and signals are low-level mechanisms that can alter the flow of control in a way similar to a subroutine , but usually occur as a response to some external stimulus or event (that can occur asynchronously ), rather than execution of an in-line control flow statement.

At the level of machine language or assembly language , control flow instructions usually work by altering the program counter . For some central processing units (CPUs), the only control flow instructions available are conditional or unconditional branch instructions, also termed jumps. However there is also predication which conditionally enables or disables instructions without branching: as an alternative technique it can have both advantages and disadvantages over branching.

Categories [ edit ] A state diagram of a peptide ion mass mapping search process The kinds of control flow statements supported by different languages vary, but can be categorized by their effect: Continuation at a different statement (unconditional branch or jump) Executing a set of statements only if some condition is met (choice - i.e., conditional branch ) Executing a set of statements zero or more times, until some condition is met (i.e., loop - the same as conditional branch ) Executing a set of distant statements, after which the flow of control usually returns ( subroutines , coroutines , and continuations ) Stopping the program, preventing any further execution (unconditional halt) Primitives [ edit ] Labels [ edit ] Main article: Label (computer science) A label is an explicit name or number assigned to a fixed position within the source code , and which may be referenced by control flow statements appearing elsewhere in the source code. A label marks a position within source code and has no other effect.

Line numbers are an alternative to a named label used in some languages (such as BASIC ). They are whole numbers placed at the start of each line of text in the source code. Languages which use these often impose the constraint that the line numbers must increase in value in each following line, but may not require that they be consecutive. For example, in BASIC: 10 LET X = 3 20 PRINT X In other languages such as C and Ada , a label is an identifier , usually appearing at the start of a line and immediately followed by a colon. For example, in C: Success : printf ( "The operation was successful.

\n " ); The language ALGOL 60 allowed both whole numbers and identifiers as labels (both linked by colons to the following statement), but few if any other ALGOL variants allowed whole numbers. Early Fortran compilers only allowed whole numbers as labels. Beginning with Fortran-90, alphanumeric labels have also been allowed.

Goto [ edit ] Main article: GOTO The goto statement (a combination of the English words go and to , and pronounced accordingly) is the most basic form of unconditional transfer of control.

Although the keyword may either be in upper or lower case depending on the language, it is usually written as: goto label The effect of a goto statement is to cause the next statement to be executed to be the statement appearing at (or immediately after) the indicated label.

Goto statements have been considered harmful by many computer scientists, notably Dijkstra .

Subroutines [ edit ] Main article: Subroutine The terminology for subroutines varies; they may alternatively be known as routines, procedures, functions (especially if they return results) or methods (especially if they belong to classes or type classes ).

In the 1950s, computer memories were very small by current standards so subroutines were used mainly to reduce program size. A piece of code was written once and then used many times from various other places in a program.

Today, subroutines are more often used to help make a program more structured, e.g., by isolating some algorithm or hiding some data access method. If many programmers are working on one program, subroutines are one kind of modularity that can help divide the work.

Sequence [ edit ] Main article: Structured programming In structured programming, the ordered sequencing of successive commands is considered one of the basic control structures, which is used as a building block for programs alongside iteration, recursion and choice.

Minimal structured control flow [ edit ] See also: Structured program theorem In May 1966, Böhm and Jacopini published an article [ 1 ] in Communications of the ACM which showed that any program with goto s could be transformed into a goto-free form involving only choice (IF THEN ELSE) and loops (WHILE condition DO xxx), possibly with duplicated code and/or the addition of Boolean variables (true/false flags). Later authors showed that choice can be replaced by loops (and yet more Boolean variables).

That such minimalism is possible does not mean that it is necessarily desirable; computers theoretically need only one machine instruction (subtract one number from another and branch if the result is negative), but practical computers have dozens or even hundreds of machine instructions.

Other research showed that control structures with one entry and one exit were much easier to understand than any other form, [ citation needed ] mainly because they could be used anywhere as a statement without disrupting the control flow. In other words, they were composable . (Later developments, such as non-strict programming languages – and more recently, composable software transactions – have continued this strategy, making components of programs even more freely composable.) Some academics took a purist approach to the Böhm–Jacopini result and argued that even instructions like break and return from the middle of loops are bad practice as they are not needed in the Böhm–Jacopini proof, and thus they advocated that all loops should have a single exit point. This purist approach is embodied in the language Pascal (designed in 1968–1969), which up to the mid-1990s was the preferred tool for teaching introductory programming in academia.

[ 2 ] The direct application of the Böhm–Jacopini theorem may result in additional local variables being introduced in the structured chart, and may also result in some code duplication .

[ 3 ] Pascal is affected by both of these problems and according to empirical studies cited by Eric S. Roberts , student programmers had difficulty formulating correct solutions in Pascal for several simple problems, including writing a function for searching an element in an array. A 1980 study by Henry Shapiro cited by Roberts found that using only the Pascal-provided control structures, the correct solution was given by only 20% of the subjects, while no subject wrote incorrect code for this problem if allowed to write a return from the middle of a loop.

[ 2 ] Control structures in practice [ edit ] Most programming languages with control structures have an initial keyword which indicates the type of control structure involved.

[ clarification needed ] Languages then divide as to whether or not control structures have a final keyword.

No final keyword: ALGOL 60 , C , C++ , Go , Haskell , Java , Pascal , Perl , PHP , PL/I , Python , PowerShell . Such languages need some way of grouping statements together: ALGOL 60 and Pascal: begin ...

end C, C++, Go, Java, Perl, PHP, and PowerShell: curly brackets { ...

} PL/I: DO ...

END Python: uses indent level (see Off-side rule ) Haskell: either indent level or curly brackets can be used, and they can be freely mixed Lua: uses do ...

end Final keyword: Ada , APL , ALGOL 68 , Modula-2 , Fortran 77 , Mythryl , Visual Basic . The forms of the final keyword vary: Ada: final keyword is end + space + initial keyword e.g., if ...

end if , loop ...

end loop APL: final keyword is :End optionally + initial keyword, e.g., :If ...

:End or :If ...

:EndIf , Select ...

:End or :Select ...

:EndSelect , however, if adding an end condition, the end keyword becomes :Until ALGOL 68, Mythryl: initial keyword spelled backwards e.g., if ...

fi , case ...

esac Fortran 77: final keyword is END + initial keyword e.g., IF ...

ENDIF , DO ...

ENDDO Modula-2: same final keyword END for everything Visual Basic: every control structure has its own keyword.

If ...

End If ; For ...

Next ; Do ...

Loop ; While ...

Wend Choice [ edit ] If-then-(else) statements [ edit ] Main article: Conditional (computer programming) Conditional expressions and conditional constructs are features of a programming language that perform different computations or actions depending on whether a programmer-specified Boolean condition evaluates to true or false.

IF..GOTO . A form found in unstructured languages, mimicking a typical machine code instruction, would jump to (GOTO) a label or line number when the condition was met.

IF..THEN..(ENDIF) . Rather than being restricted to a jump, any simple statement, or nested block, could follow the THEN key keyword. This a structured form.

IF..THEN..ELSE..(ENDIF) . As above, but with a second action to be performed if the condition is false. This is one of the most common forms, with many variations. Some require a terminal ENDIF , others do not.

C and related languages do not require a terminal keyword, or a 'then', but do require parentheses around the condition.

Conditional statements can be and often are nested inside other conditional statements. Some languages allow ELSE and IF to be combined into ELSEIF , avoiding the need to have a series of ENDIF or other final statements at the end of a compound statement.

Pascal : Ada : if a > 0 then writeln ( " yes " ) else writeln ( " no " ) ; if a > 0 then Put_Line ( "yes" ); else Put_Line ( "no" ); end if ; C : Shell script : if ( a > 0 ) { puts ( "yes" ); } else { puts ( "no" ); } if [ $a -gt 0 ] ; then echo "yes" else echo "no" fi Python : Lisp : if a > 0 : print ( "yes" ) else : print ( "no" ) ( princ ( if ( plusp a ) "yes" "no" )) Less common variations include: Some languages, such as early Fortran , [ a ] have a three-way or arithmetic if , testing whether a numeric value is negative, zero, or positive.

Some languages have a functional form of an if statement, for instance Lisp's cond .

Some languages have an operator form of an if statement, such as C's ternary operator .

Perl supplements a C-style if with when and unless .

Smalltalk uses ifTrue and ifFalse messages to implement conditionals, rather than any fundamental language construct.

Case and switch statements [ edit ] Main article: Switch statement Switch statements (or case statements , or multiway branches ) compare a given value with specified constants and take action according to the first constant to match. There is usually a provision for a default action ("else", "otherwise") to be taken if no match succeeds. Switch statements can allow compiler optimizations, such as lookup tables . In dynamic languages , the cases may not be limited to constant expressions, and might extend to pattern matching , as in the shell script example on the right, where the *) implements the default case as a glob matching any string. Case logic can also be implemented in functional form, as in SQL 's decode statement.

Pascal : Ada : case someChar of 'a' : actionOnA ; 'x' : actionOnX ; 'y' , 'z' : actionOnYandZ ; else actionOnNoMatch ; end ; case someChar is when ' a ' => actionOnA ; when ' x ' => actionOnX ; when ' y ' | ' z ' => actionOnYandZ ; when others => actionOnNoMatch ; end ; C : Shell script : switch ( someChar ) { case 'a' : actionOnA ; break ; case 'x' : actionOnX ; break ; case 'y' : case 'z' : actionOnYandZ ; break ; default : actionOnNoMatch ; } case $someChar in a ) actionOnA ;; x ) actionOnX ;; [ yz ]) actionOnYandZ ;; * ) actionOnNoMatch ;; esac Lisp : Fortran : ( case some-char (( #\a ) action-on-a ) (( #\x ) action-on-x ) (( #\y #\z ) action-on-y-and-z ) ( else action-on-no-match )) select case ( someChar ) case ( 'a' ) actionOnA case ( 'x' ) actionOnX case ( 'y' , 'z' ) actionOnYandZ case default actionOnNoMatch end select Loops [ edit ] A loop is a sequence of statements which is specified once but which may be carried out several times in succession. The code "inside" the loop (the body of the loop, shown below as xxx ) is obeyed a specified number of times, or once for each of a collection of items (both cases of definite iteration ), or until some condition is met ( indefinite iteration ), or infinitely . When one of those items is itself also a loop, it is called a "nested loop".

[ 4 ] [ 5 ] [ 6 ] Some common situations are not well-handled by these basic control structures, and are generally addressed by early exit from the loop, in the form of a break from the loop, a return from the function, or an exception being raised.

[ 7 ] [ 2 ] In functional programming languages, such as Haskell and Scheme , both recursive and iterative processes are expressed with tail recursive procedures instead of looping constructs that are syntactic.

Count-controlled loops [ edit ] Main article: For loop Most programming languages have constructions for repeating a loop a certain number of times.
In most cases counting can go downwards instead of upwards and step sizes other than 1 can be used.

FOR I = 1 TO N xxx NEXT I for I := 1 to N do begin xxx end ; DO I = 1 , N xxx END DO for ( I=1; I<=N; ++I ) {
    xxx
} In these examples, if N < 1 then the body of loop may execute once (with I having value 1) or not at all, depending on the programming language.

In many programming languages, only integers can be reliably used in a count-controlled loop. Floating-point numbers are represented imprecisely due to hardware constraints, so a loop such as for X := 0.1 step 0.1 to 1.0 do might be repeated 9 or 10 times, depending on rounding errors and/or the hardware and/or the compiler version. Furthermore, if the increment of X occurs by repeated addition, accumulated rounding errors may mean that the value of X in each iteration can differ quite significantly from the expected sequence 0.1, 0.2, 0.3, ..., 1.0.

Condition-controlled loops [ edit ] Main articles: While loop and Do while loop Most programming languages have constructions for repeating a loop until some condition changes. Some variations test the condition at the start of the loop; others test it at the end. If the test is at the start, the body may be skipped completely; if it is at the end, the body is always executed at least once.

DO WHILE (test)
    xxx
LOOP repeat xxx until test; while (test) {
    xxx
} do xxx while (test); A control break is a value change detection method used within ordinary loops to trigger processing for groups of values. Values are monitored within the loop and a change diverts program flow to the handling of the group event associated with them.

DO UNTIL (End-of-File)
      IF new-zipcode <> current-zipcode
         display_tally(current-zipcode, zipcount)
         
         current-zipcode = new-zipcode
         zipcount = 0
      ENDIF
      
      zipcount++
   LOOP Collection-controlled loops [ edit ] Main article: Foreach Several programming languages (e.g., Ada , APL , D , C++11 , Smalltalk , PHP , Perl , Object Pascal , Java , C# , MATLAB , Visual Basic , Ruby , Python , JavaScript , Fortran 95 and later) have special constructs which allow implicit looping through all elements of an array, or all members of a set or collection.

someCollection do : [ : eachElement | xxx ] .

"Smalltalk" for Item in Collection do begin xxx end ; foreach (item; myCollection) { xxx } foreach someArray { xxx } foreach ( $someArray as $k => $v ) { xxx } # PHP Collection<String> coll; for (String s : coll) {} foreach ( string s in myStringCollection) { xxx } someCollection | foreach { $_ } # Powershell: 'foreach' and '%' are the alias of 'ForEach-Object' forall ( index = first:last:step... ) Scala has for-expressions , which generalise collection-controlled loops, and also support other uses, such as asynchronous programming .

Haskell has do-expressions and comprehensions, which together provide similar function to for-expressions in Scala.

General iteration [ edit ] General iteration constructs such as C's for statement and Common Lisp 's do form can be used to express any of the above sorts of loops, and others, such as looping over some number of collections in parallel. Where a more specific looping construct can be used, it is usually preferred over the general iteration construct, since it often makes the purpose of the expression clearer.

Infinite loops [ edit ] Main article: Infinite loop Infinite loops are used to assure a program segment loops forever or until an exceptional condition arises, such as an error. For instance, an event-driven program (such as a server ) should loop forever, handling events as they occur, only stopping when the process is terminated by an operator.

Infinite loops can be implemented using other control flow constructs. Most commonly, in unstructured programming this is jump back up (goto), while in structured programming this is an indefinite loop (while loop) set to never end, either by omitting the condition or explicitly setting it to true, as while (true) ...

. Some languages have special constructs for infinite loops, typically by omitting the condition from an indefinite loop. Examples include Ada ( loop ... end loop ), [ 8 ] Fortran ( DO ... END DO ), Go ( for { ... } ), and Ruby ( loop do ... end ).

Often, an infinite loop is unintentionally created by a programming error in a condition-controlled loop, wherein the loop condition uses variables that never change within the loop.

Continuation with next iteration [ edit ] Sometimes within the body of a loop there is a desire to skip the remainder of the loop body and continue with the next iteration of the loop. Some languages provide a statement such as continue (most languages), skip , [ 9 ] cycle (Fortran), or next (Perl and Ruby), which will do this. The effect is to prematurely terminate the innermost loop body and then resume as normal with the next iteration. If the iteration is the last one in the loop, the effect is to terminate the entire loop early.

Redo current iteration [ edit ] Some languages, like Perl [ 10 ] and Ruby, [ 11 ] have a redo statement that restarts the current iteration from the start.

Restart loop [ edit ] Ruby has a retry statement that restarts the entire loop from the initial iteration.

[ 12 ] Loop-and-a-half [ edit ] Common loop structures sometimes result in duplicated code, either repeated statements or repeated conditions. This arises for various reasons and has various proposed solutions to eliminate or minimize code duplication.

[ 13 ] Other than the traditional unstructured solution of a goto statement, [ 14 ] general structured solutions include having a conditional ( if statement) inside the loop (possibly duplicating the condition but not the statements) or wrapping repeated logic in a function (so there is a duplicated function call, but the statements are not duplicated).

[ 13 ] A common case is where the start of the loop is always executed, but the end may be skipped on the last iteration.

[ 14 ] This was dubbed by Dijkstra a loop which is performed " n and a half times", [ 15 ] and is now called the loop-and-a-half problem .

[ 2 ] Common cases include reading data in the first part, checking for end of data, and then processing the data in the second part; or processing, checking for end, and then preparing for the next iteration.

[ 14 ] [ 2 ] In these cases, the first part of the loop is executed ⁠ n {\displaystyle n} ⁠ times, but the second part is only executed ⁠ n − − 1 {\displaystyle n-1} ⁠ times.

This problem has been recognized at least since 1967 by Knuth, with Wirth suggesting solving it via early loop exit.

[ 16 ] Since the 1990s this has been the most commonly taught solution, using a break statement, as in: [ 2 ] loop statements if condition break statements repeat A subtlety of this solution is that the condition is the opposite of a usual while condition: rewriting while condition ...

repeat with an exit in the middle requires reversing the condition: loop ...

if not condition exit ...

repeat . The loop with test in the middle control structure explicitly supports the loop-an-a-half use case, without reversing the condition.

[ 16 ] Early exit from loops [ edit ] It is sometimes desirable to stop executing a loop before the end of the body; for example, when using a count-controlled loop to search through a table, one can stop as soon as the required item is found. Early exit is the most common way to solve the loop-and-a-half problem.

[ 2 ] Some programming languages provide a statement such as break (most languages), Exit (Visual Basic), or last (Perl), which effect is to terminate the current loop immediately, and transfer control to the statement immediately after that loop.

Other mechanisms for early exit include a return out of a subroutine executing the looped statements, breaking out of both the loop and the subroutine; and raising an exception. There are other proposed control structures , but they are not commonly implemented. This section treats early exit from only the loop ("break").

Most commonly, this is used by combining a conditional ( if statement) with an unconditional break, as in Ada: loop Get ( X ); if X = 0 then exit ; end if ; -- Do something with X.

end loop ; In this form, the condition is interpreted as until . Some languages, such as Ada, have syntax for a conditional break, here an exit when clause (not to be confused with the exitwhen statement in § Proposed control structures ); if available, this is more idiomatic: loop Get ( X ); exit when X = 0 ; -- Do something with X.

end loop ; This functions similarly to a loop with test in the middle , but in that case the test is part of the structure of the loop, dividing the body of the loop in half (visually indented at the same level as the start/end of loop), while early exit is unstructured: simply a statement that can appear anywhere in the body of the loop, and in fact multiple break statements are possible.

Python supports conditional execution of code depending on whether a loop was exited early (with a break statement) or not by using an else-clause with the loop. For example, for n in set_of_numbers : if isprime ( n ): print ( "Set contains a prime number" ) break else : print ( "Set did not contain any prime numbers" ) The else clause in the above example is linked to the for statement, and not the inner if statement. Both Python's for and while loops support such an else clause, which is executed only if early exit of the loop has not occurred.

Multi-level breaks [ edit ] Some languages support breaking out of nested loops; in theory circles, these are called multi-level breaks . One common use example is searching a multi-dimensional table. This can be done either via multilevel breaks (break out of N levels), as in bash [ 17 ] and PHP, [ 18 ] or via labeled breaks (break out and continue at given label), as in Ada. Go, Java and Perl.

[ 19 ] Alternatives to multilevel breaks include single breaks, together with a state variable which is tested to break out another level; exceptions, which are caught at the level being broken out to; placing the nested loops in a function and using return to effect termination of the entire nested loop; or using a label and a goto statement. C does not include a multilevel break, and the usual alternative is to use a goto to implement a labeled break.

[ 20 ] Python does not have a multilevel break or continue – this was proposed in PEP 3136 , and rejected on the basis that the added complexity was not worth the rare legitimate use.

[ 21 ] The notion of multi-level breaks is of some interest in theoretical computer science , because it gives rise to what is today called the Kosaraju hierarchy .

[ 22 ] In 1973 S. Rao Kosaraju refined the structured program theorem by proving that it is possible to avoid adding additional variables in structured programming, as long as arbitrary-depth, multi-level breaks from loops are allowed.

[ 23 ] Furthermore, Kosaraju proved that a strict hierarchy of programs exists: for every integer n , there exists a program containing a multi-level break of depth n that cannot be rewritten as a program with multi-level breaks of depth less than n without introducing added variables.

[ 22 ] In his 2004 textbook, David Watt uses Tennent's notion of sequencer to explain the similarity between multi-level breaks and return statements. Watt notes that a class of sequencers known as escape sequencers , defined as "sequencer that terminates execution of a textually enclosing command or procedure", encompasses both breaks from loops (including multi-level breaks) and return statements. As commonly implemented, however, return sequencers may also carry a (return) value, whereas the break sequencer as implemented in contemporary languages usually cannot.

[ 24 ] Loop with test in the middle [ edit ] The following structure was proposed by Dahl in 1972: [ 25 ] loop loop xxx1                           read(char); while test; while not atEndOfFile;
       xxx2                           write(char); repeat ; repeat ; The construction here can be thought of as a do loop with the while check in the middle, which allows clear loop-and-a-half logic. Further, by omitting individual components, this single construction can replace several constructions in most programming languages. If xxx1 is omitted, we get a loop with the test at the top (a traditional while loop). If xxx2 is omitted, we get a loop with the test at the bottom, equivalent to a do while loop in many languages. If while is omitted, we get an infinite loop. This construction also allows keeping the same polarity of the condition even when in the middle, unlike early exit, which requires reversing the polarity (adding a not ), [ 16 ] functioning as until instead of while .

This structure is not widely supported, with most languages instead using if ...

break for conditional early exit.

This is supported by some languages, such as Forth , where the syntax is BEGIN ... WHILE ... REPEAT, [ 26 ] and the shell script languages Bourne shell ( sh ) and bash , where the syntax is while ...

do ...

done or until ...

do ...

done , as: [ 27 ] [ 28 ] while statement-1 statement-2 ...

condition do statement-a statement-b ...

done The shell syntax works because the while (or until ) loop accepts a list of commands as a condition, [ 29 ] formally: while test-commands ; do consequent-commands ; done The value (exit status) of the list of test-commands is the value of the last command, and these can be separated by newlines, resulting in the idiomatic form above.

Similar constructions are possible in C and C++ with the comma operator , and other languages with similar constructs , which allow shoehorning a list of statements into the while condition: while ( statement_1 , statement_2 , condition ) { statement_a ; statement_b ; } While legal, this is marginal, and it is primarily used, if at all, only for short modify-then-test cases, as in: [ 30 ] while ( read_string ( s ), strlen ( s ) > 0 ) { // ...

} Loop variants and invariants [ edit ] Loop variants and loop invariants are used to express correctness of loops.

[ 31 ] In practical terms, a loop variant is an integer expression which has an initial non-negative value. The variant's value must decrease during each loop iteration but must never become negative during the correct execution of the loop. Loop variants are used to guarantee that loops will terminate.

A loop invariant is an assertion which must be true before the first loop iteration and remain true after each iteration. This implies that when a loop terminates correctly, both the exit condition and the loop invariant are satisfied. Loop invariants are used to monitor specific properties of a loop during successive iterations.

Some programming languages, such as Eiffel contain native support for loop variants and invariants. In other cases, support is an add-on, such as the Java Modeling Language 's specification for loop statements in Java .

Loop sublanguage [ edit ] Some Lisp dialects provide an extensive sublanguage for describing Loops. An early example can be found in Conversional Lisp of Interlisp .

Common Lisp [ 32 ] provides a Loop macro which implements such a sublanguage.

Loop system cross-reference table [ edit ] Programming language conditional loop early exit loop continuation redo retry correctness facilities begin middle end count collection general infinite [1] variant invariant Ada Yes Yes Yes Yes arrays No Yes deep nested No APL Yes No Yes Yes Yes Yes Yes deep nested [3] Yes No No C Yes No Yes No [2] No Yes No deep nested [3] deep nested [3] No C++ Yes No Yes No [2] Yes [9] Yes No deep nested [3] deep nested [3] No C# Yes No Yes No [2] Yes Yes No deep nested [3] deep nested [3] COBOL Yes No Yes Yes No Yes No deep nested [15] deep nested [14] No Common Lisp Yes Yes Yes Yes builtin only [16] Yes Yes deep nested No D Yes No Yes Yes Yes Yes Yes [14] deep nested deep nested No Eiffel Yes No No Yes [10] Yes Yes No one level [10] No No No [11] integer only [13] Yes F# Yes No No Yes Yes No No No [6] No No FORTRAN 77 Yes No No Yes No No No one level Yes No No Fortran 90 Yes No No Yes No No Yes deep nested deep nested No No Fortran 95 and later Yes No No Yes arrays No Yes deep nested deep nested No No Go Yes No No Yes builtin only Yes Yes deep nested deep nested No Haskell No No No No Yes No Yes No [6] No No Java Yes No Yes No [2] Yes Yes No deep nested deep nested No non-native [12] non-native [12] JavaScript Yes No Yes No [2] Yes Yes No deep nested deep nested No Natural Yes Yes Yes Yes No Yes Yes Yes Yes Yes No OCaml Yes No No Yes arrays,lists No No No [6] No No PHP Yes No Yes No [2] [5] Yes [4] Yes No deep nested deep nested No Perl Yes No Yes No [2] [5] Yes Yes No deep nested deep nested Yes Python Yes No No No [5] Yes No No deep nested [6] deep nested [6] No Rebol No [7] Yes Yes Yes Yes No [8] Yes one level [6] No No Ruby Yes No Yes Yes Yes No Yes deep nested [6] deep nested [6] Yes Yes Standard ML Yes No No No arrays,lists No No No [6] No No Visual Basic .NET Yes No Yes Yes Yes No Yes one level per type of loop one level per type of loop PowerShell Yes No Yes No [2] Yes Yes No Yes Yes a while (true) does not count as an infinite loop for this purpose, because it is not a dedicated language structure.

a b c d e f g h C's for ( init ; test ; increment ) loop is a general loop construct, not specifically a counting one, although it is often used for that.

a b c Deep breaks may be accomplished in APL, C, C++ and C# through the use of labels and gotos.

a Iteration over objects was added in PHP 5.

a b c A counting loop can be simulated by iterating over an incrementing list or generator, for instance, Python's range() .

a b c d e Deep breaks may be accomplished through the use of exception handling.

a There is no special construct, since the while function can be used for this.

a There is no special construct, but users can define general loop functions.

a The C++11 standard introduced the range-based for . In the STL , there is a std::for_each template function which can iterate on STL containers and call a unary function for each element.

[ 33 ] The functionality also can be constructed as macro on these containers.

[ 34 ] a Count-controlled looping is effected by iteration across an integer interval; early exit by including an additional condition for exit.

a Eiffel supports a reserved word retry , however it is used in exception handling , not loop control.

a Requires Java Modeling Language (JML) behavioral interface specification language.

a Requires loop variants to be integers; transfinite variants are not supported.

Eiffel: Why loop variants are integers a D supports infinite collections, and the ability to iterate over those collections. This does not require any special construct.

a Deep breaks can be achieved using GO TO and procedures.

a Common Lisp predates the concept of generic collection type.

Structured non-local control flow [ edit ] Many programming languages, especially those favoring more dynamic styles of programming, offer constructs for non-local control flow . These cause the flow of execution to jump out of a given context and resume at some predeclared point.

Conditions , exceptions and continuations are three common sorts of non-local control constructs; more exotic ones also exist, such as generators , coroutines and the async keyword.

Conditions [ edit ] The earliest Fortran compilers had statements for testing exceptional conditions.  These included the IF ACCUMULATOR OVERFLOW , IF QUOTIENT OVERFLOW , and IF DIVIDE CHECK statements.  In the interest of machine independence, they were not included in FORTRAN IV and the Fortran 66 Standard.  However since Fortran 2003 it is possible to test for numerical issues via calls to functions in the IEEE_EXCEPTIONS module.

PL/I has some 22 standard conditions (e.g., ZERODIVIDE SUBSCRIPTRANGE ENDFILE) which can be raised and which can be intercepted by: ON condition action; Programmers can also define and use their own named conditions.

Like the unstructured if , only one statement can be specified so in many cases a GOTO is needed to decide where flow of control should resume.

Unfortunately, some implementations had a substantial overhead in both space and time (especially SUBSCRIPTRANGE), so many programmers tried to avoid using conditions.

Common Syntax examples: ON condition GOTO label Exceptions [ edit ] Main article: Exception handling Modern languages have a specialized structured construct for exception handling which does not rely on the use of GOTO or (multi-level) breaks or returns. For example, in C++ one can write: try { xxx1 // Somewhere in here xxx2 //     use: '''throw''' someValue; xxx3 } catch ( someClass & someId ) { // catch value of someClass actionForSomeClass } catch ( someType & anotherId ) { // catch value of someType actionForSomeType } catch (...) { // catch anything not already caught actionForAnythingElse } Any number and variety of catch clauses can be used above. If there is no catch matching a particular throw , control percolates back through subroutine calls and/or nested blocks until a matching catch is found or until the end of the main program is reached, at which point the program is forcibly stopped with a suitable error message.

Via C++'s influence, catch is the keyword reserved for declaring a pattern-matching exception handler in other languages popular today, like Java or C#. Some other languages like Ada use the keyword exception to introduce an exception handler and then may even employ a different keyword ( when in Ada) for the pattern matching. A few languages like AppleScript incorporate placeholders in the exception handler syntax to automatically extract several pieces of information when the exception occurs. This approach is exemplified below by the on error construct from AppleScript: try set myNumber to myNumber / 0 on error e number n from f to t partial result pr if ( e = "Can't divide by zero" ) then display dialog "You must not do that" end try David Watt's 2004 textbook also analyzes exception handling in the framework of sequencers (introduced in this article in the section on early exits from loops). Watt notes that an abnormal situation, generally exemplified with arithmetic overflows or input/output failures like file not found, is a kind of error that "is detected in some low-level program unit, but [for which] a handler is more naturally located in a high-level program unit". For example, a program might contain several calls to read files, but the action to perform when a file is not found depends on the meaning (purpose) of the file in question to the program and thus a handling routine for this abnormal situation cannot be located in low-level system code. Watts further notes that introducing status flags testing in the caller, as single-exit structured programming or even (multi-exit) return sequencers would entail, results in a situation where "the application code tends to get cluttered by tests of status flags" and that "the programmer might forgetfully or lazily omit to test a status flag. In fact, abnormal situations represented by status flags are by default ignored!" Watt notes that in contrast to status flags testing, exceptions have the opposite default behavior , causing the program to terminate unless the program deals with the exception explicitly in some way, possibly by adding explicit code to ignore it. Based on these arguments, Watt concludes that jump sequencers or escape sequencers are less suitable as a dedicated exception sequencer with the semantics discussed above.

[ 35 ] In Object Pascal, D, Java, C#, and Python a finally clause can be added to the try construct. No matter how control leaves the try the code inside the finally clause is guaranteed to execute. This is useful when writing code that must relinquish an expensive resource (such as an opened file or a database connection) when finished processing: FileStream stm = null ; // C# example try { stm = new FileStream ( "logfile.txt" , FileMode .

Create ); return ProcessStuff ( stm ); // may throw an exception } finally { if ( stm != null ) stm .

Close (); } Since this pattern is fairly common, C# has a special syntax: using ( var stm = new FileStream ( "logfile.txt" , FileMode .

Create )) { return ProcessStuff ( stm ); // may throw an exception } Upon leaving the using -block, the compiler guarantees that the stm object is released, effectively binding the variable to the file stream while abstracting from the side effects of initializing and releasing the file. Python's with statement and Ruby's block argument to File.open are used to similar effect.

All the languages mentioned above define standard exceptions and the circumstances under which they are thrown. Users can throw exceptions of their own; C++ allows users to throw and catch almost any type, including basic types like int , whereas other languages like Java are less permissive.

Continuations [ edit ] Main article: Continuation Async [ edit ] C# 5.0 introduced the async keyword for supporting asynchronous I/O in a "direct style".

Generators [ edit ] Main article: Generator (computer science) Generators , also known as semicoroutines, allow control to be yielded to a consumer method temporarily, typically using a yield keyword ( yield description ) . Like the async keyword, this supports programming in a "direct style".

Coroutines [ edit ] Main article: Coroutine Coroutines are functions that can yield control to each other - a form of co-operative multitasking without threads.

Coroutines can be implemented as a library if the programming language provides either continuations or generators - so the distinction between coroutines and generators in practice is a technical detail.

Non-local control flow cross reference [ edit ] Programming language conditions exceptions generators/coroutines async Ada No Yes ?

?

APL No Yes No No C No No No No C++ No Yes Yes ?

C# No Yes Yes Yes COBOL Yes Yes No No Common Lisp Yes No ?

?

D No Yes Yes ?

Eiffel No Yes ?

?

Erlang No Yes Yes ?

F# No Yes Yes Yes Go No Yes Yes ?

Haskell No Yes Yes No Java No Yes No No JavaScript ?

Yes Yes Yes Objective-C No Yes No ?

PHP No Yes Yes ?

PL/I Yes No No No Python No Yes Yes Yes [ 36 ] Rebol Yes Yes No ?

Ruby No Yes Yes via extension [ 37 ] Rust No Yes experimental [ 38 ] [ 39 ] Yes [ 40 ] Scala No Yes via experimental extension [ 41 ] via experimental extension Tcl via traces Yes Yes via event loop Visual Basic .NET Yes Yes No ?

PowerShell No Yes No ?

Proposed control structures [ edit ] COMEFROM [ edit ] Main article: COMEFROM In a spoof Datamation article [ 42 ] in 1973, R. Lawrence Clark suggested that the GOTO statement could be replaced by the COMEFROM statement, and provides some entertaining examples. COMEFROM was implemented in one esoteric programming language named INTERCAL .

Event-based early exit from nested loops [ edit ] This construct was proposed by Zahn in 1974, [ 43 ] and discussed in Knuth (1974) . A modified version is presented here.

exitwhen EventA or EventB or EventC;
       xxx exits EventA: actionA
       EventB: actionB
       EventC: actionC endexit ; exitwhen is used to specify the events which may occur within xxx ,
their occurrence is indicated by using the name of the event as a statement. When some event does occur, the relevant action is carried out, and then control passes just after endexit . This construction provides a very clear separation between determining that some situation applies, and the action to be taken for that situation.

exitwhen is conceptually similar to exception handling , and exceptions or similar constructs are used for this purpose in many languages.

The following simple example involves searching a two-dimensional table for a particular item.

exitwhen found or missing; for I := 1 to N do for J := 1 to M do if table[I,J] = target then found;
       missing; exits found:   print ("item is in table");
       missing: print ("item is not in table"); endexit ; Security [ edit ] One way to attack a piece of software is to redirect the flow of execution of a program. A variety of control-flow integrity techniques, including stack canaries , buffer overflow protection , shadow stacks, and vtable pointer verification, are used to defend against these attacks.

[ 44 ] [ 45 ] [ 46 ] See also [ edit ] Branch (computer science) Control-flow analysis Control-flow diagram Control-flow graph Control table Coroutine Cyclomatic complexity Drakon-chart Flowchart Goto Jeroo , helps learn control structures Main loop predication Recursion Scheduling (computing) Spaghetti code Structured programming Subroutine Switch statement , alters control flow conditionally Zahn's construct Notes [ edit ] ^ In Fortran, this statement was deemed obsolescent in Fortran-90, and deleted as of Fortran 2018.

References [ edit ] ^ Böhm, Jacopini. "Flow diagrams, turing machines and languages with only two formation rules" Comm. ACM , 9(5):366-371, May 1966.

^ a b c d e f g Roberts, E. [1995] " Loop Exits and Structured Programming: Reopening the Debate Archived 2014-07-25 at the Wayback Machine ," ACM SIGCSE Bulletin, (27)1: 268–272.

^ David Anthony Watt; William Findlay (2004).

Programming language design concepts . John Wiley & Sons. p. 228.

ISBN 978-0-470-85320-7 .

^ "Nested Loops in C with Examples" .

GeeksforGeeks . 2019-11-25 . Retrieved 2024-03-14 .

^ "Python Nested Loops" .

www.w3schools.com . Retrieved 2024-03-14 .

^ Dean, Jenna (2019-11-22).

"Nested Loops" .

The Startup . Retrieved 2024-03-14 .

^ Knuth, Donald E.

(1974). "Structured Programming with go to Statements".

Computing Surveys .

6 (4): 261– 301.

CiteSeerX 10.1.1.103.6084 .

doi : 10.1145/356635.356640 .

S2CID 207630080 .

^ Ada Programming: Control: Endless Loop ^ "What is a loop and how we can use them?" . Archived from the original on 2020-07-28 . Retrieved 2020-05-25 .

^ "redo - perldoc.perl.org" .

perldoc.perl.org . Retrieved 2020-09-25 .

^ "control_expressions - Documentation for Ruby 2.4.0" .

docs.ruby-lang.org . Retrieved 2020-09-25 .

^ "control_expressions - Documentation for Ruby 2.3.0" .

docs.ruby-lang.org . Retrieved 2020-09-25 .

^ a b "Messy Loop Conditions" .

WikiWikiWeb . 2014-11-03.

^ a b c Knuth 1974 , p. 278, Simple Iterations.

^ Edsger W. Dijkstra , personal communication to Donald Knuth on 1974-01-03, cited in Knuth (1974 , p. 278, Simple Iterations) ^ a b c Knuth 1974 , p. 279.

^ Advanced Bash Scripting Guide: 11.3. Loop Control ^ PHP Manual: " break " ^ perldoc: last ^ comp.lang.c FAQ list · " Question 20.20b " ^ [Python-3000] Announcing PEP 3136 , Guido van Rossum ^ a b Kozen, Dexter (2008). "The Böhm–Jacopini Theorem is False, Propositionally".

Mathematics of Program Construction (PDF) . Lecture Notes in Computer Science. Vol. 5133. pp.

177– 192.

CiteSeerX 10.1.1.218.9241 .

doi : 10.1007/978-3-540-70594-9_11 .

ISBN 978-3-540-70593-2 .

^ Kosaraju, S. Rao. "Analysis of structured programs," Proc. Fifth Annual ACM Syrup.
Theory of Computing, (May 1973), 240-252; also in J. Computer and System Sciences, 9,
3 (December 1974), cited by Knuth (1974) .

^ David Anthony Watt; William Findlay (2004).

Programming language design concepts . John Wiley & Sons. pp.

215– 221.

ISBN 978-0-470-85320-7 .

^ Dahl & Dijkstra & Hoare, "Structured Programming" Academic Press, 1972.

^ "6. Throw It For a Loop" .

^ "3.2.5.1 Looping Constructs" , The GNU Bash Reference Manual , 2025-05-18 ^ "How could a language make the loop-and-a-half less error-prone?" .

Stack Exchange: Programming Language Design and Implementation .

^ "3.2.4 Lists of Commands" , The GNU Bash Reference Manual , 2025-05-18 ^ "What does the comma operator , do?" .

Stack Overflow .

^ Meyer, Bertrand (1991).

Eiffel: The Language . Prentice Hall. pp.

129– 131.

^ "Common Lisp LOOP macro" .

^ for_each . Sgi.com. Retrieved on 2010-11-09.

^ Chapter 1. Boost.Foreach Archived 2010-01-29 at the Wayback Machine . Boost-sandbox.sourceforge.net (2009-12-19). Retrieved on 2010-11-09.

^ David Anthony Watt; William Findlay (2004).

Programming language design concepts . John Wiley & Sons. pp.

221– 222.

ISBN 978-0-470-85320-7 .

^ "asyncio — Asynchronous I/O" .

Python documentation .

^ "Socketry/Async" .

GitHub . 25 February 2022.

^ "generators - The Rust Unstable Book" .

doc.rust-lang.org .

^ "corona - Rust" .

docs.rs .

^ "Introduction - Asynchronous Programming in Rust" .

rust-lang.github.io .

^ "Jitsi Meet" . Storm-enroute.com . Retrieved 2022-09-07 .

^ We don't know where to GOTO if we don't know where we've COME FROM. This (spoof) linguistic innovation lives up to all expectations.

Archived 2018-07-16 at the Wayback Machine By R. Lawrence Clark* From Datamation, December, 1973 ^ Zahn, C. T. "A control statement for natural top-down structured programming" presented at Symposium on Programming Languages, Paris, 1974.

^ Payer, Mathias ; Kuznetsov, Volodymyr.

"On differences between the CFI, CPS, and CPI properties" .

nebelwelt.net . Retrieved 2016-06-01 .

^ "Adobe Flash Bug Discovery Leads To New Attack Mitigation Method" .

Dark Reading . 10 November 2015 . Retrieved 2016-06-01 .

^ Endgame.

"Endgame to Present at Black Hat USA 2016" .

www.prnewswire.com (Press release) . Retrieved 2016-06-01 .

Further reading [ edit ] Hoare, C. A. R. "Partition: Algorithm 63," "Quicksort: Algorithm 64," and "Find: Algorithm 65." Comm. ACM 4, 321–322, 1961.

External links [ edit ] The Wikibook Ada Programming has a page on the topic of: Control The Wikibook Computer Programming has a page on the topic of: Control Media related to Control flow at Wikimedia Commons Go To Statement Considered Harmful A Linguistic Contribution of GOTO-less Programming "Structured Programming with Go To Statements" (PDF) . Archived from the original (PDF) on 2009-08-24.

(2.88 MB) "IBM 704 Manual" (PDF) .

(31.4 MB) NewPP limit report
Parsed by mw‐api‐ext.codfw.main‐7c4585bdc‐rkdtf
Cached time: 20250813014143
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.795 seconds
Real time usage: 0.978 seconds
Preprocessor visited node count: 8781/1000000
Revision size: 68336/2097152 bytes
Post‐expand include size: 119602/2097152 bytes
Template argument size: 6885/2097152 bytes
Highest expansion depth: 13/100
Expensive parser function count: 51/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 176621/5000000 bytes
Lua time usage: 0.352/10.000 seconds
Lua memory usage: 9244056/52428800 bytes
Number of Wikibase entities loaded: 1/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  728.051      1 -total
 33.28%  242.278      2 Template:Reflist
 12.77%   93.006     22 Template:Cite_web
 12.76%   92.865      5 Template:Cite_book
 11.49%   83.654      1 Template:Loop_constructs
 11.21%   81.598      1 Template:Sidebar
  9.70%   70.630      1 Template:Short_description
  6.56%   47.739      2 Template:Pagetype
  6.37%   46.396      6 Template:Sfn
  4.69%   34.159      1 Template:Flatlist Saved in parser cache with key enwiki:pcache:45459:|#|:idhash:canonical and timestamp 20250813014143 and revision id 1305601536. Rendering was triggered because: unknown Retrieved from " https://en.wikipedia.org/w/index.php?title=Control_flow&oldid=1305601536#Loops " Categories : Control flow Iteration in programming Programming language comparisons Recursion Hidden categories: Webarchive template wayback links Articles with short description Short description is different from Wikidata All articles with unsourced statements Articles with unsourced statements from July 2014 Wikipedia articles needing clarification from November 2015 Articles with example Python (programming language) code Commons category link from Wikidata Articles with example Ada code Articles with example ALGOL 60 code Articles with example ALGOL 68 code Articles with example C code Articles with example C++ code Articles with example C Sharp code Articles with example D code Articles with example Fortran code Articles with example Haskell code Articles with example Java code Articles with example JavaScript code Articles with example Lisp (programming language) code Articles with example MATLAB/Octave code Articles with example Pascal code Articles with example Perl code Articles with example PHP code Articles with example Ruby code Articles with example Smalltalk code This page was last edited on 13 August 2025, at 01:41 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Control flow 33 languages Add topic

