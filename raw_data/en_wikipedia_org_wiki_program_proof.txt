Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Approaches Toggle Approaches subsection 1.1 Model checking 1.2 Deductive verification 1.3 Application to software 2 Verification and validation 3 Automated program repair 4 Industry use 5 See also 6 References Toggle the table of contents Formal verification 21 languages العربية Català Čeština Ελληνικά Español Euskara فارسی Français 한국어 Italiano עברית 日本語 Polski Português Русский Simple English Српски / srpski Svenska Türkçe Українська 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia (Redirected from Program proof ) Proving or disproving the correctness of certain intended algorithms Not to be confused with Verificationism .

For the Wikipedia policy, see Wikipedia:Verifiability .

In the context of hardware and software systems, formal verification is the act of proving or disproving the correctness of a system with respect to a certain formal specification or property, using formal methods of mathematics .

[ 1 ] Formal verification is a key incentive for formal specification of systems, and is at the core of formal methods .
It represents an important dimension of analysis and verification in electronic design automation and is one approach to software verification . The use of formal verification enables the highest Evaluation Assurance Level ( EAL7 ) in the framework of common criteria for computer security certification.

[ 2 ] Formal verification can be helpful in proving the correctness of systems such as: cryptographic protocols , combinational circuits , digital circuits with internal memory, and software expressed as source code in a programming language . Prominent examples of verified software systems include the CompCert verified C compiler and the seL4 high-assurance operating system kernel .

The verification of these systems is done by ensuring the existence of a formal proof of a mathematical model of the system.

[ 3 ] Examples of mathematical objects used to model systems are: finite-state machines , labelled transition systems , Horn clauses , Petri nets , vector addition systems , timed automata , hybrid automata , process algebra , formal semantics of programming languages such as operational semantics , denotational semantics , axiomatic semantics and Hoare logic .

[ 4 ] Approaches [ edit ] Model checking [ edit ] Model checking involves a systematic and exhaustive exploration of the mathematical model. Such exploration is possible for finite models , but also for some infinite models, where infinite sets of states can be effectively represented finitely by using abstraction or taking advantage of symmetry. Usually, this consists of exploring all states and transitions in the model, by using smart and domain-specific abstraction techniques to consider whole groups of states in a single operation and reduce computing time. Implementation techniques include state space enumeration , symbolic state space enumeration, abstract interpretation , symbolic simulation , abstraction refinement.

[ citation needed ] The properties to be verified are often described in temporal logics , such as linear temporal logic (LTL), Property Specification Language (PSL), SystemVerilog Assertions (SVA), [ 5 ] or computational tree logic (CTL). The great advantage of model checking is that it is often fully automatic; its primary disadvantage is that it does not in general scale to large systems; symbolic models are typically limited to a few hundred bits of state, while explicit state enumeration requires the state space being explored to be relatively small.

Deductive verification [ edit ] Another approach is deductive verification.

[ 6 ] [ 7 ] It consists of generating from the system and its specifications (and possibly other annotations) a collection of mathematical proof obligations , the truth of which imply conformance of the system to its specification, and discharging these obligations using either proof assistants (interactive theorem provers) (such as HOL , ACL2 , Isabelle , Rocq (previously known as Coq ) or PVS ), or automatic theorem provers , including in particular satisfiability modulo theories (SMT) solvers. This approach has the disadvantage that it may require the user to understand in detail why the system works correctly, and to convey this information to the verification system, either in the form of a sequence of theorems to be proved or in the form of specifications (invariants, preconditions, postconditions) of system components (e.g. functions or procedures) and perhaps subcomponents (such as loops or data structures).

Application to software [ edit ] Formal verification of software programs involves proving that a program satisfies a formal specification of its behavior. Subareas of formal verification include deductive verification (see above), abstract interpretation , automated theorem proving , type systems , and lightweight formal methods . A promising type-based verification approach is dependently typed programming , in which the types of functions include (at least part of) those functions' specifications, and type-checking the code establishes its correctness against those specifications. Fully featured dependently typed languages support deductive verification as a special case.

Another complementary approach is program derivation , in which efficient code is produced from functional specifications by a series of correctness-preserving steps. An example of this approach is the Bird–Meertens formalism , and this approach can be seen as another form of program synthesis .

These techniques can be sound , meaning that the verified properties can be logically deduced from the semantics, or unsound , meaning that there is no such guarantee. A sound technique yields a result only once it has covered the entire space of possibilities. An example of an unsound technique is one that covers only a subset of the possibilities, for instance only integers up to a certain number, and give a "good-enough" result. Techniques can also be decidable , meaning that their algorithmic implementations are guaranteed to terminate with an answer, or undecidable, meaning that they may never terminate. By bounding the scope of possibilities, unsound techniques that are decidable might be able to be constructed when no decidable sound techniques are available.

Verification and validation [ edit ] Main article: Verification and validation Verification is one aspect of testing a product's fitness for purpose. Validation is the complementary aspect. Often one refers to the overall checking process as V & V.

Validation : "Are we trying to make the right thing?", i.e., is the product specified to the user's actual needs?

Verification : "Have we made what we were trying to make?", i.e., does the product conform to the specifications?

The verification process consists of static/structural and dynamic/behavioral aspects. E.g., for a software product one can inspect the source code (static) and run against specific test cases (dynamic). Validation usually can be done only dynamically, i.e., the product is tested by putting it through typical and atypical usages ("Does it satisfactorily meet all use cases ?").

Automated program repair [ edit ] Main article: Automatic bug fixing Program repair is performed with respect to an oracle , encompassing the desired functionality of the program which is used for validation of the generated fix. A simple example is a test-suite—the input/output pairs specify the functionality of the program. A variety of techniques are employed, most notably using satisfiability modulo theories (SMT) solvers, and genetic programming , [ 8 ] using evolutionary computing to generate and evaluate possible candidates for fixes. The former method is deterministic, while the latter is randomized.

Program repair combines techniques from formal verification and program synthesis . Fault-localization techniques in formal verification are used to compute program points which might be possible bug-locations, which can be targeted by the synthesis modules. Repair systems often focus on a small pre-defined class of bugs in order to reduce the search space. Industrial use is limited owing to the computational cost of existing techniques.

Industry use [ edit ] This section may require cleanup to meet Wikipedia's quality standards . The specific problem is: needs a more well-rounded overview of the subject; filter for what is actually used in industry; only mention notable papers.

Please help improve this section if you can.

( October 2022 ) ( Learn how and when to remove this message ) The growth in complexity of designs increases the importance of formal verification techniques in the hardware industry .

[ 9 ] [ 10 ] At present, formal verification is used by most or all leading hardware companies, [ 11 ] but its use in the software industry is still languishing.

[ citation needed ] This could be attributed to the greater need in the hardware industry, where errors have greater commercial significance.

[ citation needed ] Because of the potential subtle interactions between components, it is increasingly difficult to exercise a realistic set of possibilities by simulation. Important aspects of hardware design are amenable to automated proof methods, making formal verification easier to introduce and more productive.

[ 12 ] As of 2011 [update] , several operating systems have been formally verified:
NICTA's Secure Embedded L4 microkernel , sold commercially as seL4 by OK Labs; [ 13 ] OSEK/VDX based real-time operating system ORIENTAIS by East China Normal University ; [ citation needed ] Green Hills Software's Integrity operating system ; [ citation needed ] and SYSGO 's PikeOS .

[ 14 ] [ 15 ] In 2016, a team led by Zhong Shao at Yale developed a formally verified operating system kernel called CertiKOS.

[ 16 ] [ 17 ] As of 2017, formal verification has been applied to the design of large computer networks through a mathematical model of the network, [ 18 ] and as part of a new network technology category, intent-based networking .

[ 19 ] Network software vendors that offer formal verification solutions include Cisco [ 20 ] Forward Networks [ 21 ] [ 22 ] and Veriflow Systems.

[ 23 ] The SPARK programming language provides a toolset which enables software development with formal verification and is used in several high-integrity systems .

[ citation needed ] The CompCert C compiler is a formally verified C compiler implementing the majority of ISO C.

[ 24 ] [ 25 ] See also [ edit ] Look up verifiability in Wiktionary, the free dictionary.

Automated theorem proving Model checking List of model checking tools Formal equivalence checking Proof checker Property Specification Language Static code analysis Temporal logic in finite-state verification Post-silicon validation Intelligent verification Runtime verification Software verification Hardware verification References [ edit ] ^ Sanghavi, Alok (May 21, 2010). "What is formal verification?".

EE Times Asia .

^ "Common Criteria for Information Technology Security Evaluation Part 5: Pre-defined packages of security requirements" (PDF) . Retrieved April 15, 2025 .

^ Sanjit A. Seshia; Natasha Sharygina; Stavros Tripakis (2018). "Chapter 3: Modeling for Verification". In Clarke, Edmund M.; Henzinger, Thomas A.; Veith, Helmut; Bloem, Roderick (eds.).

Handbook of Model Checking . Springer. pp.

75– 105.

doi : 10.1007/978-3-319-10575-8 .

ISBN 978-3-319-10574-1 .

^ Introduction to Formal Verification , Berkeley University of California, Retrieved November 6, 2013 ^ Cohen, Ben; Venkataramanan, Srinivasan; Kumari, Ajeetha; Piper, Lisa (2015).

SystemVerilog Assertions Handbook (4th ed.). CreateSpace Independent Publishing Platform.

ISBN 978-1518681448 .

^ Ahrendt, Wolgang; Beckert, Bernhard; Bubel, Richard; Hähnle, Reiner; Schmitt, Peter H., eds. (2016).

Deductive Software Verification - The KeY Book: From Theory to Practice (1st 2016 ed.). Cham: Springer International Publishing : Imprint: Springer.

ISBN 978-3-319-49812-6 .

^ Pretschner, Alexander; Müller, Peter; Stöckle, Patrick, eds. (2019). "Building Deductive Program Verifiers - Lecture Notes".

Engineering secure and dependable software systems . Amsterdam, Netherlands: IOS Press.

ISBN 978-1-61499-976-8 .

^ Le Goues, Claire ; Nguyen, ThanhVu; Forrest, Stephanie; Weimer, Westley (January 2012).

"GenProg: A Generic Method for Automatic Software Repair" .

IEEE Transactions on Software Engineering .

38 (1): 54– 72.

doi : 10.1109/TSE.2011.104 .

S2CID 4111307 .

^ Harrison, J. (2003). "Formal verification at Intel".

18th Annual IEEE Symposium of Logic in Computer Science, 2003. Proceedings . pp.

45– 54.

doi : 10.1109/LICS.2003.1210044 .

ISBN 978-0-7695-1884-8 .

S2CID 44585546 .

^ Formal verification of a real-time hardware design . Portal.acm.org (June 27, 1983). Retrieved on April 30, 2011.

^ "Formal Verification: An Essential Tool for Modern VLSI Design by Erik Seligman, Tom Schubert, and M V Achutha Kirankumar" . 2015.

^ "Formal Verification in Industry" (PDF) . Retrieved September 20, 2012 .

^ "Abstract Formal Specification of the seL4/ARMv6 API" (PDF) . Archived from the original (PDF) on May 21, 2015 . Retrieved May 19, 2015 .

^ Christoph Baumann, Bernhard Beckert, Holger Blasum, and Thorsten Bormer Ingredients of Operating System Correctness? Lessons Learned in the Formal Verification of PikeOS Archived July 19, 2011, at the Wayback Machine ^ "Getting it Right" by Jack Ganssle ^ Harris, Robin.

"Unhackable OS? CertiKOS enables creation of secure system kernels" .

ZDNet . Retrieved June 10, 2019 .

^ "CertiKOS: Yale develops world's first hacker-resistant operating system" .

International Business Times UK . November 15, 2016 . Retrieved June 10, 2019 .

^ Scroxton, Alex.

"For Cisco, intent-based networking heralds future tech demands" . Computer Weekly . Retrieved February 12, 2018 .

^ Lerner, Andrew.

"Intent-based networking" . Gartner . Retrieved February 12, 2018 .

^ Kerravala, Zeus.

"Cisco brings intent based networks to the data center" . NetworkWorld.

Archived from the original on December 11, 2023 . Retrieved February 12, 2018 .

^ "Forward Networks: Accelerating and De-risking Network Operations" .

Insightssuccess Media and Technology Pvt. Ltd . Insights Success. January 16, 2018 . Retrieved February 12, 2018 .

^ "Getting Grounded in Intent=based Networking" (PDF) . NetworkWorld . Retrieved February 12, 2018 .

^ "Veriflow Systems" . Bloomberg . Retrieved February 12, 2018 .

^ "CompCert - The CompCert C compiler" .

compcert.org . Retrieved February 22, 2023 .

^ Barrière, Aurèle; Blazy, Sandrine ; Pichardie, David (January 9, 2023).

"Formally Verified Native Code Generation in an Effectful JIT: Turning the CompCert Backend into a Formally Verified JIT Compiler" .

Proceedings of the ACM on Programming Languages .

7 (POPL): 249– 277.

arXiv : 2212.03129 .

doi : 10.1145/3571202 .

ISSN 2475-1421 .

S2CID 253736486 .

NewPP limit report
Parsed by mw‐web.codfw.main‐6cc77c66b8‐zkljf
Cached time: 20250812015435
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.435 seconds
Real time usage: 0.540 seconds
Preprocessor visited node count: 3127/1000000
Revision size: 18704/2097152 bytes
Post‐expand include size: 68091/2097152 bytes
Template argument size: 7435/2097152 bytes
Highest expansion depth: 15/100
Expensive parser function count: 15/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 80951/5000000 bytes
Lua time usage: 0.271/10.000 seconds
Lua memory usage: 7528330/52428800 bytes
Number of Wikibase entities loaded: 0/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  492.603      1 -total
 45.95%  226.328      1 Template:Reflist
 18.04%   88.870      3 Template:Cite_journal
 13.82%   68.099      6 Template:Citation_needed
 12.66%   62.366     13 Template:Cite_web
 12.22%   60.188      1 Template:Short_description
 11.85%   58.384      6 Template:Fix
  9.99%   49.204     12 Template:Main_other
  8.67%   42.731      1 Template:Cleanup
  7.83%   38.575     13 Template:Category_handler Saved in parser cache with key enwiki:pcache:270054:|#|:idhash:canonical and timestamp 20250812015435 and revision id 1285719773. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Formal_verification&oldid=1285719773 " Categories : Electronic circuit verification Formal methods Logic in computer science Theoretical computer science Hidden categories: Webarchive template wayback links Articles with short description Short description is different from Wikidata Use mdy dates from June 2019 All articles with unsourced statements Articles with unsourced statements from December 2014 Articles needing cleanup from October 2022 All pages needing cleanup Cleanup tagged articles with a reason field from October 2022 Wikipedia pages needing cleanup from October 2022 Articles with unsourced statements from December 2011 Articles containing potentially dated statements from 2011 All articles containing potentially dated statements Articles with unsourced statements from March 2012 Articles with unsourced statements from October 2022 This page was last edited on 15 April 2025, at 10:45 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Formal verification 21 languages Add topic

