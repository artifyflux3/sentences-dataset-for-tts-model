Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Overview 2 Versions history 3 Servants 4 Features Toggle Features subsection 4.1 Objects By Reference 4.2 Data By Value 4.3 Objects By Value (OBV) 4.4 CORBA Component Model (CCM) 4.5 Portable interceptors 4.6 General InterORB Protocol (GIOP) 4.7 VMCID (Vendor Minor Codeset ID) 4.8 Corba Location (CorbaLoc) 5 Benefits Toggle Benefits subsection 5.1 Language independence 5.2 OS-independence 5.3 Freedom from technologies 5.4 Data-typing 5.5 High tunability 5.6 Freedom from data-transfer details 5.7 Compression 6 Problems and criticism Toggle Problems and criticism subsection 6.1 Initial implementation incompatibilities 6.2 Location transparency 6.3 Design and process deficiencies 6.4 Problems with implementations 6.5 Firewalls 7 See also Toggle See also subsection 7.1 Software engineering 7.2 Component-based software technologies 7.3 Language bindings 8 References 9 Further reading 10 External links Toggle the table of contents Common Object Request Broker Architecture 27 languages العربية Català Deutsch Español Euskara فارسی Français Gaeilge Galego 한국어 Italiano Кыргызча Lietuvių Magyar मराठी Nederlands 日本語 Norsk bokmål Polski Português Русский Slovenščina Suomi Svenska Türkçe Українська 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Standard to facilitate communication between systems on diverse platforms This article has multiple issues.

Please help improve it or discuss these issues on the talk page .

( Learn how and when to remove these messages ) This article includes a list of general references , but it lacks sufficient corresponding inline citations .

Please help to improve this article by introducing more precise citations.

( February 2009 ) ( Learn how and when to remove this message ) This article contains instructions or advice .

Wikipedia is not a guidebook; please help rewrite the content to make it more encyclopedic or move it to Wikiversity , Wikibooks , or Wikivoyage .

( April 2023 ) This article needs more complete citations for verification .

Please help add missing citation information so that sources are clearly identifiable.

( July 2025 ) ( Learn how and when to remove this message ) ( Learn how and when to remove this message ) Common Object Request Broker Architecture Abbreviation CORBA Status Published Year started 1991 ; 34 years ago ( 1991 ) Latest version 3.4 February 2021 ; 4 years ago ( 2021-02 ) Organization Object Management Group Website www .corba .org The Common Object Request Broker Architecture ( CORBA ) is a standard defined by the Object Management Group (OMG) designed to facilitate the communication of systems that are deployed on diverse platforms . CORBA enables collaboration between systems on different operating systems, programming languages , and computing hardware. CORBA uses an object-oriented model although the systems that use the CORBA do not have to be object-oriented. CORBA is an example of the distributed object paradigm.

While briefly popular in the mid to late 1990s, CORBA's complexity, inconsistency, and high licensing costs have relegated it to being a niche technology.

[ 1 ] Overview [ edit ] CORBA enables communication between software written in different languages and running on different computers. Implementation details from specific operating systems, programming languages, and hardware platforms are all removed from the responsibility of developers who use CORBA. CORBA normalizes the method-call semantics between application objects residing either in the same address-space (application) or in remote address-spaces (same host, or remote host on a network). Version 1.0 was released in October 1991.

CORBA uses an interface definition language (IDL) to specify the interfaces that objects present to the outer world. CORBA then specifies a mapping from IDL to a specific implementation language like C++ or Java . Standard mappings exist for Ada , C , C++ , C++11 , COBOL , Java , Lisp , PL/I , Object Pascal , Python , Ruby , and Smalltalk . Non-standard mappings exist for C# , Erlang , Perl , Tcl , and Visual Basic implemented by object request brokers (ORBs) written for those languages. Versions of IDL have changed significantly with annotations replacing some pragmas.

The CORBA specification dictates there shall be an ORB through which an application would interact with other objects. This is how it is implemented in practice: The application initializes the ORB, and accesses an internal Object Adapter , which maintains things like reference counting , object (and reference) instantiation policies, and object lifetime policies.

The Object Adapter is used to register instances of the generated code classes . Generated code classes are the result of compiling the user IDL code, which translates the high-level interface definition into an OS- and language-specific class base for use by the user application. This step is necessary in order to enforce CORBA semantics and provide a clean user process for interfacing with the CORBA infrastructure.

Some IDL mappings are more difficult to use than others. For example, due to the nature of Java, the IDL-Java mapping is rather straightforward and makes usage of CORBA very simple in a Java application. This is also true of the IDL to Python mapping. The C++ mapping requires the programmer to learn datatypes that predate the C++ Standard Template Library (STL). By contrast, the C++11 mapping is easier to use, but requires heavy use of the STL. Since the C language is not object-oriented, the IDL to C mapping requires a C programmer to manually emulate object-oriented features.

In order to build a system that uses or implements a CORBA-based distributed object interface, a developer must either obtain or write the IDL code that defines the object-oriented interface to the logic the system will use or implement. Typically, an ORB implementation includes a tool called an IDL compiler that translates the IDL interface into the target language for use in that part of the system. A traditional compiler then compiles the generated code to create the linkable-object files for use in the application. This diagram illustrates how the generated code is used within the CORBA infrastructure: Illustration of the autogeneration of the infrastructure code from an interface defined using the CORBA IDL This figure illustrates the high-level paradigm for remote interprocess communications using CORBA. The CORBA specification further addresses data typing, exceptions, network protocols, communication timeouts, etc. For example: Normally the server side has the Portable Object Adapter (POA) that redirects calls either to the local servants or (to balance the load) to the other servers. The CORBA specification (and thus this figure) leaves various aspects of distributed system to the application to define including object lifetimes (although reference counting semantics are available to applications), redundancy/fail-over, memory management, dynamic load balancing, and application-oriented models such as the separation between display/data/control semantics (e.g. see Model–view–controller ), etc.

In addition to providing users with a language and a platform-neutral remote procedure call (RPC) specification, CORBA defines commonly needed services such as transactions and security, events, time, and other domain-specific interface models.

Versions history [ edit ] This table presents the history of CORBA standard versions.

[ 2 ] [ 3 ] [ 4 ] Version Version Date Highlights Corba IDL Version 1.0 October 1991 First version, C mapping — 1.1 February 1992 Interoperability, C++ mapping — 1.2 December 1993 — 2.0 August 1996 First major update of the standard, also dubbed CORBA 2 — 2.1 August 1997 — 2.2 February 1998 Java mapping — 2.3 June 1999 — 2.4 August 2000 — 2.5 September 2001 — 2.6 December 2001 — 3.0 July 2002 Second major update of the standard, also dubbed CORBA 3 CORBA Component Model (CCM) — 3.0.1 November 2002 — 3.0.2 December 2002 — 3.0.3 March 2004 — 3.1 January 2008 — 3.1.1 August 2011 Adopted as 2012 edition of ISO/IEC 19500 — 3.2 November 2011 — 3.3 November 2012 Addition of ZIOP — 3.4 February 2021 Annotations 4.2 Note that IDL changes have progressed with annotations (e.g. @unit, @topic) replacing some pragmas.

Servants [ edit ] A servant is the invocation target containing methods for handling the remote method invocations . In the newer CORBA versions, the remote object (on the server side) is split into the object (that is exposed to remote invocations) and servant (to which the former part forwards the method calls) . It can be one servant per remote object , or the same servant can support several (possibly all) objects, associated with the given Portable Object Adapter . The servant for each object can be set or found "once and forever" (servant activation) or dynamically chosen each time the method on that object is invoked (servant location). Both servant locator and servant activator can forward the calls to another server. In total, this system provides a very powerful means to balance the load, distributing requests between several machines. In the object-oriented languages, both remote object and its servant are objects from the viewpoint of the object-oriented programming.

Incarnation is the act of associating a servant with a CORBA object so that it may service requests. Incarnation provides a concrete servant form for the virtual CORBA object. Activation and deactivation refer only to CORBA objects, while the terms incarnation and etherealization refer to servants. However, the lifetimes of objects and servants are independent. You always incarnate a servant before calling activate_object(), but the reverse is also possible, create_reference() activates an object without incarnating a servant, and servant incarnation is later done on demand with a Servant Manager.

The Portable Object Adapter (POA) is the CORBA object responsible for splitting the server side remote invocation handler into the remote object and its servant . The object is exposed for the remote invocations, while the servant contains the methods that are actually handling the requests. The servant for each object can be chosen either statically (once) or dynamically (for each remote invocation), in both cases allowing the call forwarding to another server.

On the server side, the POAs form a tree-like structure, where each POA is responsible for one or more objects being served. The branches of this tree can be independently activated/deactivated, have the different code for the servant location or activation and the different request handling policies.

Features [ edit ] The following describes some of the most significant ways that CORBA can be used to facilitate communication among distributed objects.

Objects By Reference [ edit ] This reference is either acquired through a stringified Uniform Resource Locator (URL), NameService lookup (similar to Domain Name System (DNS)), or passed-in as a method parameter during a call.

Object references are lightweight objects matching the interface of the real object (remote or local). Method calls on the reference result in subsequent calls to the ORB and blocking on the thread while waiting for a reply, success, or failure. The parameters, return data (if any), and exception data are marshaled internally by the ORB according to the local language and OS mapping.

Data By Value [ edit ] The CORBA Interface Definition Language provides the language- and OS-neutral inter-object communication definition. CORBA Objects are passed by reference, while data (integers, doubles, structs, enums, etc.) are passed by value. The combination of Objects-by-reference and data-by-value provides the means to enforce great data typing while compiling clients and servers, yet preserve the flexibility inherent in the CORBA problem-space.

Objects By Value (OBV) [ edit ] Apart from remote objects, the CORBA and RMI-IIOP define the concept of the OBV and Valuetypes. The code inside the methods of Valuetype objects is executed locally by default. If the OBV has been received from the remote side, the needed code must be either a priori known for both sides or dynamically downloaded from the sender. To make this possible, the record, defining OBV, contains the Code Base that is a space-separated list of URLs whence this code should be downloaded. The OBV can also have the remote methods.

CORBA Component Model (CCM) [ edit ] CORBA Component Model (CCM) is an addition to the family of CORBA definitions.

[ 5 ] It was introduced with CORBA 3 and it describes a standard application framework for CORBA components. Though not dependent on "language dependent Enterprise Java Beans (EJB)", it is a more general form of EJB, providing four component types instead of the two that EJB defines. It provides an abstraction of entities that can provide and accept services through well-defined named interfaces called ports .

The CCM has a component container, where software components can be deployed. The container offers a set of services that the components can use. These services include (but are not limited to) notification , authentication , persistence , and transaction processing . These are the most-used services any distributed system requires, and, by moving the implementation of these services from the software components to the component container, the complexity of the components is dramatically reduced.

Portable interceptors [ edit ] Portable interceptors are the "hooks", used by CORBA and RMI-IIOP to mediate the most important functions of the CORBA system. The CORBA standard defines the following types of interceptors: IOR interceptors mediate the creation of the new references to the remote objects, presented by the current server.

Client interceptors usually mediate the remote method calls on the client (caller) side. If the object Servant exists on the same server where the method is invoked, they also mediate the local calls.

Server interceptors mediate the handling of the remote method calls on the server (handler) side.

The interceptors can attach the specific information to the messages being sent and IORs being created. This information can be later read by the corresponding interceptor on the remote side. Interceptors can also throw forwarding exceptions, redirecting request to another target.

General InterORB Protocol (GIOP) [ edit ] Main article: General Inter-ORB Protocol The GIOP is an abstract protocol by which Object request brokers (ORBs) communicate. Standards associated with the protocol are maintained by the Object Management Group (OMG). The GIOP architecture provides several concrete protocols, including: Internet InterORB Protocol (IIOP) – The Internet Inter-Orb Protocol is an implementation of the GIOP for use over the Internet , and provides a mapping between GIOP messages and the TCP/IP layer.

SSL InterORB Protocol (SSLIOP) – SSLIOP is IIOP over SSL , providing encryption and authentication .

HyperText InterORB Protocol (HTIOP) – HTIOP is IIOP over HTTP , providing transparent proxy bypassing.

Zipped IOP (ZIOP) – A zipped version of GIOP that reduces the bandwidth usage.

VMCID (Vendor Minor Codeset ID) [ edit ] Each standard CORBA exception includes a minor code to designate the subcategory of the exception. Minor exception codes are of type unsigned long and consist of a 20-bit "Vendor Minor Codeset ID" (VMCID), which occupies the high order 20 bits, and the minor code proper which occupies the low order 12 bits.

Minor codes for the standard exceptions are prefaced by the VMCID assigned to OMG, defined as the unsigned long constant CORBA::OMGVMCID, which has the VMCID allocated to OMG occupying the high order 20 bits. The minor exception codes associated with the standard exceptions that are found in Table 3–13 on page 3-58 are or-ed with OMGVMCID to get the minor code value that is returned in the ex_body structure.

[ 6 ] Within a vendor assigned space, the assignment of values to minor codes is left to the vendor.

[ 7 ] [ 8 ] The VMCID 0 and 0xfffff are reserved for experimental use. The VMCID OMGVMCID [ 9 ] and 1 through 0xf are reserved for OMG use.

[ 10 ] Corba Location (CorbaLoc) [ edit ] Corba Location (CorbaLoc) refers to a stringified object reference for a CORBA object that looks similar to a URL.

All CORBA products must support two OMG-defined URLs: " corbaloc: " and " corbaname: ". The purpose of these is to provide a human readable and editable way to specify a location where an IOR can be obtained.

An example of corbaloc is shown below: corbaloc::160.45.110.41:38693/StandardNS/NameServer-POA/_root A CORBA product may optionally support the " http: ", " ftp: ", and " file: " formats. The semantics of these is that they provide details of how to download a stringified IOR (or, recursively, download another URL that will eventually provide a stringified IOR). Some ORBs do deliver additional formats which are proprietary for that ORB.

Benefits [ edit ] CORBA's benefits include language- and OS-independence, freedom from technology-linked implementations, strong data-typing, high level of tunability, and freedom from the details of distributed data transfers.

Language independence [ edit ] CORBA was designed to free engineers from limitations of coupling their designs to a particular software language. Currently there are many languages supported by various CORBA providers, the most popular being Java and C++. There are also C++11, C-only, Smalltalk, Perl, Ada, Ruby, and Python implementations, just to mention a few.

OS-independence [ edit ] CORBA's design is meant to be OS-independent. CORBA is available in Java (OS-independent), as well as natively for Linux/Unix, Windows, Solaris, OS X, OpenVMS, HPUX, Android, LynxOS, VxWorks, ThreadX, INTEGRITY, and others.

Freedom from technologies [ edit ] One of the main implicit benefits is that CORBA provides a neutral playing field for engineers to be able to normalize the interfaces between various new and legacy systems. When integrating C, C++, Object Pascal, Java, Fortran, Python, and any other language or OS into a single cohesive system design model, CORBA provides the means to level the field and allow disparate teams to develop systems and unit tests that can later be joined into a whole system. This does not rule out the need for basic system engineering decisions, such as threading, timing, object lifetime, etc. These issues are part of any system regardless of technology. CORBA allows system elements to be normalized into a single cohesive system model.

For example, the design of a multitier architecture is made simple using Java Servlets in the web server and various CORBA servers containing the business logic and wrapping the database accesses. This allows the implementations of the business logic to change, while the interface changes would need to be handled as in any other technology. For example, a database wrapped by a server can have its database schema change for the sake of improved disk usage or performance (or even whole-scale database vendor change), without affecting the external interfaces. At the same time, C++ legacy code can talk to C/Fortran legacy code and Java database code, and can provide data to a web interface.

Data-typing [ edit ] CORBA provides flexible data typing, for example an "ANY" datatype. CORBA also enforces tightly coupled data typing, reducing human errors. In a situation where Name-Value pairs are passed around, it is conceivable that a server provides a number where a string was expected. CORBA Interface Definition Language provides the mechanism to ensure that user-code conforms to method-names, return-, parameter-types, and exceptions.

High tunability [ edit ] Many implementations (e.g. ORBexpress (Ada, C++, and Java implementation) [ 11 ] and OmniORB (open source C++ and Python implementation)) [ 12 ] have options for tuning the threading and connection management features. Not all ORB implementations provide the same features.

Freedom from data-transfer details [ edit ] When handling low-level connection and threading, CORBA provides a high level of detail in error conditions. This is defined in the CORBA-defined standard exception set and the implementation-specific extended exception set. Through the exceptions, the application can determine if a call failed for reasons such as "Small problem, so try again", "The server is dead", or "The reference does not make sense." The general rule is: Not receiving an exception means that the method call completed successfully. This is a very powerful design feature.

Compression [ edit ] CORBA marshals its data in a binary form and supports compression. IONA, Remedy IT, and Telefónica have worked on an extension to the CORBA standard that delivers compression. This extension is called ZIOP and this is now a formal OMG standard.

Problems and criticism [ edit ] While CORBA delivered much in the way code was written and software constructed, it has been the subject of criticism.

[ 13 ] Much of the criticism of CORBA stems from poor implementations of the standard and not deficiencies of the standard itself. Some of the failures of the standard itself were due to the process by which the CORBA specification was created and the compromises inherent in the politics and business of writing a common standard sourced by many competing implementors.

Initial implementation incompatibilities [ edit ] The initial specifications of CORBA defined only the IDL, not the on-the-wire format. This meant that source-code compatibility was the best that was available for several years. With CORBA 2 and later this issue was resolved.

Location transparency [ edit ] CORBA's notion of location transparency has been criticized; that is, that objects residing in the same address space and accessible with a simple function call are treated the same as objects residing elsewhere (different processes on the same machine, or different machines). This is a fundamental design flaw, [ 14 ] [ failed verification ] as it makes all object access as complex as the most complex case (i.e., remote network call with a wide class of failures that are not possible in local calls). It also hides the inescapable differences between the two classes, making it impossible for applications to select an appropriate use strategy (that is, a call with 1 μs latency and guaranteed return will be used very differently from a call with 1 s latency with possible transport failure, in which the delivery status is potentially unknown and might take 30 s to time out).

Design and process deficiencies [ edit ] The creation of the CORBA standard is also often cited for its process of design by committee . There was no process to arbitrate between conflicting proposals or to decide on the hierarchy of problems to tackle. Thus the standard was created by taking a union of the features in all proposals with no regard to their coherence.

[ 15 ] This made the specification complex, expensive to implement entirely, and often ambiguous.

A design committee composed of a mixture of implementation vendors and customers created a diverse set of interests. This diversity made difficult a cohesive standard. Standards and interoperability increased competition and eased customers' movement between alternative implementations. This led to much political fighting within the committee and frequent releases of revisions of the CORBA standard that some ORB implementors ensured were difficult to use without proprietary extensions.

[ 13 ] Less ethical CORBA vendors encouraged customer lock-in and achieved strong short-term results. Over time the ORB vendors that encourage portability took over market share.

[ citation needed ] Problems with implementations [ edit ] Through its history, CORBA has been plagued by shortcomings in poor ORB implementations. Unfortunately many of the papers criticizing CORBA as a standard are simply criticisms of a particularly bad CORBA ORB implementation.

CORBA is a comprehensive standard with many features. Few implementations attempt to implement all of the specifications, [ 15 ] and initial implementations were incomplete or inadequate. As there were no requirements to provide a reference implementation, members were free to propose features which were never tested for usefulness or implementability. Implementations were further hindered by the general tendency of the standard to be verbose, and the common practice of compromising by adopting the sum of all submitted proposals, which often created APIs that were incoherent and difficult to use, even if the individual proposals were perfectly reasonable.

[ citation needed ] Robust implementations of CORBA have been very difficult to acquire in the past, but are now much easier to find. The SUN Java SDK comes with CORBA built-in. Some poorly designed implementations have been found to be complex, slow, incompatible, and incomplete. Robust commercial versions began to appear but for significant cost. As good quality free implementations became available the bad commercial implementations died quickly.

Firewalls [ edit ] CORBA (more precisely, GIOP ) is not tied to any particular communications transport. A specialization of GIOP is the Internet Inter-ORB Protocol or IIOP. IIOP uses raw TCP/IP connections in order to transmit data.

If the client is behind a very restrictive firewall or transparent proxy server environment that only allows HTTP connections to the outside through port 80, communication may be impossible, unless the proxy server in question allows the HTTP CONNECT method or SOCKS connections as well. At one time, it was difficult even to force implementations to use a single standard port – they tended to pick multiple random ports instead. As of today, current ORBs do have these deficiencies. Due to such difficulties, some users have made increasing use of web services instead of CORBA. These communicate using XML / SOAP via port 80, which is normally left open or filtered through a HTTP proxy inside the organization, for web browsing via HTTP. Recent CORBA implementations, though, support SSL and can be easily configured to work on a single port. Some ORBS, such as TAO , omniORB, and JacORB also support bidirectional GIOP, which gives CORBA the advantage of being able to use callback communication rather than the polling approach characteristic of web service implementations. Also, most modern firewalls support GIOP & IIOP and are thus CORBA-friendly firewalls.

See also [ edit ] This " see also " section may contain an excessive number of entries . Please ensure that only the most relevant links are given, that they are not red links , and that any links are not already in this article.

( July 2025 ) ( Learn how and when to remove this message ) Software engineering [ edit ] Component-based software engineering – Engineering focused on building software from reusable components Distributed computing – System with multiple networked computers Portable object – Object in distributed programming Service-oriented architecture – Architectural pattern in software design (SOA) Network socket – Software-based endpoint of network communications Component-based software technologies [ edit ] Common Language Infrastructure – Open specification for runtime environments Component Object Model – Software component technology from Microsoft (COM) Distributed Component Object Model – Software for communication between software components (Distributed COM/DCOM) D-Bus – Linux message-oriented middleware Bonobo (GNOME) – Obsolete component framework for the GNOME free desktop environment IBM System Object Model – Programming framework SOM and DSOM – component systems from IBM used in OS/2 and AIX Internet Communications Engine – Framework for remote procedure calls (ICE) Java Platform, Enterprise Edition – Set of specifications extending Java SE Pages displaying short descriptions of redirect targets (Java EE) Java remote method invocation – Java application-programming interface (Java RMI) JavaBean – Computing technology developer by Sun Microsystems Pages displaying short descriptions of redirect targets KDE – Free software community Desktop communication protocol (DCOP) - deprecated KParts – KDE component framework OpenAIR – Aspect of system integration regarding artificial intelligence Pages displaying short descriptions of redirect targets Remote procedure call – Mechanism to allow software to execute a remote procedure (RPC) XML-RPC – Data serialization format Software Communications Architecture – Open architecture framework for software-defined radio (SCA) Windows Communication Foundation – Software framework (WCF) XPCOM – Component model (Cross Platform Component Object Model) – developed by Mozilla for applications based on it (e.g.

Mozilla Application Suite , SeaMonkey 1.x) SOAP – Messaging protocol for web services Internet Communications Engine – Framework for remote procedure calls Language bindings [ edit ] Application binary interface – Interface to software defined in terms of in-process, machine code access - ABI Application programming interface – Connection between computers or programs Pages displaying short descriptions of redirect targets - API Calling convention – Mechanism of function calls in computers Comparison of application virtual machines Dynamic Invocation Interface Foreign function interface – Interface to call functions from other programming languages Language binding – Software library that allows using another library coded in another programming language Name mangling – Technique in compiler construction SWIG – Open-source programming tool References [ edit ] "CORBA" .

Current . Specification.

OMG .

^ The Rise and Fall of CORBA ^ "History of CORBA" .

Object Management Group . Retrieved 12 March 2017 .

^ "History of CORBA" .

Object Management Group . Retrieved 4 June 2017 .

^ "OMG IDL Corba Version" .

Object Management Group . Retrieved 4 December 2023 .

^ "The CORBA Component Model" .

Dr. Dobb's Journal . 1 September 2004 . Retrieved 13 March 2017 .

^ see Section 3.17.1, "Standard Exception Definitions", on page 3-52 and Section 3.17.2, "Standard Minor Exception Codes", on page 3-58.

^ Vendors may request allocation of VMCIDs by sending email to tagrequest omg.org .

^ A list of currently assigned VMCIDs can be found on the OMG website at: https://www.omg.org/cgi-bin/doc?vendor-tags ^ Section 3.17.1, "Standard Exception Definitions", on page 3-52 ^ The Common Object Request Broker: Architecture and Specification (CORBA 2.3) ^ "ORBexpress: An Overview" .

^ "omniORB: Free CORBA ORB" . Retrieved 10 October 2024 .

^ a b Chappel, David (May 1998).

"Trouble with CORBA" . davidchappel.com.

Archived from the original on 3 December 2012 . Retrieved 10 October 2024 .

^ Waldo, Jim; Geoff Wyant; Ann Wollrath; Sam Kendall (November 1994).

"A Note on Distributed Computing" (PDF) .

Sun Microsystem Laboratories .

Archived (PDF) from the original on 10 October 2022 . Retrieved 10 October 2024 .

^ a b Henning, Michi (30 June 2006).

"The Rise and Fall of CORBA" .

ACM Queue .

4 (5).

Association for Computing Machinery : 28– 34.

doi : 10.1145/1142031.1142044 .

S2CID 12103742 .

Further reading [ edit ] Bolton, Fintan (2001).

Pure Corba . Sams Publishing.

ISBN 0-672-31812-1 .

Brose, Gerald; Vogel, Andreas; Duddy, Keith (25 January 2001).

Java Programming with CORBA . John Wiley & Sons.

ISBN 0-471-37681-7 .

Harmon, Paul ; Morrissey, William (1996).

The Object Technology Casebook . John Wiley & Sons.

ISBN 0-471-14717-6 .

Hartman, Bret; Beznosov, hartman; Vinoski, Steve; Flinn, Donald (20 April 2001).

Enterprise Security with EJB and CORBA . John Wiley & Sons.

ISBN 0-471-40131-5 .

Henning, Michi; Vinoski, Steve (1999).

Advanced CORBA Programming with C++ . Addison-Wesley.

ISBN 0-201-37927-9 .

Korthaus, Axel; Schader, Martin; Aleksy, Markus (22 June 2005).

Implementing Distributed Systems with Java and CORBA . Springer.

ISBN 3-540-24173-6 . Archived from the original on 31 October 2005 . Retrieved 23 June 2005 .

Mowbray, Thomas J.; Malveau, Raphael C. (1997).

CORBA Design Patterns . John Wiley & Sons.

ISBN 0-471-15882-8 .

Mowbray, Thomas J.; Zahavi, Ron (1995).

The Essential Corba: System Integration Using Distributed Objects . John Wiley & Sons.

ISBN 0-471-10611-9 .

Orfali, Robert (1996).

The Essential Client/Server Survival Guide . John Wiley & Sons.

ISBN 0-471-15325-7 .

Orfali, Robert; Harkey, Dan; Edwards, Jeri (1997).

Instant CORBA . John Wiley & Sons.

ISBN 0-471-18333-4 .

Orfali, Robert; Harkey, Dan; Edwards, Jeri (1996).

The Essential Distributed Objects Survival Guide . John Wiley & Sons.

ISBN 0-471-12993-3 .

Orfali, Robert; Harkey, Dan (1998).

Client/Server Programming with JAVA and CORBA . John Wiley & Sons.

ISBN 0-471-24578-X .

Rosen, Michael ; Curtis, David (13 October 1998).

Integrating CORBA and COM Applications . John Wiley & Sons.

ISBN 0-471-19827-7 .

Rosenberger, Jeremy L. (1998).

Teach Yourself CORBA in 14 Days . Sams Publishing.

ISBN 0-672-31208-5 .

Schettino, John; Hohman, Robin S.; O'Hara, Liz (1998).

CORBA For Dummies . Hungry Minds.

ISBN 0-7645-0308-1 .

Siegel, Jon (27 April 2000).

CORBA 3 - Fundamentals and Programming . John Wiley & Sons.

ISBN 0-471-29518-3 .

Siegel, Jon (7 May 2001).

Quick CORBA 3 . John Wiley & Sons.

ISBN 0-471-38935-8 .

Slama, Dirk; Garbis, Jason; Russell, Perry (1999).

Enterprise CORBA . Prentice Hall.

ISBN 0-13-083963-9 .

Zahavi, Ron (2000).

Enterprise Application Integration with CORBA: Component and Web-Based Solutions . John Wiley & Sons.

ISBN 0-471-32720-4 .

External links [ edit ] Wikibooks has a book on the topic of: CORBA Programming Official OMG CORBA Components page Unofficial CORBA Component Model page Comparing IDL to C++ with IDL to C++11 CORBA: Gone But (Hopefully) Not Forgotten OMG XMI Specification v t e International Organization for Standardization (ISO) standards List of ISO standards – ISO romanizations – IEC standards 1–9999 1 2 3 4 6 7 9 16 17 31 -0 -1 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 68-1 128 216 217 226 228 233 259 261 262 302 306 361 500 518 519 639 -1 -2 -3 -5 -6 646 657 668 690 704 732 764 838 843 860 898 965 999 1000 1004 1007 1073-1 1073-2 1155 1413 1538 1629 1745 1989 2014 2015 2022 2033 2047 2108 2145 2146 2240 2281 2533 2709 2711 2720 2788 2848 2852 2921 3029 3103 3166 -1 -2 -3 3297 3307 3601 3602 3864 3901 3950 3977 4031 4157 4165 4217 4909 5218 5426 5427 5428 5725 5775 5776 5800 5807 5964 6166 6344 6346 6373 6385 6425 6429 6438 6523 6709 6943 7001 7002 7010 7027 7064 7098 7185 7200 7498 -1 7637 7736 7810 7811 7812 7813 7816 7942 8000 8093 8178 8217 8373 8501-1 8571 8583 8601 8613 8632 8651 8652 8691 8805/8806 8807 8820-5 8859 -1 -2 -3 -4 -5 -6 -7 -8 -8-I -9 -10 -11 -12 -13 -14 -15 -16 8879 9000/9001 9036 9075 9126 9141 9227 9241 9293 9314 9362 9407 9496 9506 9529 9564 9592/9593 9594 9660 9797-1 9897 9899 9945 9984 9985 9995 10000–19999 10006 10007 10116 10118-3 10160 10161 10165 10179 10206 10218 10279 10303 -11 -21 -22 -28 -238 10383 10585 10589 10628 10646 10664 10746 10861 10957 10962 10967 11073 11170 11172 11179 11404 11544 11783 11784 11785 11801 11889 11898 11940 ( -2 ) 11941 11941 (TR) 11992 12006 12052 12182 12207 12234-2 12620 13211 -1 -2 13216 13250 13399 13406-2 13450 13485 13490 13567 13568 13584 13616 13816 13818 14000 14031 14224 14289 14396 14443 14496 -2 -3 -6 -10 -11 -12 -14 -17 -20 14617 14644 14649 14651 14698 14764 14882 14971 15022 15189 15288 15291 15398 15408 15444 -3 -9 15445 15438 15504 15511 15686 15693 15706 -2 15707 15897 15919 15924 15926 15926 WIP 15930 15938 16023 16262 16355-1 16485 16612-2 16750 16949 (TS) 17024 17025 17100 17203 17369 17442 17506 17799 18004 18014 18181 18245 18629 18760 18916 19005 19011 19092 -1 -2 19114 19115 19125 19136 19407 19439 19500 19501 19502 19503 19505 19506 19507 19508 19509 19510 19600 19752 19757 19770 19775-1 19794-5 19831 20000–29999 20000 20022 20121 20400 20802 20830 21000 21001 21047 21122 21500 21778 21827 22000 22275 22300 22301 22395 22537 23000 23003 23008 23009 23090-3 23092 23094-1 23094-2 23270 23271 23360 23941 24517 24613 24617 24707 24728 25178 25964 26000 26262 26300 26324 27000 series 27000 27001 27002 27005 27006 27729 28000 29110 29148 29199-2 29500 30000+ 30170 31000 32000 37001 38500 39075 40314 40500 42010 45001 50001 55000 56000 80000 Category Authority control databases National Germany United States Latvia Israel Other Yale LUX NewPP limit report
Parsed by mw‐web.codfw.main‐7c956d68b4‐5n66l
Cached time: 20250818045828
Cache expiry: 1191706
Reduced expiry: true
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.898 seconds
Real time usage: 1.156 seconds
Preprocessor visited node count: 8850/1000000
Revision size: 36809/2097152 bytes
Post‐expand include size: 156398/2097152 bytes
Template argument size: 14738/2097152 bytes
Highest expansion depth: 20/100
Expensive parser function count: 10/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 111521/5000000 bytes
Lua time usage: 0.546/10.000 seconds
Lua memory usage: 23004362/52428800 bytes
Number of Wikibase entities loaded: 1/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  996.784      1 -total
 27.48%  273.948     34 Template:Annotated_link
 10.08%  100.525     19 Template:Cite_book
  9.65%   96.196      8 Template:Cite_web
  7.48%   74.593      1 Template:ISO_standards
  7.28%   72.536      1 Template:Navbox
  6.52%   64.990      1 Template:Reflist
  6.43%   64.077      1 Template:Multiple_issues
  6.24%   62.165      1 Template:Short_description
  5.27%   52.566      1 Template:Infobox_technology_standard Saved in parser cache with key enwiki:pcache:43285:|#|:idhash:canonical and timestamp 20250818045828 and revision id 1302941659. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Common_Object_Request_Broker_Architecture&oldid=1302941659 " Categories : Common Object Request Broker Architecture Component-based software engineering GNOME Inter-process communication ISO standards Object-oriented programming Hidden categories: Articles with short description Short description matches Wikidata Articles lacking in-text citations from February 2009 All articles lacking in-text citations Articles needing cleanup from April 2023 All pages needing cleanup Articles containing how-to sections Articles with incomplete citations from July 2025 All articles with incomplete citations Articles with multiple maintenance issues Use dmy dates from December 2019 All articles with failed verification Articles with failed verification from November 2017 All articles with unsourced statements Articles with unsourced statements from November 2017 Articles with unsourced statements from February 2007 Articles with excessive see also sections from July 2025 All articles with excessive see also sections Pages displaying short descriptions of redirect targets via Module:Annotated link This page was last edited on 28 July 2025, at 06:58 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Common Object Request Broker Architecture 27 languages Add topic

