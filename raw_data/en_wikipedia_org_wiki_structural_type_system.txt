Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Description 2 Example 3 References 4 External links Toggle the table of contents Structural type system 2 languages Français Українська Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Class of type systems This article needs additional citations for verification .

Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed.

Find sources: "Structural type system" – news · newspapers · books · scholar · JSTOR ( July 2011 ) ( Learn how and when to remove this message ) Type systems General concepts Type safety Strong vs. weak typing Major categories Static vs.

dynamic Manifest vs.

inferred Nominal vs.

structural Duck typing Minor categories Abstract Dependent Flow-sensitive Gradual Intersection Latent Refinement Substructural Unique Session v t e A structural type system (or property-based type system ) is a major class of type systems in which type compatibility and equivalence are determined by the type's actual structure or definition and not by other characteristics such as its name or place of declaration. Structural systems are used to determine if types are equivalent and whether a type is a subtype of another. It contrasts with nominative systems , where comparisons are based on the names of the types or explicit declarations, and duck typing , in which only the part of the structure accessed at runtime is checked for compatibility.

Description [ edit ] In structural typing , an element is considered to be compatible with another if, for each feature within the second element's type, a corresponding and identical feature exists in the first element's type.  Some languages may differ on the details, such as whether the features must match in name. This definition is not symmetric, and includes subtype compatibility. Two types are considered to be identical if each is compatible with the other.

For example, OCaml uses structural typing on methods for compatibility of object types.

Go uses structural typing on methods to determine compatibility of a type with an interface.

C++ template functions exhibit structural typing on type arguments.

Haxe uses structural typing, but classes are not structurally subtyped.

In languages which support subtype polymorphism , a similar dichotomy can be formed based on how the subtype relationship is defined.  One type is a subtype of another if and only if it contains all the features of the base type, or subtypes thereof. The subtype may contain added features, such as members not present in the base type, or stronger invariants.

A distinction exists between structural substitution for inferred and non-inferred polymorphism. Some languages, such as Haskell , do not substitute structurally in the case where an expected type is declared (i.e., not inferred), e.g., only substitute for functions that are signature-based polymorphic via type inference.

[ 1 ] Then it is not possible to accidentally subtype a non-inferred type, although it may still be possible to provide an explicit conversion to a non-inferred type, which is invoked implicitly.

Structural subtyping is arguably more flexible than nominative subtyping , as it permits the creation of ad hoc types and protocols ; in particular, it permits creation of a type which is a supertype of an existing type, without modifying the definition of the latter. However, this may not be desirable where the programmer wishes to create closed abstractions.

A pitfall of structural typing versus nominative typing is that two separately defined types intended for different purposes, but accidentally holding the same properties (e.g. both composed of a pair of integers), could be considered the same type by the type system, simply because they happen to have identical structure. One way this can be avoided is by creating one algebraic data type for each use.

In 1990, Cook, et al., proved that inheritance is not subtyping in structurally-typed OO languages.

[ 2 ] Checking that two types are compatible, based on structural typing, is a non-trivial operation, e.g., requires maintaining a stack of previous checked types.

[ 3 ] When a type does not match the expected structure, error messages are longer than with nominal typing .

Example [ edit ] Objects in OCaml are structurally typed by the names and types of their methods.

Objects can be created directly ( immediate objects ) without going through a nominative class. Classes only serve as functions for creating objects.

# let x = object val mutable x = 5 method get_x = x method set_x y = x <- y end ;; val x : < get_x : int ; set_x : int -> unit > = < obj > Here the OCaml interactive runtime prints out the inferred type of the object for convenience. Its type ( < get_x : int; set_x : int -> unit > ) is defined only by its methods. In other words, the type of x is defined by the method types "get_x : int" and "set_x : int -> unit" rather than by any name.

[ 4 ] To define another object, which has the same methods and types of methods: # let y = object method get_x = 2 method set_x y = Printf .

printf "%d \n " y end ;; val y : < get_x : int ; set_x : int -> unit > = < obj > OCaml considers them the same type. For example, the equality operator is typed to only take two values of the same type: # x = y ;; - : bool = false So they must be the same type, or else this wouldn't even type-check. This shows that equivalence of types is structural.

One can define a function that invokes a method: # let set_to_10 a = a # set_x 10 ;; val set_to_10 : < set_x : int -> ' a ; ..

> -> ' a = < fun > The inferred type for the first argument ( < set_x : int -> 'a; .. > ) is interesting. The ..

means that the first argument can be any object which has a "set_x" method, which takes an int as argument.

So it can be used on object x : # set_to_10 x ;; - : unit = () Another object can be made that happens to have that method and method type; the other methods are irrelevant: # let z = object method blahblah = 2 .

5 method set_x y = Printf .

printf "%d \n " y end ;; val z : < blahblah : float ; set_x : int -> unit > = < obj > The "set_to_10" function also works on it: # set_to_10 z ;; 10 - : unit = () This shows that compatibility for things like method invocation is determined by structure.

Let us define a type synonym for objects with only a "get_x" method and no other methods: # type simpler_obj = < get_x : int >;; type simpler_obj = < get_x : int > The object x is not of this type; but structurally, x is of a subtype of this type, since x contains a superset of its methods. So x can be coerced to this type: # ( x :> simpler_obj );; - : simpler_obj = < obj > # ( x :> simpler_obj )# get_x ;; - : int = 10 But not object z , because it is not a structural subtype: # (z :> simpler_obj);;
This expression cannot be coerced to type simpler_obj = < get_x : int >;
it has type < blahblah : float; set_x : int -> unit > but is here used with type
  < get_x : int; .. >
The first object type has no method get_x This shows that compatibility for widening coercions are structural.

References [ edit ] ^ "Signature-based polymorphism" .

^ Cook, W.R.; Hill, W.L.; Canning, P.S. (January 1990). "Inheritance is not subtyping".

Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on Principles of programming languages - POPL '90 . San Francisco, California. pp.

125– 135.

doi : 10.1145/96709.96721 .

ISBN 978-0897913430 .

S2CID 8225906 .

{{ cite book }} :  CS1 maint: location missing publisher ( link ) ^ "Type compatibility: name vs structural equivalence" .

^ "Object types" .

Pierce, Benjamin C. (2002). "19.3".

Types and Programming Languages . MIT Press.

ISBN 978-0-262-16209-8 .

External links [ edit ] NominativeAndStructuralTyping at WikiWikiWeb Retrieved from " https://en.wikipedia.org/w/index.php?title=Structural_type_system&oldid=1258358331 " Category : Type systems Hidden categories: CS1 maint: location missing publisher Articles with short description Short description is different from Wikidata Articles needing additional references from July 2011 All articles needing additional references This page was last edited on 19 November 2024, at 07:04 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Structural type system 2 languages Add topic

