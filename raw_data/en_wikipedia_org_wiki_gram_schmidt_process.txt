Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 The Gram–Schmidt process 2 Example Toggle Example subsection 2.1 Euclidean space 3 Properties 4 Numerical stability 5 Algorithm 6 Via Gaussian elimination 7 Determinant formula 8 Expressed using geometric algebra 9 Alternatives 10 Run-time complexity 11 See also 12 References 13 Notes 14 Sources 15 External links Toggle the table of contents Gram–Schmidt process 36 languages Bosanski Català Čeština Dansk Deutsch Ελληνικά Español فارسی Français Galego 한국어 Hrvatski Íslenska Italiano עברית Magyar Nederlands 日本語 Norsk nynorsk Polski Português Română Русский Shqip Simple English Slovenčina Српски / srpski Srpskohrvatski / српскохрватски Suomi Svenska Türkçe Українська اردو Tiếng Việt 粵語 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Orthonormalization of a set of vectors The first two steps of the Gram–Schmidt process In mathematics , particularly linear algebra and numerical analysis , the Gram–Schmidt process or Gram-Schmidt algorithm is a way of finding a set of two or more vectors that are perpendicular to each other.

By technical definition, it is a method of constructing an orthonormal basis from a set of vectors in an inner product space , most commonly the Euclidean space R n {\displaystyle \mathbb {R} ^{n}} equipped with the standard inner product . The Gram–Schmidt process takes a finite , linearly independent set of vectors S = { v 1 , … … , v k } {\displaystyle S=\{\mathbf {v} _{1},\ldots ,\mathbf {v} _{k}\}} for k ≤ n and generates an orthogonal set S ′ = { u 1 , … … , u k } {\displaystyle S'=\{\mathbf {u} _{1},\ldots ,\mathbf {u} _{k}\}} that spans the same k {\displaystyle k} -dimensional subspace of R n {\displaystyle \mathbb {R} ^{n}} as S {\displaystyle S} .

The method is named after Jørgen Pedersen Gram and Erhard Schmidt , but Pierre-Simon Laplace had been familiar with it before Gram and Schmidt.

[ 1 ] In the theory of Lie group decompositions , it is generalized by the Iwasawa decomposition .

The application of the Gram–Schmidt process to the column vectors of a full column rank matrix yields the QR decomposition (it is decomposed into an orthogonal and a triangular matrix ).

The Gram–Schmidt process [ edit ] The modified Gram-Schmidt process being executed on three linearly independent, non-orthogonal vectors of a basis for R 3 {\displaystyle \mathbb {R} ^{3}} . Click on image for details. Modification is explained in the Numerical Stability section of this article.

The vector projection of a vector v {\displaystyle \mathbf {v} } on a nonzero vector u {\displaystyle \mathbf {u} } is defined as [ note 1 ] proj u ⁡ ⁡ ( v ) = ⟨ ⟨ v , u ⟩ ⟩ ⟨ ⟨ u , u ⟩ ⟩ u , {\displaystyle \operatorname {proj} _{\mathbf {u} }(\mathbf {v} )={\frac {\langle \mathbf {v} ,\mathbf {u} \rangle }{\langle \mathbf {u} ,\mathbf {u} \rangle }}\,\mathbf {u} ,} where ⟨ ⟨ v , u ⟩ ⟩ {\displaystyle \langle \mathbf {v} ,\mathbf {u} \rangle } denotes the dot product of the vectors u {\displaystyle \mathbf {u} } and v {\displaystyle \mathbf {v} } . This means that proj u ⁡ ⁡ ( v ) {\displaystyle \operatorname {proj} _{\mathbf {u} }(\mathbf {v} )} is the orthogonal projection of v {\displaystyle \mathbf {v} } onto the line spanned by u {\displaystyle \mathbf {u} } . If u {\displaystyle \mathbf {u} } is the zero vector, then proj u ⁡ ⁡ ( v ) {\displaystyle \operatorname {proj} _{\mathbf {u} }(\mathbf {v} )} is defined as the zero vector.

Given k {\displaystyle k} nonzero linearly-independent vectors v 1 , … … , v k {\displaystyle \mathbf {v} _{1},\ldots ,\mathbf {v} _{k}} the Gram–Schmidt process defines the vectors u 1 , … … , u k {\displaystyle \mathbf {u} _{1},\ldots ,\mathbf {u} _{k}} as follows: u 1 = v 1 , e 1 = u 1 ‖ ‖ u 1 ‖ ‖ u 2 = v 2 − − proj u 1 ⁡ ⁡ ( v 2 ) , e 2 = u 2 ‖ ‖ u 2 ‖ ‖ u 3 = v 3 − − proj u 1 ⁡ ⁡ ( v 3 ) − − proj u 2 ⁡ ⁡ ( v 3 ) , e 3 = u 3 ‖ ‖ u 3 ‖ ‖ u 4 = v 4 − − proj u 1 ⁡ ⁡ ( v 4 ) − − proj u 2 ⁡ ⁡ ( v 4 ) − − proj u 3 ⁡ ⁡ ( v 4 ) , e 4 = u 4 ‖ ‖ u 4 ‖ ‖ ⋮ ⋮ ⋮ ⋮ u k = v k − − ∑ ∑ j = 1 k − − 1 proj u j ⁡ ⁡ ( v k ) , e k = u k ‖ ‖ u k ‖ ‖ .

{\displaystyle {\begin{aligned}\mathbf {u} _{1}&=\mathbf {v} _{1},&\!\mathbf {e} _{1}&={\frac {\mathbf {u} _{1}}{\|\mathbf {u} _{1}\|}}\\\mathbf {u} _{2}&=\mathbf {v} _{2}-\operatorname {proj} _{\mathbf {u} _{1}}(\mathbf {v} _{2}),&\!\mathbf {e} _{2}&={\frac {\mathbf {u} _{2}}{\|\mathbf {u} _{2}\|}}\\\mathbf {u} _{3}&=\mathbf {v} _{3}-\operatorname {proj} _{\mathbf {u} _{1}}(\mathbf {v} _{3})-\operatorname {proj} _{\mathbf {u} _{2}}(\mathbf {v} _{3}),&\!\mathbf {e} _{3}&={\frac {\mathbf {u} _{3}}{\|\mathbf {u} _{3}\|}}\\\mathbf {u} _{4}&=\mathbf {v} _{4}-\operatorname {proj} _{\mathbf {u} _{1}}(\mathbf {v} _{4})-\operatorname {proj} _{\mathbf {u} _{2}}(\mathbf {v} _{4})-\operatorname {proj} _{\mathbf {u} _{3}}(\mathbf {v} _{4}),&\!\mathbf {e} _{4}&={\mathbf {u} _{4} \over \|\mathbf {u} _{4}\|}\\&{}\ \ \vdots &&{}\ \ \vdots \\\mathbf {u} _{k}&=\mathbf {v} _{k}-\sum _{j=1}^{k-1}\operatorname {proj} _{\mathbf {u} _{j}}(\mathbf {v} _{k}),&\!\mathbf {e} _{k}&={\frac {\mathbf {u} _{k}}{\|\mathbf {u} _{k}\|}}.\end{aligned}}} The sequence u 1 , … … , u k {\displaystyle \mathbf {u} _{1},\ldots ,\mathbf {u} _{k}} is the required system of orthogonal vectors, and the normalized vectors e 1 , … … , e k {\displaystyle \mathbf {e} _{1},\ldots ,\mathbf {e} _{k}} form an orthonormal set . The calculation of the sequence u 1 , … … , u k {\displaystyle \mathbf {u} _{1},\ldots ,\mathbf {u} _{k}} is known as Gram–Schmidt orthogonalization , and the calculation of the sequence e 1 , … … , e k {\displaystyle \mathbf {e} _{1},\ldots ,\mathbf {e} _{k}} is known as Gram–Schmidt orthonormalization .

To check that these formulas yield an orthogonal sequence, first compute ⟨ ⟨ u 1 , u 2 ⟩ ⟩ {\displaystyle \langle \mathbf {u} _{1},\mathbf {u} _{2}\rangle } by substituting the above formula for u 2 {\displaystyle \mathbf {u} _{2}} : we get zero. Then use this to compute ⟨ ⟨ u 1 , u 3 ⟩ ⟩ {\displaystyle \langle \mathbf {u} _{1},\mathbf {u} _{3}\rangle } again by substituting the formula for u 3 {\displaystyle \mathbf {u} _{3}} : we get zero. For arbitrary k {\displaystyle k} the proof is accomplished by mathematical induction .

Geometrically, this method proceeds as follows: to compute u i {\displaystyle \mathbf {u} _{i}} , it projects v i {\displaystyle \mathbf {v} _{i}} orthogonally onto the subspace U {\displaystyle U} generated by u 1 , … … , u i − − 1 {\displaystyle \mathbf {u} _{1},\ldots ,\mathbf {u} _{i-1}} , which is the same as the subspace generated by v 1 , … … , v i − − 1 {\displaystyle \mathbf {v} _{1},\ldots ,\mathbf {v} _{i-1}} . The vector u i {\displaystyle \mathbf {u} _{i}} is then defined to be the difference between v i {\displaystyle \mathbf {v} _{i}} and this projection, guaranteed to be orthogonal to all of the vectors in the subspace U {\displaystyle U} .

The Gram–Schmidt process also applies to a linearly independent countably infinite sequence { v i } i . The result is an orthogonal (or orthonormal) sequence { u i } i such that for natural number n : the algebraic span of v 1 , … … , v n {\displaystyle \mathbf {v} _{1},\ldots ,\mathbf {v} _{n}} is the same as that of u 1 , … … , u n {\displaystyle \mathbf {u} _{1},\ldots ,\mathbf {u} _{n}} .

If the Gram–Schmidt process is applied to a linearly dependent sequence, it outputs the 0 vector on the i {\displaystyle i} th step, assuming that v i {\displaystyle \mathbf {v} _{i}} is a linear combination of v 1 , … … , v i − − 1 {\displaystyle \mathbf {v} _{1},\ldots ,\mathbf {v} _{i-1}} . If an orthonormal basis is to be produced, then the algorithm should test for zero vectors in the output and discard them because no multiple of a zero vector can have a length of 1. The number of vectors output by the algorithm will then be the dimension of the space spanned by the original inputs.

A variant of the Gram–Schmidt process using transfinite recursion applied to a (possibly uncountably) infinite sequence of vectors ( v α α ) α α < λ λ {\displaystyle (v_{\alpha })_{\alpha <\lambda }} yields a set of orthonormal vectors ( u α α ) α α < κ κ {\displaystyle (u_{\alpha })_{\alpha <\kappa }} with κ κ ≤ ≤ λ λ {\displaystyle \kappa \leq \lambda } such that for any α α ≤ ≤ λ λ {\displaystyle \alpha \leq \lambda } , the completion of the span of { u β β : β β < min ( α α , κ κ ) } {\displaystyle \{u_{\beta }:\beta <\min(\alpha ,\kappa )\}} is the same as that of { v β β : β β < α α } {\displaystyle \{v_{\beta }:\beta <\alpha \}} .

In particular, when applied to a (algebraic) basis of a Hilbert space (or, more generally, a basis of any dense subspace), it yields a (functional-analytic) orthonormal basis. Note that in the general case often the strict inequality κ κ < λ λ {\displaystyle \kappa <\lambda } holds, even if the starting set was linearly independent, and the span of ( u α α ) α α < κ κ {\displaystyle (u_{\alpha })_{\alpha <\kappa }} need not be a subspace of the span of ( v α α ) α α < λ λ {\displaystyle (v_{\alpha })_{\alpha <\lambda }} (rather, it's a subspace of its completion).

Example [ edit ] Euclidean space [ edit ] Consider the following set of vectors in R 2 {\displaystyle \mathbb {R} ^{2}} (with the conventional inner product ) S = { v 1 = [ 3 1 ] , v 2 = [ 2 2 ] } .

{\displaystyle S=\left\{\mathbf {v} _{1}={\begin{bmatrix}3\\1\end{bmatrix}},\mathbf {v} _{2}={\begin{bmatrix}2\\2\end{bmatrix}}\right\}.} Now, perform Gram–Schmidt, to obtain an orthogonal set of vectors: u 1 = v 1 = [ 3 1 ] {\displaystyle \mathbf {u} _{1}=\mathbf {v} _{1}={\begin{bmatrix}3\\1\end{bmatrix}}} u 2 = v 2 − − proj u 1 ⁡ ⁡ ( v 2 ) = [ 2 2 ] − − proj [ 3 1 ] ⁡ ⁡ [ 2 2 ] = [ 2 2 ] − − 8 10 [ 3 1 ] = [ − − 2 / 5 6 / 5 ] .

{\displaystyle \mathbf {u} _{2}=\mathbf {v} _{2}-\operatorname {proj} _{\mathbf {u} _{1}}(\mathbf {v} _{2})={\begin{bmatrix}2\\2\end{bmatrix}}-\operatorname {proj} _{\left[{\begin{smallmatrix}3\\1\end{smallmatrix}}\right]}{\begin{bmatrix}2\\2\end{bmatrix}}={\begin{bmatrix}2\\2\end{bmatrix}}-{\frac {8}{10}}{\begin{bmatrix}3\\1\end{bmatrix}}={\begin{bmatrix}-2/5\\6/5\end{bmatrix}}.} We check that the vectors u 1 {\displaystyle \mathbf {u} _{1}} and u 2 {\displaystyle \mathbf {u} _{2}} are indeed orthogonal: ⟨ ⟨ u 1 , u 2 ⟩ ⟩ = ⟨ [ 3 1 ] , [ − − 2 / 5 6 / 5 ] ⟩ = − − 6 5 + 6 5 = 0 , {\displaystyle \langle \mathbf {u} _{1},\mathbf {u} _{2}\rangle =\left\langle {\begin{bmatrix}3\\1\end{bmatrix}},{\begin{bmatrix}-2/5\\6/5\end{bmatrix}}\right\rangle =-{\frac {6}{5}}+{\frac {6}{5}}=0,} noting that if the dot product of two vectors is 0 then they are orthogonal.

For non-zero vectors, we can then normalize the vectors by dividing out their sizes as shown above: e 1 = 1 10 [ 3 1 ] {\displaystyle \mathbf {e} _{1}={\frac {1}{\sqrt {10}}}{\begin{bmatrix}3\\1\end{bmatrix}}} e 2 = 1 40 25 [ − − 2 / 5 6 / 5 ] = 1 10 [ − − 1 3 ] .

{\displaystyle \mathbf {e} _{2}={\frac {1}{\sqrt {40 \over 25}}}{\begin{bmatrix}-2/5\\6/5\end{bmatrix}}={\frac {1}{\sqrt {10}}}{\begin{bmatrix}-1\\3\end{bmatrix}}.} Properties [ edit ] Denote by GS ⁡ ⁡ ( v 1 , … … , v k ) {\displaystyle \operatorname {GS} (\mathbf {v} _{1},\dots ,\mathbf {v} _{k})} the result of applying the Gram–Schmidt process to a collection of vectors v 1 , … … , v k {\displaystyle \mathbf {v} _{1},\dots ,\mathbf {v} _{k}} . This yields a map GS : : ( R n ) k → → ( R n ) k {\displaystyle \operatorname {GS} \colon (\mathbb {R} ^{n})^{k}\to (\mathbb {R} ^{n})^{k}} .

It has the following properties: It is continuous It is orientation preserving in the sense that or ⁡ ⁡ ( v 1 , … … , v k ) = or ⁡ ⁡ ( GS ⁡ ⁡ ( v 1 , … … , v k ) ) {\displaystyle \operatorname {or} (\mathbf {v} _{1},\dots ,\mathbf {v} _{k})=\operatorname {or} (\operatorname {GS} (\mathbf {v} _{1},\dots ,\mathbf {v} _{k}))} .

It commutes with orthogonal maps: Let g : : R n → → R n {\displaystyle g\colon \mathbb {R} ^{n}\to \mathbb {R} ^{n}} be orthogonal (with respect to the given inner product). Then we have GS ⁡ ⁡ ( g ( v 1 ) , … … , g ( v k ) ) = ( g ( GS ⁡ ⁡ ( v 1 , … … , v k ) 1 ) , … … , g ( GS ⁡ ⁡ ( v 1 , … … , v k ) k ) ) {\displaystyle \operatorname {GS} (g(\mathbf {v} _{1}),\dots ,g(\mathbf {v} _{k}))=\left(g(\operatorname {GS} (\mathbf {v} _{1},\dots ,\mathbf {v} _{k})_{1}),\dots ,g(\operatorname {GS} (\mathbf {v} _{1},\dots ,\mathbf {v} _{k})_{k})\right)} Further, a parametrized version of the Gram–Schmidt process yields a (strong) deformation retraction of the general linear group G L ( R n ) {\displaystyle \mathrm {GL} (\mathbb {R} ^{n})} onto the orthogonal group O ( R n ) {\displaystyle O(\mathbb {R} ^{n})} .

Numerical stability [ edit ] When this process is implemented on a computer, the vectors u k {\displaystyle \mathbf {u} _{k}} are often not quite orthogonal, due to rounding errors . For the Gram–Schmidt process as described above (sometimes referred to as "classical Gram–Schmidt") this loss of orthogonality is particularly bad; therefore, it is said that the (classical) Gram–Schmidt process is numerically unstable .

The Gram–Schmidt process can be stabilized by a small modification; this version is sometimes referred to as modified Gram-Schmidt or MGS. This approach gives the same result as the original formula in exact arithmetic and introduces smaller errors in finite-precision arithmetic.

Instead of computing the vector u k as u k = v k − − proj u 1 ⁡ ⁡ ( v k ) − − proj u 2 ⁡ ⁡ ( v k ) − − ⋯ ⋯ − − proj u k − − 1 ⁡ ⁡ ( v k ) , {\displaystyle \mathbf {u} _{k}=\mathbf {v} _{k}-\operatorname {proj} _{\mathbf {u} _{1}}(\mathbf {v} _{k})-\operatorname {proj} _{\mathbf {u} _{2}}(\mathbf {v} _{k})-\cdots -\operatorname {proj} _{\mathbf {u} _{k-1}}(\mathbf {v} _{k}),} it is computed as u k ( 1 ) = v k − − proj u 1 ⁡ ⁡ ( v k ) , u k ( 2 ) = u k ( 1 ) − − proj u 2 ⁡ ⁡ ( u k ( 1 ) ) , ⋮ ⋮ u k ( k − − 2 ) = u k ( k − − 3 ) − − proj u k − − 2 ⁡ ⁡ ( u k ( k − − 3 ) ) , u k ( k − − 1 ) = u k ( k − − 2 ) − − proj u k − − 1 ⁡ ⁡ ( u k ( k − − 2 ) ) , e k = u k ( k − − 1 ) ‖ u k ( k − − 1 ) ‖ {\displaystyle {\begin{aligned}\mathbf {u} _{k}^{(1)}&=\mathbf {v} _{k}-\operatorname {proj} _{\mathbf {u} _{1}}(\mathbf {v} _{k}),\\\mathbf {u} _{k}^{(2)}&=\mathbf {u} _{k}^{(1)}-\operatorname {proj} _{\mathbf {u} _{2}}\left(\mathbf {u} _{k}^{(1)}\right),\\&\;\;\vdots \\\mathbf {u} _{k}^{(k-2)}&=\mathbf {u} _{k}^{(k-3)}-\operatorname {proj} _{\mathbf {u} _{k-2}}\left(\mathbf {u} _{k}^{(k-3)}\right),\\\mathbf {u} _{k}^{(k-1)}&=\mathbf {u} _{k}^{(k-2)}-\operatorname {proj} _{\mathbf {u} _{k-1}}\left(\mathbf {u} _{k}^{(k-2)}\right),\\\mathbf {e} _{k}&={\frac {\mathbf {u} _{k}^{(k-1)}}{\left\|\mathbf {u} _{k}^{(k-1)}\right\|}}\end{aligned}}} This method is used in the previous animation, when the intermediate v 3 ′ {\displaystyle \mathbf {v} '_{3}} vector is used when orthogonalizing the blue vector v 3 {\displaystyle \mathbf {v} _{3}} .

Here is another description of the modified algorithm. Given the vectors v 1 , v 2 , … … , v n {\displaystyle \mathbf {v} _{1},\mathbf {v} _{2},\dots ,\mathbf {v} _{n}} , in our first step we produce vectors v 1 , v 2 ( 1 ) , … … , v n ( 1 ) {\displaystyle \mathbf {v} _{1},\mathbf {v} _{2}^{(1)},\dots ,\mathbf {v} _{n}^{(1)}} by removing components along the direction of v 1 {\displaystyle \mathbf {v} _{1}} . In formulas, v k ( 1 ) := v k − − ⟨ ⟨ v k , v 1 ⟩ ⟩ ⟨ ⟨ v 1 , v 1 ⟩ ⟩ v 1 {\displaystyle \mathbf {v} _{k}^{(1)}:=\mathbf {v} _{k}-{\frac {\langle \mathbf {v} _{k},\mathbf {v} _{1}\rangle }{\langle \mathbf {v} _{1},\mathbf {v} _{1}\rangle }}\mathbf {v} _{1}} . After this step we already have two of our desired orthogonal vectors u 1 , … … , u n {\displaystyle \mathbf {u} _{1},\dots ,\mathbf {u} _{n}} , namely u 1 = v 1 , u 2 = v 2 ( 1 ) {\displaystyle \mathbf {u} _{1}=\mathbf {v} _{1},\mathbf {u} _{2}=\mathbf {v} _{2}^{(1)}} , but we also made v 3 ( 1 ) , … … , v n ( 1 ) {\displaystyle \mathbf {v} _{3}^{(1)},\dots ,\mathbf {v} _{n}^{(1)}} already orthogonal to u 1 {\displaystyle \mathbf {u} _{1}} . Next, we orthogonalize those remaining vectors against u 2 = v 2 ( 1 ) {\displaystyle \mathbf {u} _{2}=\mathbf {v} _{2}^{(1)}} . This means we compute v 3 ( 2 ) , v 4 ( 2 ) , … … , v n ( 2 ) {\displaystyle \mathbf {v} _{3}^{(2)},\mathbf {v} _{4}^{(2)},\dots ,\mathbf {v} _{n}^{(2)}} by subtraction v k ( 2 ) := v k ( 1 ) − − ⟨ ⟨ v k ( 1 ) , u 2 ⟩ ⟩ ⟨ ⟨ u 2 , u 2 ⟩ ⟩ u 2 {\displaystyle \mathbf {v} _{k}^{(2)}:=\mathbf {v} _{k}^{(1)}-{\frac {\langle \mathbf {v} _{k}^{(1)},\mathbf {u} _{2}\rangle }{\langle \mathbf {u} _{2},\mathbf {u} _{2}\rangle }}\mathbf {u} _{2}} . Now we have stored the vectors v 1 , v 2 ( 1 ) , v 3 ( 2 ) , v 4 ( 2 ) , … … , v n ( 2 ) {\displaystyle \mathbf {v} _{1},\mathbf {v} _{2}^{(1)},\mathbf {v} _{3}^{(2)},\mathbf {v} _{4}^{(2)},\dots ,\mathbf {v} _{n}^{(2)}} where the first three vectors are already u 1 , u 2 , u 3 {\displaystyle \mathbf {u} _{1},\mathbf {u} _{2},\mathbf {u} _{3}} and the remaining vectors are already orthogonal to u 1 , u 2 {\displaystyle \mathbf {u} _{1},\mathbf {u} _{2}} . As should be clear now, the next step orthogonalizes v 4 ( 2 ) , … … , v n ( 2 ) {\displaystyle \mathbf {v} _{4}^{(2)},\dots ,\mathbf {v} _{n}^{(2)}} against u 3 = v 3 ( 2 ) {\displaystyle \mathbf {u} _{3}=\mathbf {v} _{3}^{(2)}} . Proceeding in this manner we find the full set of orthogonal vectors u 1 , … … , u n {\displaystyle \mathbf {u} _{1},\dots ,\mathbf {u} _{n}} . If orthonormal vectors are desired, then we normalize as we go, so that the denominators in the subtraction formulas turn into ones.

Algorithm [ edit ] The following MATLAB algorithm implements classical Gram–Schmidt orthonormalization. The vectors v 1 , ..., v k (columns of matrix V , so that V(:,j) is the j {\displaystyle j} th vector) are replaced by orthonormal vectors (columns of U ) which span the same subspace.

function U = gramschmidt ( V ) [ n , k ] = size ( V ); U = zeros ( n , k ); U (:, 1 ) = V (:, 1 ) / norm ( V (:, 1 )); for i = 2 : k U (:, i ) = V (:, i ); for j = 1 : i - 1 U (:, i ) = U (:, i ) - ( U (:, j ) '* U (:, i )) * U (:, j ); end U (:, i ) = U (:, i ) / norm ( U (:, i )); end end The cost of this algorithm is asymptotically O( nk 2 ) floating point operations, where n is the dimensionality of the vectors.

[ 2 ] Via Gaussian elimination [ edit ] If the rows { v 1 , ..., v k } are written as a matrix A {\displaystyle A} , then applying Gaussian elimination to the augmented matrix [ A A T | A ] {\displaystyle \left[AA^{\mathsf {T}}|A\right]} will produce the orthogonalized vectors in place of A {\displaystyle A} . However the matrix A A T {\displaystyle AA^{\mathsf {T}}} must be brought to row echelon form , using only the row operation of adding a scalar multiple of one row to another.

[ 3 ] For example, taking v 1 = [ 3 1 ] , v 2 = [ 2 2 ] {\displaystyle \mathbf {v} _{1}={\begin{bmatrix}3&1\end{bmatrix}},\mathbf {v} _{2}={\begin{bmatrix}2&2\end{bmatrix}}} as above, we have [ A A T | A ] = [ 10 8 3 1 8 8 2 2 ] {\displaystyle \left[AA^{\mathsf {T}}|A\right]=\left[{\begin{array}{rr|rr}10&8&3&1\\8&8&2&2\end{array}}\right]} And reducing this to row echelon form produces [ 1 .8 .3 .1 0 1 − − .25 .75 ] {\displaystyle \left[{\begin{array}{rr|rr}1&.8&.3&.1\\0&1&-.25&.75\end{array}}\right]} The normalized vectors are then e 1 = 1 .3 2 + .1 2 [ .3 .1 ] = 1 10 [ 3 1 ] {\displaystyle \mathbf {e} _{1}={\frac {1}{\sqrt {.3^{2}+.1^{2}}}}{\begin{bmatrix}.3&.1\end{bmatrix}}={\frac {1}{\sqrt {10}}}{\begin{bmatrix}3&1\end{bmatrix}}} e 2 = 1 .25 2 + .75 2 [ − − .25 .75 ] = 1 10 [ − − 1 3 ] , {\displaystyle \mathbf {e} _{2}={\frac {1}{\sqrt {.25^{2}+.75^{2}}}}{\begin{bmatrix}-.25&.75\end{bmatrix}}={\frac {1}{\sqrt {10}}}{\begin{bmatrix}-1&3\end{bmatrix}},} as in the example above.

Determinant formula [ edit ] The result of the Gram–Schmidt process may be expressed in a non-recursive formula using determinants .

e j = 1 D j − − 1 D j | ⟨ ⟨ v 1 , v 1 ⟩ ⟩ ⟨ ⟨ v 2 , v 1 ⟩ ⟩ ⋯ ⋯ ⟨ ⟨ v j , v 1 ⟩ ⟩ ⟨ ⟨ v 1 , v 2 ⟩ ⟩ ⟨ ⟨ v 2 , v 2 ⟩ ⟩ ⋯ ⋯ ⟨ ⟨ v j , v 2 ⟩ ⟩ ⋮ ⋮ ⋮ ⋮ ⋱ ⋱ ⋮ ⋮ ⟨ ⟨ v 1 , v j − − 1 ⟩ ⟩ ⟨ ⟨ v 2 , v j − − 1 ⟩ ⟩ ⋯ ⋯ ⟨ ⟨ v j , v j − − 1 ⟩ ⟩ v 1 v 2 ⋯ ⋯ v j | {\displaystyle \mathbf {e} _{j}={\frac {1}{\sqrt {D_{j-1}D_{j}}}}{\begin{vmatrix}\langle \mathbf {v} _{1},\mathbf {v} _{1}\rangle &\langle \mathbf {v} _{2},\mathbf {v} _{1}\rangle &\cdots &\langle \mathbf {v} _{j},\mathbf {v} _{1}\rangle \\\langle \mathbf {v} _{1},\mathbf {v} _{2}\rangle &\langle \mathbf {v} _{2},\mathbf {v} _{2}\rangle &\cdots &\langle \mathbf {v} _{j},\mathbf {v} _{2}\rangle \\\vdots &\vdots &\ddots &\vdots \\\langle \mathbf {v} _{1},\mathbf {v} _{j-1}\rangle &\langle \mathbf {v} _{2},\mathbf {v} _{j-1}\rangle &\cdots &\langle \mathbf {v} _{j},\mathbf {v} _{j-1}\rangle \\\mathbf {v} _{1}&\mathbf {v} _{2}&\cdots &\mathbf {v} _{j}\end{vmatrix}}} u j = 1 D j − − 1 | ⟨ ⟨ v 1 , v 1 ⟩ ⟩ ⟨ ⟨ v 2 , v 1 ⟩ ⟩ ⋯ ⋯ ⟨ ⟨ v j , v 1 ⟩ ⟩ ⟨ ⟨ v 1 , v 2 ⟩ ⟩ ⟨ ⟨ v 2 , v 2 ⟩ ⟩ ⋯ ⋯ ⟨ ⟨ v j , v 2 ⟩ ⟩ ⋮ ⋮ ⋮ ⋮ ⋱ ⋱ ⋮ ⋮ ⟨ ⟨ v 1 , v j − − 1 ⟩ ⟩ ⟨ ⟨ v 2 , v j − − 1 ⟩ ⟩ ⋯ ⋯ ⟨ ⟨ v j , v j − − 1 ⟩ ⟩ v 1 v 2 ⋯ ⋯ v j | {\displaystyle \mathbf {u} _{j}={\frac {1}{D_{j-1}}}{\begin{vmatrix}\langle \mathbf {v} _{1},\mathbf {v} _{1}\rangle &\langle \mathbf {v} _{2},\mathbf {v} _{1}\rangle &\cdots &\langle \mathbf {v} _{j},\mathbf {v} _{1}\rangle \\\langle \mathbf {v} _{1},\mathbf {v} _{2}\rangle &\langle \mathbf {v} _{2},\mathbf {v} _{2}\rangle &\cdots &\langle \mathbf {v} _{j},\mathbf {v} _{2}\rangle \\\vdots &\vdots &\ddots &\vdots \\\langle \mathbf {v} _{1},\mathbf {v} _{j-1}\rangle &\langle \mathbf {v} _{2},\mathbf {v} _{j-1}\rangle &\cdots &\langle \mathbf {v} _{j},\mathbf {v} _{j-1}\rangle \\\mathbf {v} _{1}&\mathbf {v} _{2}&\cdots &\mathbf {v} _{j}\end{vmatrix}}} where D 0 = 1 {\displaystyle D_{0}=1} and, for j ≥ ≥ 1 {\displaystyle j\geq 1} , D j {\displaystyle D_{j}} is the Gram determinant D j = | ⟨ ⟨ v 1 , v 1 ⟩ ⟩ ⟨ ⟨ v 2 , v 1 ⟩ ⟩ ⋯ ⋯ ⟨ ⟨ v j , v 1 ⟩ ⟩ ⟨ ⟨ v 1 , v 2 ⟩ ⟩ ⟨ ⟨ v 2 , v 2 ⟩ ⟩ ⋯ ⋯ ⟨ ⟨ v j , v 2 ⟩ ⟩ ⋮ ⋮ ⋮ ⋮ ⋱ ⋱ ⋮ ⋮ ⟨ ⟨ v 1 , v j ⟩ ⟩ ⟨ ⟨ v 2 , v j ⟩ ⟩ ⋯ ⋯ ⟨ ⟨ v j , v j ⟩ ⟩ | .

{\displaystyle D_{j}={\begin{vmatrix}\langle \mathbf {v} _{1},\mathbf {v} _{1}\rangle &\langle \mathbf {v} _{2},\mathbf {v} _{1}\rangle &\cdots &\langle \mathbf {v} _{j},\mathbf {v} _{1}\rangle \\\langle \mathbf {v} _{1},\mathbf {v} _{2}\rangle &\langle \mathbf {v} _{2},\mathbf {v} _{2}\rangle &\cdots &\langle \mathbf {v} _{j},\mathbf {v} _{2}\rangle \\\vdots &\vdots &\ddots &\vdots \\\langle \mathbf {v} _{1},\mathbf {v} _{j}\rangle &\langle \mathbf {v} _{2},\mathbf {v} _{j}\rangle &\cdots &\langle \mathbf {v} _{j},\mathbf {v} _{j}\rangle \end{vmatrix}}.} Note that the expression for u k {\displaystyle \mathbf {u} _{k}} is a "formal" determinant, i.e. the matrix contains both scalars and vectors; the meaning of this expression is defined to be the result of a cofactor expansion along the row of vectors.

The determinant formula for the Gram-Schmidt is computationally (exponentially) slower than the recursive algorithms described above; it is mainly of theoretical interest.

Expressed using geometric algebra [ edit ] Expressed using notation used in geometric algebra , the unnormalized results of the Gram–Schmidt process can be expressed as u k = v k − − ∑ ∑ j = 1 k − − 1 ( v k ⋅ ⋅ u j ) u j − − 1 , {\displaystyle \mathbf {u} _{k}=\mathbf {v} _{k}-\sum _{j=1}^{k-1}(\mathbf {v} _{k}\cdot \mathbf {u} _{j})\mathbf {u} _{j}^{-1}\ ,} which is equivalent to the expression using the proj {\displaystyle \operatorname {proj} } operator defined above. The results can equivalently be expressed as [ 4 ] u k = v k ∧ ∧ v k − − 1 ∧ ∧ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ∧ ∧ v 1 ( v k − − 1 ∧ ∧ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ∧ ∧ v 1 ) − − 1 , {\displaystyle \mathbf {u} _{k}=\mathbf {v} _{k}\wedge \mathbf {v} _{k-1}\wedge \cdot \cdot \cdot \wedge \mathbf {v} _{1}(\mathbf {v} _{k-1}\wedge \cdot \cdot \cdot \wedge \mathbf {v} _{1})^{-1},} which is closely related to the expression using determinants above.

Alternatives [ edit ] Other orthogonalization algorithms use Householder transformations or Givens rotations . The algorithms using Householder transformations are more stable than the stabilized Gram–Schmidt process. On the other hand, the Gram–Schmidt process produces the j {\displaystyle j} th orthogonalized vector after the j {\displaystyle j} th iteration, while orthogonalization using Householder reflections produces all the vectors only at the end. This makes only the Gram–Schmidt process applicable for iterative methods like the Arnoldi iteration .

Yet another alternative is motivated by the use of Cholesky decomposition for inverting the matrix of the normal equations in linear least squares . Let V {\displaystyle V} be a full column rank matrix, whose columns need to be orthogonalized. The matrix V ∗ ∗ V {\displaystyle V^{*}V} is Hermitian and positive definite , so it can be written as V ∗ ∗ V = L L ∗ ∗ , {\displaystyle V^{*}V=LL^{*},} using the Cholesky decomposition . The lower triangular matrix L {\displaystyle L} with strictly positive diagonal entries is invertible . Then columns of the matrix U = V ( L − − 1 ) ∗ ∗ {\displaystyle U=V\left(L^{-1}\right)^{*}} are orthonormal and span the same subspace as the columns of the original matrix V {\displaystyle V} . The explicit use of the product V ∗ ∗ V {\displaystyle V^{*}V} makes the algorithm unstable, especially if the product's condition number is large. Nevertheless, this algorithm is used in practice and implemented in some software packages because of its high efficiency and simplicity.

In quantum mechanics there are several orthogonalization schemes with characteristics better suited for certain applications than original Gram–Schmidt. Nevertheless, it remains a popular and effective algorithm for even the largest electronic structure calculations.

[ 5 ] Run-time complexity [ edit ] Gram-Schmidt orthogonalization can be done in strongly-polynomial time . The run-time analysis is similar to that of Gaussian elimination .

[ 6 ] : 40 See also [ edit ] Linear algebra Recursion Orthogonality (mathematics) References [ edit ] ^ Cheney, Ward; Kincaid, David (2009).

Linear Algebra: Theory and Applications . Sudbury, Ma: Jones and Bartlett. pp. 544, 558.

ISBN 978-0-7637-5020-6 .

^ Golub & Van Loan 1996 , §5.2.8.

^ Pursell, Lyle; Trimble, S. Y. (1 January 1991). "Gram-Schmidt Orthogonalization by Gauss Elimination".

The American Mathematical Monthly .

98 (6): 544– 549.

doi : 10.2307/2324877 .

JSTOR 2324877 .

^ Doran, Chris; Lasenby, Anthony (2007).

Geometric Algebra for Physicists . Cambridge University Press. p. 124.

ISBN 978-0-521-71595-9 .

^ Pursell, Yukihiro; et al. (2011). "First-principles calculations of electron states of a silicon nanowire with 100,000 atoms on the K computer".

Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis . pp. 1:1–1:11.

doi : 10.1145/2063384.2063386 .

ISBN 9781450307710 .

S2CID 14316074 .

^ Grötschel, Martin ; Lovász, László ; Schrijver, Alexander (1993), Geometric algorithms and combinatorial optimization , Algorithms and Combinatorics, vol. 2 (2nd ed.), Springer-Verlag, Berlin, doi : 10.1007/978-3-642-78240-4 , ISBN 978-3-642-78242-8 , MR 1261419 Notes [ edit ] ^ In the complex case, this assumes that the inner product is linear in the first argument and conjugate-linear in the second. In physics a more common convention is linearity in the second argument, in which case we define proj u ⁡ ⁡ ( v ) = ⟨ ⟨ u , v ⟩ ⟩ ⟨ ⟨ u , u ⟩ ⟩ u .

{\displaystyle \operatorname {proj} _{\mathbf {u} }(\mathbf {v} )={\frac {\langle \mathbf {u} ,\mathbf {v} \rangle }{\langle \mathbf {u} ,\mathbf {u} \rangle }}\,\mathbf {u} .} Sources [ edit ] Bau III, David; Trefethen, Lloyd N.

(1997), Numerical linear algebra , Philadelphia: Society for Industrial and Applied Mathematics, ISBN 978-0-89871-361-9 .

Golub, Gene H.

; Van Loan, Charles F.

(1996), Matrix Computations (3rd ed.), Johns Hopkins, ISBN 978-0-8018-5414-9 .

Greub, Werner (1975), Linear Algebra (4th ed.), Springer .

Soliverez, C. E.; Gagliano, E. (1985), "Orthonormalization on the plane: a geometric approach" (PDF) , Mex. J. Phys.

, 31 (4): 743– 758, archived from the original (PDF) on 2014-03-07 , retrieved 2013-06-22 .

External links [ edit ] Mathematics portal "Orthogonalization" , Encyclopedia of Mathematics , EMS Press , 2001 [1994] Harvey Mudd College Math Tutorial on the Gram-Schmidt algorithm Earliest known uses of some of the words of mathematics: G The entry "Gram-Schmidt orthogonalization" has some information and references on the origins of the method.

Demos: Gram Schmidt process in plane and Gram Schmidt process in space Gram-Schmidt orthogonalization applet NAG Gram–Schmidt orthogonalization of n vectors of order m routine Proof: Raymond Puzio, Keenan Kidwell. "proof of Gram-Schmidt orthogonalization algorithm" (version 8). PlanetMath.org.

v t e Linear algebra Outline Glossary Basic concepts Scalar Vector Vector space Scalar multiplication Vector projection Linear span Linear map Linear projection Linear independence Linear combination Multilinear map Basis Change of basis Row and column vectors Row and column spaces Kernel Eigenvalues and eigenvectors Transpose Linear equations Matrices Block Decomposition Invertible Minor Multiplication Rank Transformation Cramer's rule Gaussian elimination Productive matrix Gram matrix Bilinear Orthogonality Dot product Hadamard product Inner product space Outer product Kronecker product Gram–Schmidt process Multilinear algebra Determinant Cross product Triple product Seven-dimensional cross product Geometric algebra Exterior algebra Bivector Multivector Tensor Outermorphism Vector space constructions Dual Direct sum Function space Quotient Subspace Tensor product Numerical Floating-point Numerical stability Basic Linear Algebra Subprograms Sparse matrix Comparison of linear algebra libraries Category Retrieved from " https://en.wikipedia.org/w/index.php?title=Gram–Schmidt_process&oldid=1296401574 " Categories : Linear algebra Functional analysis Hidden categories: Articles with short description Short description is different from Wikidata Articles with example MATLAB/Octave code This page was last edited on 19 June 2025, at 20:07 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Gram–Schmidt process 36 languages Add topic

