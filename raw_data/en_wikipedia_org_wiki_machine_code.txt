Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Assembly language 2 Instruction set Toggle Instruction set subsection 2.1 Overlapping instruction 2.2 Microcode 3 Examples Toggle Examples subsection 3.1 IBM 709x 3.2 MIPS 4 Bytecode 5 Storage 6 Readability 7 See also 8 Notes 9 References 10 Sources 11 Further reading Toggle the table of contents Machine code 75 languages العربية Azərbaycanca বাংলা 閩南語 / Bân-lâm-gí Беларуская Български Bosanski Brezhoneg Català Čeština Cymraeg Dansk Deutsch Eesti Ελληνικά Español Esperanto Euskara فارسی Français Galego 한국어 Հայերեն हिन्दी Hornjoserbsce Hrvatski Ido Bahasa Indonesia IsiZulu Íslenska Italiano עברית ქართული Қазақша Кыргызча Latviešu Lietuvių La .lojban.

Lombard Magyar മലയാളം Bahasa Melayu Minangkabau Mirandés Монгол မြန်မာဘာသာ Nederlands 日本語 Norsk bokmål Norsk nynorsk Олык марий Oʻzbekcha / ўзбекча Polski Português Qaraqalpaqsha Română Русский Shqip Simple English Slovenčina Slovenščina کوردی Српски / srpski Srpskohrvatski / српскохрватски Suomi Svenska Tagalog ไทย Türkçe Українська اردو Tiếng Việt 吴语 粵語 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Instructions directly executable by a computer For code that is completely internal to some CPUs and normally inaccessible to programmers, see Microcode .

"Native code" redirects here. For the French colonial legal system, see Native code (France) .

Machine language monitor running on a W65C816S microprocessor , displaying code disassembly and dumps of processor register and memory Program execution General concepts Code Translation Compiler Compile time Optimizing compiler Linking Execution Runtime system Executable Interpreter Virtual machine Intermediate representation (IR) Types of code Source code Object code Bytecode Machine code Microcode Compilation strategies Ahead-of-time (AOT) Just-in-time (JIT) Tracing just-in-time Compile and go system Precompilation Transcompilation Recompilation Notable runtimes Android Runtime (ART) BEAM (Erlang) Common Language Runtime (CLR) and Mono CPython and PyPy crt0 ( C target-specific initializer) Java virtual machine (JVM) LuaJIT Objective-C and Swift 's V8 and Node.js Zend Engine (PHP) Notable compilers & toolchains GNU Compiler Collection (GCC) LLVM and Clang MSVC Glasgow Haskell Compiler (GHC) v t e In computing , machine code is data encoded and structured to control a computer 's central processing unit (CPU) via its programmable interface . A computer program consists primarily of sequences of machine-code instructions.

[ 1 ] Machine code is classified as native with respect to its host CPU since it is the language that CPU interprets directly.

[ 2 ] A software interpreter is a virtual machine that processes virtual machine code.

A machine-code instruction causes the CPU to perform a specific task such as: Load a word from memory to a CPU register Execute an arithmetic logic unit (ALU) operation on one or more registers or memory locations Jump or skip to an instruction that is not the next one An instruction set architecture (ISA) defines the interface to a CPU and varies by groupings or families of CPU design such as x86 and ARM . Generally, machine code compatible with one family is not with others, but there are exceptions. The VAX architecture includes optional support of the PDP-11 instruction set. The IA-64 architecture includes optional support of the IA-32 instruction set. And, the PowerPC 615 can natively process both PowerPC and x86 instructions.

Assembly language [ edit ] Translation of assembly into machine code Assembly language provides a relatively direct mapping from a human-readable source code to machine code. The source code represents numerical codes as mnemonics and labels.

[ 3 ] For example, NOP represents the x86 architecture opcode 0x90. While it is possible to write a program in machine code, doing so is tedious and error-prone. Therefore, programs are usually written in assembly or, more commonly, in a high-level programming language .

Instruction set [ edit ] A machine instruction encodes an operation as a pattern of bits based on the specified format for the machine's instruction set.

[ nb 1 ] [ 4 ] Instruction sets differ in various ways. Instructions of a set might all be the same length or different instructions might have different lengths; they might be smaller than, the same size as, or larger than the word size of the architecture. The number of instructions may be relatively small or large. Instructions may or may not have to be aligned on particular memory boundaries, such as the architecture's word boundary.

[ 4 ] An instruction set needs to execute the circuits of a computer's digital logic level . At the digital level, the program needs to control the computer's registers, bus, memory, ALU, and other hardware components.

[ 5 ] To control a computer's architectural features, machine instructions are created. Examples of features that are controlled using machine instructions: segment registers [ 6 ] protected address mode [ 7 ] binary-coded decimal (BCD) arithmetic [ 8 ] The criteria for instruction formats include: Instructions most commonly used should be shorter than instructions rarely used.

[ 4 ] The memory transfer rate of the underlying hardware determines the flexibility of the memory fetch instructions.

The number of bits in the address field requires special consideration.

[ 9 ] Determining the size of the address field is a choice between space and speed.

[ 9 ] On some computers, the number of bits in the address field may be too small to access all of the physical memory. Also, virtual address space needs to be considered. Another constraint may be a limitation on the size of registers used to construct the address. Whereas a shorter address field allows the instructions to execute more quickly, other physical properties need to be considered when designing the instruction format.

Instructions can be separated into two types: general-purpose and special-purpose. Special-purpose instructions exploit architectural features that are unique to a computer. General-purpose instructions control architectural features common to all computers.

[ 10 ] General-purpose instructions control: Data movement from one place to another Monadic operations that have one operand to produce a result Dyadic operations that have two operands to produce a result Comparisons and conditional jumps Procedure calls Loop control Input/output Overlapping instruction [ edit ] On processor architectures with variable-length instruction sets [ 11 ] (such as Intel 's x86 processor family) it is, within the limits of the control-flow resynchronizing phenomenon known as the Kruskal count , [ 12 ] [ 11 ] [ 13 ] [ 14 ] [ 15 ] sometimes possible through opcode-level programming to deliberately arrange the resulting code so that two code paths share a common fragment of opcode sequences.

[ nb 2 ] These are called overlapping instructions , overlapping opcodes , overlapping code , overlapped code , instruction scission , or jump into the middle of an instruction .

[ 16 ] [ 17 ] [ 18 ] In the 1970s and 1980s, overlapping instructions were sometimes used to preserve memory space. One example were in the implementation of error tables in Microsoft 's Altair BASIC , where interleaved instructions mutually shared their instruction bytes.

[ 19 ] [ 11 ] [ 16 ] The technique is rarely used today, but might still be necessary to resort to in areas where extreme optimization for size is necessary on byte-level such as in the implementation of boot loaders which have to fit into boot sectors .

[ nb 3 ] It is also sometimes used as a code obfuscation technique as a measure against disassembly and tampering.

[ 11 ] [ 14 ] The principle is also used in shared code sequences of fat binaries which must run on multiple instruction-set-incompatible processor platforms.

[ nb 2 ] This property is also used to find unintended instructions called gadgets in existing code repositories and is used in return-oriented programming as alternative to code injection for exploits such as return-to-libc attacks .

[ 20 ] [ 11 ] Microcode [ edit ] In some computers, the machine code of the architecture is implemented by an even more fundamental underlying layer called microcode , providing a common machine language interface across a line or family of different models of computer with widely different underlying dataflows . This is done to facilitate porting of machine language programs between different models.

[ 21 ] An example of this use is the IBM System/360 family of computers and their successors.

[ 22 ] Examples [ edit ] IBM 709x [ edit ] The IBM 704, 709, 704x and 709x store one instruction in each instruction word; IBM numbers the bit from the left as S, 1, ..., 35. Most instructions have one of two formats: Generic S,1-11 12-13 Flag, ignored in some instructions 14-17 unused 18-20 Tag 21-35 Y Index register control, other than TSX S,1-2 Opcode 3-17 Decrement 18-20 Tag 21-35 Y For all but the IBM 7094 and 7094 II, there are three index registers designated A, B and C; indexing with multiple 1 bits in the tag subtracts the logical or of the selected index registers and loading with multiple 1 bits in the tag loads all of the selected index registers. The 7094 and 7094 II have seven index registers, but when they are powered on they are in multiple tag mode , in which they use only the three of the index registers in a fashion compatible with earlier machines, and require a Leave Multiple Tag Mode ( LMTM ) instruction in order to access the other four index registers.

The effective address is normally Y-C(T), where C(T) is either 0 for a tag of 0, the logical or of the selected index registers in multiple tag mode or the selected index register if not in multiple tag mode. However, the effective address for index register control instructions is just Y.

A flag with both bits 1 selects indirect addressing; the indirect address word has both a tag and a Y field.

In addition to transfer (branch) instructions, these machines have skip instruction that conditionally skip one or two words, e.g., Compare Accumulator with Storage (CAS) does a three way compare and conditionally skips to NSI, NSI+1 or NSI+2, depending on the result.

MIPS [ edit ] The MIPS architecture provides a specific example for a machine code whose instructions are always 32 bits long.

[ 23 ] : 299 The general type of instruction is given by the op (operation) field, the highest 6 bits. J-type (jump) and I-type (immediate) instructions are fully specified by op . R-type (register) instructions include an additional field funct to determine the exact operation. The fields used in these types are: 6      5     5     5     5      6 bits
[  op  |  rs |  rt |  rd |shamt| funct]  R-type
[  op  |  rs |  rt | address/immediate]  I-type
[  op  |        target address        ]  J-type rs , rt , and rd indicate register operands; shamt gives a shift amount; and the address or immediate fields contain an operand directly.

[ 23 ] : 299–301 For example, adding the registers 1 and 2 and placing the result in register 6 is encoded: [ 23 ] : 554 [  op  |  rs |  rt |  rd |shamt| funct]
    0     1     2     6     0     32     decimal
 000000 00001 00010 00110 00000 100000   binary Load a value into register 8, taken from the memory cell 68 cells after the location listed in register 3: [ 23 ] : 552 [  op  |  rs |  rt | address/immediate]
   35     3     8           68           decimal
 100011 00011 01000 00000 00001 000100   binary Jumping to the address 1024: [ 23 ] : 552 [  op  |        target address        ]
    2                 1024               decimal
 000010 00000 00000 00000 10000 000000   binary Bytecode [ edit ] Machine code is similar to yet fundamentally different from bytecode . Like machine code, bytecode is typically generated (i.e. by a compiler) from source code. But, unlike machine code, bytecode is not directly executable by a CPU. An exception is if a processor is designed to use bytecode as its machine code, such as the Java processor . If bytecode is processed by an software interpreter, then that interpreter is a virtual machine for which the bytecode is its machine code.

Storage [ edit ] During execution, machine code is generally stored in RAM although running form ROM is supported by some devices. Regardless, the code may also be cached in more specialized memory to enhance performance. There may be different caches for instructions and data, depending on the architecture.

[ 24 ] From the point of view of a process , the machine code lives in code space , a designated part of its address space . In a multi-threading environment, different threads of one process share code space along with data space, which reduces the overhead of context switching considerably as compared to process switching.

[ 25 ] Readability [ edit ] Machine code is generally considered to be not human readable, [ 26 ] with Douglas Hofstadter comparing it to examining the atoms of a DNA molecule.

[ 27 ] However, various tools and methods support understanding machine code.

Disassembly decodes machine code to assembly language which is possible since assembly instructions can often be mapped one-to-one to machine instructions.

[ 28 ] A decompiler converts machine code to a high-level language , but the result can be relatively obfuscated ; hard to understand.

A program can be associated with debug symbols (either embedded in the executable or in a separate file) that allow it to be mapped to external source code. A debugger reads the symbols to help a programmer interactively debug the program. Example include: The SHARE Operating System (1959) for the IBM 709 , IBM 7090 , and IBM 7094 computers allowed for an loadable code format named SQUOZE . SQUOZE was a compressed binary form of assembly language code and included a symbol table.

Modern IBM mainframe operating systems , such as z/OS , have available a symbol table named Associated data (ADATA). The table is stored in a file that can be produced by the IBM High-Level Assembler (HLASM), [ 29 ] [ 30 ] IBM's COBOL compiler, [ 31 ] and IBM's PL/I compiler, [ 32 ] either as a separate SYSADATA file or as ADATA records in a Generalized object output file (GOFF).

[ 33 ] This obsoletes the TEST records from OS/360 , although it is still possible to request them and to use them in the TSO TEST command.

Windows uses a symbol table [ 34 ] that is stored in a program database ( .pdb ) file.

[ 35 ] Most Unix-like operating systems have available symbol table formats named stabs and DWARF . In macOS and other Darwin -based operating systems, the debug symbols are stored in DWARF format in a separate .dSYM file.

See also [ edit ] Look up machine code in Wiktionary, the free dictionary.

Computer code Endianness – Order of bytes in a computer word List of machine languages Machine code monitor – Software that was popular during the home computer era of the 1970s and 1980s Micro-Professor MPF-I – Microcomputer released by Multitech in 1981 Object code – Sequence of statements or instructions in a computer language P-code machine – Programming virtual machine Reduced instruction set computer – Processor executing one instruction in minimal clock cycles (RISC) Very long instruction word – Processor design that offloads complexity to the compiler Notes [ edit ] ^ On early decimal machines , patterns of characters, digits and digit sign ^ a b While overlapping instructions on processor architectures with variable-length instruction sets can sometimes be arranged to merge different code paths back into one through control-flow resynchronization , overlapping code for different processor architectures can sometimes also be crafted to cause execution paths to branch into different directions depending on the underlying processor, as is sometimes used in fat binaries .

^ For example, the DR-DOS master boot records (MBRs) and boot sectors (which also hold the partition table and BIOS Parameter Block , leaving less than 446 respectively 423 bytes for the code) were traditionally able to locate the boot file in the FAT12 or FAT16 file system by themselves and load it into memory as a whole, in contrast to their counterparts in MS-DOS and PC DOS , which instead rely on the system files to occupy the first two directory entry locations in the file system and the first three sectors of IBMBIO.COM to be stored at the start of the data area in contiguous sectors containing a secondary loader to load the remainder of the file into memory (requiring SYS to take care of all these conditions). When FAT32 and logical block addressing (LBA) support was added, Microsoft even switched to require i386 instructions and split the boot code over two sectors for code size reasons, which was no option to follow for DR-DOS as it would have broken backward - and cross-compatibility with other operating systems in multi-boot and chain load scenarios, and as with older IBM PC–compatible PCs. Instead, the DR-DOS 7.07 boot sectors resorted to self-modifying code , opcode -level programming in machine language, controlled utilization of (documented) side effects , multi-level data/code overlapping and algorithmic folding techniques to still fit everything into a physical sector of only 512 bytes without giving up any of their extended functions.

References [ edit ] ^ Stallings, William (2015).

Computer Organization and Architecture 10th edition . Pearson Prentice Hall. p. 776.

ISBN 9789332570405 .

^ Gregory, Kate (2003-04-28).

"Managed, Unmanaged, Native: What Kind of Code Is This?" .

Developer.com . Archived from the original on 2009-09-23 . Retrieved 2008-09-02 .

^ Dourish, Paul (2004).

Where the Action is: The Foundations of Embodied Interaction .

MIT Press . p. 7.

ISBN 0-262-54178-5 . Retrieved 2023-03-05 .

^ a b c Tanenbaum 1990 , p.

251 ^ Tanenbaum 1990 , p.

162 ^ Tanenbaum 1990 , p.

231 ^ Tanenbaum 1990 , p.

237 ^ Tanenbaum 1990 , p.

236 ^ a b Tanenbaum 1990 , p.

253 ^ Tanenbaum 1990 , p.

283 ^ a b c d e Jacob, Matthias; Jakubowski, Mariusz H.; Venkatesan, Ramarathnam [at Wikidata] (20–21 September 2007).

Towards Integral Binary Execution: Implementing Oblivious Hashing Using Overlapped Instruction Encodings (PDF) . Proceedings of the 9th workshop on Multimedia & Security (MM&Sec '07). Dallas, Texas, US: Association for Computing Machinery . pp.

129– 140.

CiteSeerX 10.1.1.69.5258 .

doi : 10.1145/1288869.1288887 .

ISBN 978-1-59593-857-2 .

S2CID 14174680 .

Archived (PDF) from the original on 2018-09-04 . Retrieved 2021-12-25 .

(12 pages) ^ Lagarias, Jeffrey "Jeff" Clark ; Rains, Eric Michael ; Vanderbei, Robert J.

(2009) [2001-10-13]. "The Kruskal Count". In Brams, Stephen; Gehrlein, William V.; Roberts, Fred S. (eds.).

The Mathematics of Preference, Choice and Order . Studies in Choice and Welfare. Berlin / Heidelberg, Germany: Springer-Verlag . pp.

371– 391.

arXiv : math/0110143 .

doi : 10.1007/978-3-540-79128-7_23 .

ISBN 978-3-540-79127-0 .

(22 pages) ^ Andriesse, Dennis; Bos, Herbert [at Wikidata] (2014-07-10).  Written at Vrije Universiteit Amsterdam, Amsterdam, Netherlands. Dietrich, Sven (ed.).

Instruction-Level Steganography for Covert Trigger-Based Malware (PDF) . 11th International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment (DIMVA).

Lecture Notes in Computer Science . Egham, UK; Switzerland: Springer International Publishing . pp. 41–50 [45].

doi : 10.1007/978-3-319-08509-8_3 .

eISSN 1611-3349 .

ISBN 978-3-31908508-1 .

ISSN 0302-9743 .

S2CID 4634611 . LNCS 8550.

Archived (PDF) from the original on 2023-08-26 . Retrieved 2023-08-26 .

(10 pages) ^ a b Jakubowski, Mariusz H. (February 2016).

"Graph Based Model for Software Tamper Protection" .

Microsoft .

Archived from the original on 2019-10-31 . Retrieved 2023-08-19 .

^ Jämthagen, Christopher (November 2016).

On Offensive and Defensive Methods in Software Security (PDF) (Thesis). Lund, Sweden: Department of Electrical and Information Technology, Lund University . p. 96.

ISBN 978-91-7623-942-1 .

ISSN 1654-790X .

Archived (PDF) from the original on 2023-08-26 . Retrieved 2023-08-26 .

(1+xvii+1+152 pages) ^ a b "Unintended Instructions on x86" .

Hacker News . 2021.

Archived from the original on 2021-12-25 . Retrieved 2021-12-24 .

^ Kinder, Johannes (2010-09-24).

Static Analysis of x86 Executables [ Statische Analyse von Programmen in x86 Maschinensprache ] (PDF) (Dissertation). Munich, Germany: Technische Universität Darmstadt . D17.

Archived from the original on 2020-11-12 . Retrieved 2021-12-25 .

(199 pages) ^ "What is "overlapping instructions" obfuscation?" .

Reverse Engineering Stack Exchange . 2013-04-07.

Archived from the original on 2021-12-25 . Retrieved 2021-12-25 .

^ Gates, William "Bill" Henry , Personal communication (NB. According to Jacob et al .) ^ Shacham, Hovav (2007).

The Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86) (PDF) . Proceedings of the ACM, CCS 2007.

ACM Press .

Archived (PDF) from the original on 2021-12-15 . Retrieved 2021-12-24 .

^ Kent, Allen; Williams, James G. (1993-04-05).

Encyclopedia of Computer Science and Technology: Volume 28 - Supplement 13: AerosPate Applications of Artificial Intelligence to Tree Structures . CRC Press. pp.

33– 34.

ISBN 978-0-8247-2281-4 .

^ Tucker, S. G. (1967-12-31).

"Microprogram control for SYSTEM/360" .

IBM Systems Journal .

6 (4): 222– 241.

doi : 10.1147/sj.64.0222 .

ISSN 0018-8670 – via IEEE Xplore.

^ a b c d e Harris, David; Harris, Sarah L. (2007).

Digital Design and Computer Architecture .

Morgan Kaufmann Publishers .

ISBN 978-0-12-370497-9 . Retrieved 2023-03-05 .

^ Su, Chao; Zeng, Qingkai (2021).

"Survey of CPU Cache-Based Side-Channel Attacks: Systematic Analysis, Security Models, and Countermeasures" .

Security and Communication Networks .

2021 (1): 5559552.

doi : 10.1155/2021/5559552 .

ISSN 1939-0122 .

^ "CS 537 Notes, Section #3A: Processes and Threads" .

pages.cs.wisc.edu . School of Computer, Data & Information Sciences, University of Wisconsin-Madison . Retrieved 2025-07-18 .

^ Samuelson 1984 , p. 683.

^ Hofstadter 1979 , p.

290 .

^ Tanenbaum 1990 , p.

398 .

^ "Associated Data Architecture" .

High Level Assembler and Toolkit Feature .

^ "Associated data file output" (PDF) .

High Level Assembler for z/OS & z/VM & z/VSE - 1.6 -HLASM Programmer's Guide (PDF) (Eighth ed.).

IBM . October 2022. pp.

278– 332. SC26-4941-07 . Retrieved 2025-02-14 .

^ "COBOL SYSADATA file contents" .

Enterprise COBOL for z/OS .

^ "SYSADATA message information" .

Enterprise PL/I for z/OS 6.1 information . 2025-03-17.

^ "Appendix C. Generalized object file format (GOFF)" (PDF) .

z/OS - 3.1 - MVS Program Management: Advanced Facilities (PDF) .

IBM . 2024-12-18. pp.

201– 240. SA23-1392-60 . Retrieved 2025-02-14 .

^ "Symbols for Windows debugging" .

Microsoft Learn . 2022-12-20.

^ "Querying the .Pdb File" .

Microsoft Learn . 2024-01-12.

Sources [ edit ] Hofstadter, Douglas R.

(1979).

Gödel, Escher, Bach: An Eternal Golden Braid .

Basic Books .

ISBN 0-465-02685-0 . Retrieved 2025-02-10 .

Samuelson, Pamela (1984).

"CONTU Revisited: The Case Against Copyright Protection for Computer Programs in Machine-Readable Form" .

Duke Law Journal .

33 (4): 663– 769.

doi : 10.2307/1372418 .

hdl : hein.journals/duklr1984 .

JSTOR 1372418 . Retrieved 2025-02-10 .

Tanenbaum, Andrew S.

(1990).

Structured Computer Organization, Third Edition . Prentice Hall. p.

398 .

ISBN 978-0-13-854662-5 .

Further reading [ edit ] Hennessy, John L.

; Patterson, David A.

(1994).

Computer Organization and Design. The Hardware/Software Interface .

Morgan Kaufmann Publishers .

ISBN 1-55860-281-X .

Tanenbaum, Andrew S.

(1999).

Structured Computer Organization (Fourth ed.).

Prentice Hall .

ISBN 0-13-020435-8 . Retrieved 2025-02-10 .

Brookshear, J. Glenn (2007).

Computer Science: An Overview (Ninth ed.).

Addison Wesley .

ISBN 978-0-321-38701-1 . Retrieved 2025-02-10 .

v t e Application binary interface (ABI) Parts, conventions Alignment Calling convention Call stack Library static Machine code Memory segmentation Name mangling Object code Opaque pointer Position-independent code Relocation System call Virtual method table Related topics Binary-code compatibility Foreign function interface Language binding Linker dynamic Loader Year 2038 problem v t e Types of programming languages Level Machine Assembly Compiled Interpreted Low-level High-level Very high-level Esoteric Generation First Second Third Fourth Fifth Authority control databases : National Germany NewPP limit report
Parsed by mw‐web.codfw.main‐b499cfbc7‐cmkch
Cached time: 20250815154034
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.829 seconds
Real time usage: 1.029 seconds
Preprocessor visited node count: 5612/1000000
Revision size: 32799/2097152 bytes
Post‐expand include size: 98572/2097152 bytes
Template argument size: 2874/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 6/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 154533/5000000 bytes
Lua time usage: 0.555/10.000 seconds
Lua memory usage: 27524991/52428800 bytes
Number of Wikibase entities loaded: 1/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  920.938      1 -total
 30.22%  278.353      2 Template:Reflist
 17.97%  165.481      9 Template:Annotated_link
 16.95%  156.136     14 Template:Cite_book
  9.04%   83.291      1 Template:Program_execution
  8.17%   75.217      1 Template:Short_description
  5.19%   47.769      5 Template:Rp
  4.95%   45.567      3 Template:Sfn
  4.88%   44.972      2 Template:Pagetype
  4.66%   42.950     10 Template:Cite_web Saved in parser cache with key enwiki:pcache:20683:|#|:idhash:canonical and timestamp 20250815154034 and revision id 1305936654. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Machine_code&oldid=1305936654 " Categories : Machine code Assembly languages Low-level programming languages Hidden categories: CS1 interproject-linked names CS1 location test Articles with short description Short description is different from Wikidata Use dmy dates from December 2021 Use list-defined references from December 2021 This page was last edited on 15 August 2025, at 00:06 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Machine code 75 languages Add topic

