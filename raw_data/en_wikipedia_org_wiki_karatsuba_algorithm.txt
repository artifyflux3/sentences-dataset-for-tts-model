Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 History 2 Algorithm Toggle Algorithm subsection 2.1 Basic step 2.2 Example 2.3 Recursive application 2.4 Time complexity analysis 3 Implementation 4 References 5 External links Toggle the table of contents Karatsuba algorithm 18 languages Català Čeština Deutsch Español Esperanto فارسی Français 한국어 Italiano മലയാളം 日本語 Polski Português Русский Српски / srpski ไทย Українська 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Algorithm for integer multiplication Karatsuba algorithm Class Multiplication algorithm Karatsuba multiplication of az+b and cz+d (boxed), and 1234 and 567 with z=100. Magenta arrows denote multiplication, amber denotes addition, silver denotes subtraction and cyan denotes left shift. (A), (B) and (C) show recursion with z=10 to obtain intermediate values.

The Karatsuba algorithm is a fast multiplication algorithm for integers . It was discovered by Anatoly Karatsuba in 1960 and published in 1962.

[ 1 ] [ 2 ] [ 3 ] It is a divide-and-conquer algorithm that reduces the multiplication of two n -digit numbers to three multiplications of n /2-digit numbers and, by repeating this reduction, to  at most n log 2 ⁡ ⁡ 3 ≈ ≈ n 1.58 {\displaystyle n^{\log _{2}3}\approx n^{1.58}} single-digit multiplications. It is therefore asymptotically faster than the traditional algorithm, which performs n 2 {\displaystyle n^{2}} single-digit products.

The Karatsuba algorithm was the first multiplication algorithm asymptotically faster than the quadratic "grade school" algorithm.
The Toom–Cook algorithm (1963) is a faster generalization of Karatsuba's method, and the Schönhage–Strassen algorithm (1971) is even faster, for sufficiently large n .

History [ edit ] The standard procedure for multiplication of two n -digit numbers requires a number of elementary operations proportional to n 2 {\displaystyle n^{2}\,\!} , or O ( n 2 ) {\displaystyle O(n^{2})\,\!} in big-O notation .

Andrey Kolmogorov conjectured that the traditional algorithm was asymptotically optimal , meaning that any algorithm for that task would require Ω Ω ( n 2 ) {\displaystyle \Omega (n^{2})\,\!} elementary operations.

In 1960, Kolmogorov organized a seminar on mathematical problems in cybernetics at the Moscow State University , where he stated the Ω Ω ( n 2 ) {\displaystyle \Omega (n^{2})\,\!} conjecture and other problems in the complexity of computation . Within a week, Karatsuba, then a 23-year-old student, found an algorithm that multiplies two n -digit numbers in O ( n log 2 ⁡ ⁡ 3 ) {\displaystyle O(n^{\log _{2}3})} elementary steps, thus disproving the conjecture. Kolmogorov was very excited about the discovery; he communicated it at the next meeting of the seminar, which was then terminated. Kolmogorov gave some lectures on the Karatsuba result at conferences all over the world (see, for example, "Proceedings of the International Congress of Mathematicians 1962", pp. 351–356, and also "6 Lectures delivered at the International Congress of Mathematicians in Stockholm, 1962") and published the method in 1962, in the Proceedings of the USSR Academy of Sciences . The article had been written by Kolmogorov and contained two results on multiplication, Karatsuba's algorithm and a separate result by Yuri Ofman ; it listed "A. Karatsuba and Yu. Ofman" as the authors. Karatsuba only became aware of the paper when he received the reprints from the publisher.

[ 2 ] Algorithm [ edit ] Basic step [ edit ] The basic principle of Karatsuba's algorithm is divide-and-conquer , using a formula that allows one to compute the product of two large numbers x {\displaystyle x} and y {\displaystyle y} using three multiplications of smaller numbers, each with about half as many digits as x {\displaystyle x} or y {\displaystyle y} , plus some additions and digit shifts. This basic step is, in fact, a generalization of a similar complex multiplication algorithm , where the imaginary unit i is replaced by a power of the base .

Let x {\displaystyle x} and y {\displaystyle y} be represented as n {\displaystyle n} -digit strings in some base B {\displaystyle B} . For any positive integer m {\displaystyle m} less than n {\displaystyle n} , one can write the two given numbers as x = x 1 B m + x 0 , {\displaystyle x=x_{1}B^{m}+x_{0},} y = y 1 B m + y 0 , {\displaystyle y=y_{1}B^{m}+y_{0},} where x 0 {\displaystyle x_{0}} and y 0 {\displaystyle y_{0}} are less than B m {\displaystyle B^{m}} . The product is then x y = ( x 1 B m + x 0 ) ( y 1 B m + y 0 ) = x 1 y 1 B 2 m + ( x 1 y 0 + x 0 y 1 ) B m + x 0 y 0 = z 2 B 2 m + z 1 B m + z 0 , {\displaystyle {\begin{aligned}xy&=(x_{1}B^{m}+x_{0})(y_{1}B^{m}+y_{0})\\&=x_{1}y_{1}B^{2m}+(x_{1}y_{0}+x_{0}y_{1})B^{m}+x_{0}y_{0}\\&=z_{2}B^{2m}+z_{1}B^{m}+z_{0},\\\end{aligned}}} where z 2 = x 1 y 1 , {\displaystyle z_{2}=x_{1}y_{1},} z 1 = x 1 y 0 + x 0 y 1 , {\displaystyle z_{1}=x_{1}y_{0}+x_{0}y_{1},} z 0 = x 0 y 0 .

{\displaystyle z_{0}=x_{0}y_{0}.} These formulae require four multiplications and were known to Charles Babbage .

[ 4 ] Karatsuba observed that x y {\displaystyle xy} can be computed in only three multiplications, at the cost of a few extra additions.  With z 0 {\displaystyle z_{0}} and z 2 {\displaystyle z_{2}} as before and z 3 = ( x 1 + x 0 ) ( y 1 + y 0 ) , {\displaystyle z_{3}=(x_{1}+x_{0})(y_{1}+y_{0}),} one can observe that z 1 = x 1 y 0 + x 0 y 1 = ( x 1 + x 0 ) ( y 0 + y 1 ) − − x 1 y 1 − − x 0 y 0 = z 3 − − z 2 − − z 0 .

{\displaystyle {\begin{aligned}z_{1}&=x_{1}y_{0}+x_{0}y_{1}\\&=(x_{1}+x_{0})(y_{0}+y_{1})-x_{1}y_{1}-x_{0}y_{0}\\&=z_{3}-z_{2}-z_{0}.\\\end{aligned}}} Thus only three multiplications are required for computing z 0 , z 1 {\displaystyle z_{0},z_{1}} and z 2 .

{\displaystyle z_{2}.} Example [ edit ] To compute the product of 12345 and 6789, where B = 10, choose m = 3. We use m right shifts for decomposing the input operands using the resulting base ( B m = 1000 ), as: 12345 = 12 · 1000 + 345 6789 = 6 · 1000 + 789 Only three multiplications, which operate on smaller integers, are used to compute three partial results: z 2 = 12 × 6 = 72 z 0 = 345 × 789 = 272205 z 1 = ( 12 + 345 ) × ( 6 + 789 ) − z 2 − z 0 = 357 × 795 − 72 − 272205 = 283815 − 72 − 272205 = 11538 We get the result by just adding these three partial results, shifted accordingly (and then taking carries into account by decomposing these three inputs in base 1000 as for the input operands): result = z 2 · ( B m ) 2 + z 1 · ( B m ) 1 + z 0 · ( B m ) 0 , i.e.

result = 72 · 1000 2 + 11538 · 1000 + 272205 = 83810205 .

Note that the intermediate third multiplication operates on an input domain which is less than two times larger than for the two first multiplications, its output domain is less than four times larger, and base- 1000 carries computed from the first two multiplications must be taken into account when computing these two subtractions.

Recursive application [ edit ] If n is four or more, the three multiplications in Karatsuba's basic step involve operands with fewer than n digits. Therefore, those products can be computed by recursive calls of the Karatsuba algorithm. The recursion can be applied until the numbers are so small that they can (or must) be computed directly.

In a computer with a full 32-bit by 32-bit multiplier , for example, one could choose B = 2 31 and store each digit as a separate 32-bit binary word. Then the sums x 1 + x 0 and y 1 + y 0 will not need an extra binary word for storing the carry-over digit (as in carry-save adder ), and the Karatsuba recursion can be applied until the numbers to multiply are only one digit long.

Time complexity analysis [ edit ] Karatsuba's basic step works for any base B and any m , but the recursive algorithm is most efficient when m is equal to n /2, rounded up. In particular, if n is 2 k , for some integer k , and the recursion stops only when n is 1, then the number of single-digit multiplications is 3 k , which is n c where c = log 2 3.

Since one can extend any inputs with zero digits until their length is a power of two, it follows that the number of elementary multiplications, for any n , is at most 3 ⌈ ⌈ log 2 ⁡ ⁡ n ⌉ ⌉ ≤ ≤ 3 n log 2 ⁡ ⁡ 3 {\displaystyle 3^{\lceil \log _{2}n\rceil }\leq 3n^{\log _{2}3}\,\!} .

Since the additions, subtractions, and digit shifts (multiplications by powers of B ) in Karatsuba's basic step take time proportional to n , their cost becomes negligible as n increases. More precisely, if T ( n ) denotes the total number of elementary operations that the algorithm performs when multiplying two n -digit numbers, then T ( n ) = 3 T ( ⌈ ⌈ n / 2 ⌉ ⌉ ) + c n + d {\displaystyle T(n)=3T(\lceil n/2\rceil )+cn+d} for some constants c and d . For this recurrence relation , the master theorem for divide-and-conquer recurrences gives the asymptotic bound T ( n ) = Θ Θ ( n log 2 ⁡ ⁡ 3 ) {\displaystyle T(n)=\Theta (n^{\log _{2}3})\,\!} .

It follows that, for sufficiently large n , Karatsuba's algorithm will perform fewer shifts and single-digit additions than longhand multiplication, even though its basic step uses more additions and shifts than the straightforward formula. For small values of n , however, the extra shift and add operations may make it run slower than the longhand method.

Implementation [ edit ] Here is the pseudocode for this algorithm, using numbers represented in base ten. For the binary representation of integers, it suffices to replace everywhere 10 by 2.

[ 5 ] The second argument of the split_at function specifies the number of digits to extract from the right : for example, split_at("12345", 3) will extract the 3 final digits, giving: high="12", low="345".

function karatsuba ( num1 , num2 ) if ( num1 < 10 or num2 < 10 ) return num1 × num2 /* fall back to traditional multiplication */ /* Calculates the size of the numbers. */ m = max ( size_base10 ( num1 ), size_base10 ( num2 )) m2 = floor ( m / 2 ) /* m2 = ceil (m / 2) will also work */ /* Split the digit sequences in the middle. */ high1 , low1 = split_at ( num1 , m2 ) high2 , low2 = split_at ( num2 , m2 ) /* 3 recursive calls made to numbers approximately half the size. */ z0 = karatsuba ( low1 , low2 ) z1 = karatsuba ( low1 + high1 , low2 + high2 ) z2 = karatsuba ( high1 , high2 ) return ( z2 × 10 ^ ( m2 × 2 )) + (( z1 - z2 - z0 ) × 10 ^ m2 ) + z0 An issue that occurs when implementation is that the above computation of ( x 1 + x 0 ) {\displaystyle (x_{1}+x_{0})} and ( y 1 + y 0 ) {\displaystyle (y_{1}+y_{0})} for z 1 {\displaystyle z_{1}} may result in overflow (will produce a result in the range B m ≤ ≤ result < 2 B m {\displaystyle B^{m}\leq {\text{result}}<2B^{m}} ), which require a multiplier having one extra bit.  This can be avoided by noting that z 1 = ( x 0 − − x 1 ) ( y 1 − − y 0 ) + z 2 + z 0 .

{\displaystyle z_{1}=(x_{0}-x_{1})(y_{1}-y_{0})+z_{2}+z_{0}.} This computation of ( x 0 − − x 1 ) {\displaystyle (x_{0}-x_{1})} and ( y 1 − − y 0 ) {\displaystyle (y_{1}-y_{0})} will produce a result in the range of − − B m < result < B m {\displaystyle -B^{m}<{\text{result}}<B^{m}} .  This method may produce negative numbers, which require one extra bit to encode signedness, and would still require one extra bit for the multiplier.  However, one way to avoid this is to record the sign and then use the absolute value of ( x 0 − − x 1 ) {\displaystyle (x_{0}-x_{1})} and ( y 1 − − y 0 ) {\displaystyle (y_{1}-y_{0})} to perform an unsigned multiplication, after which the result may be negated when both signs originally differed.  Another advantage is that even though ( x 0 − − x 1 ) ( y 1 − − y 0 ) {\displaystyle (x_{0}-x_{1})(y_{1}-y_{0})} may be negative, the final computation of z 1 {\displaystyle z_{1}} only involves additions.

References [ edit ] ^ A. Karatsuba and Yu. Ofman (1962).

"Multiplication of Many-Digital Numbers by Automatic Computers" .

Proceedings of the USSR Academy of Sciences .

145 : 293– 294. Translation in the academic journal Physics-Doklady , 7 (1963), pp. 595–596 {{ cite journal }} :  CS1 maint: postscript ( link ) ^ a b A. A. Karatsuba (1995).

"The Complexity of Computations" (PDF) .

Proceedings of the Steklov Institute of Mathematics .

211 : 169– 183. Translation from Trudy Mat. Inst. Steklova, 211, 186–202 (1995) {{ cite journal }} :  CS1 maint: postscript ( link ) ^ Knuth D.E. (1969) The Art of Computer Programming . v.2.

Addison-Wesley Publ.Co., 724 pp.

^ Charles Babbage, Chapter VIII – Of the Analytical Engine, Larger Numbers Treated, Passages from the Life of a Philosopher , Longman Green, London, 1864; page 125.

^ Weiss, Mark A. (2005).

Data Structures and Algorithm Analysis in C++ . Addison-Wesley. p. 480.

ISBN 0321375319 .

External links [ edit ] Karatsuba's Algorithm for Polynomial Multiplication Weisstein, Eric W.

"Karatsuba Multiplication" .

MathWorld .

Bernstein, D. J., " Multidigit multiplication for mathematicians ". Covers Karatsuba and many other multiplication algorithms.

v t e Number-theoretic algorithms Primality tests AKS APR Baillie–PSW Elliptic curve Pocklington Fermat Lucas Lucas–Lehmer Lucas–Lehmer–Riesel Proth's theorem Pépin's Quadratic Frobenius Solovay–Strassen Miller–Rabin Prime-generating Sieve of Atkin Sieve of Eratosthenes Sieve of Pritchard Sieve of Sundaram Wheel factorization Integer factorization Continued fraction (CFRAC) Dixon's Lenstra elliptic curve (ECM) Euler's Pollard's rho p − 1 p + 1 Quadratic sieve (QS) General number field sieve (GNFS) Special number field sieve (SNFS) Rational sieve Fermat's Shanks's square forms Trial division Shor's Multiplication Ancient Egyptian Long Karatsuba Toom–Cook Schönhage–Strassen Fürer's Euclidean division Binary Chunking Fourier Goldschmidt Newton-Raphson Long Short SRT Discrete logarithm Baby-step giant-step Pollard rho Pollard kangaroo Pohlig–Hellman Index calculus Function field sieve Greatest common divisor Binary Euclidean Extended Euclidean Lehmer's Modular square root Cipolla Pocklington's Tonelli–Shanks Berlekamp Other algorithms Chakravala Cornacchia Exponentiation by squaring Integer square root Integer relation ( LLL ; KZ ) Modular exponentiation Montgomery reduction Schoof Trachtenberg system Italics indicate that algorithm is for numbers of special forms Retrieved from " https://en.wikipedia.org/w/index.php?title=Karatsuba_algorithm&oldid=1288801081 " Categories : Computer arithmetic algorithms Multiplication Divide-and-conquer algorithms Hidden categories: CS1 maint: postscript Articles with short description Short description matches Wikidata Articles with example pseudocode This page was last edited on 4 May 2025, at 20:43 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Karatsuba algorithm 18 languages Add topic

