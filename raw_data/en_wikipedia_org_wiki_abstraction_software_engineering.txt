Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Rationale 2 Abstraction features Toggle Abstraction features subsection 2.1 Programming languages 2.2 Specification methods 2.3 Specification languages 3 Control abstraction Toggle Control abstraction subsection 3.1 Structured programming 4 Data abstraction 5 Manual data abstraction 6 Abstraction in object oriented programming Toggle Abstraction in object oriented programming subsection 6.1 Object-oriented design 7 Considerations 8 Levels of abstraction Toggle Levels of abstraction subsection 8.1 Database systems 8.2 Layered architecture 9 See also 10 References 11 Further reading 12 External links Toggle the table of contents Abstraction (computer science) 32 languages Afrikaans العربية বাংলা Български Bosanski Català Dansk Deutsch Español فارسی Français 한국어 Ido Bahasa Indonesia Italiano עברית Magyar Bahasa Melayu 日本語 Polski Português Русский کوردی Српски / srpski Srpskohrvatski / српскохрватски Suomi Türkçe Українська اردو Tiếng Việt 粵語 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia (Redirected from Abstraction (software engineering) ) Technique for arranging complexity of computer systems In software engineering and computer science , abstraction is the process of generalizing concrete details, [ 1 ] such as attributes , away from the study of objects and systems to focus attention on details of greater importance.

[ 2 ] Abstraction is a fundamental concept in computer science and software engineering , especially within the object-oriented programming paradigm.

[ 3 ] Examples of this include: the usage of abstract data types to separate usage from working representations of data within programs ; [ 4 ] the concept of functions or subroutines which represent a specific way of implementing control flow ; the process of reorganizing common behavior from groups of non-abstract classes into abstract classes using inheritance and sub-classes , as seen in object-oriented programming languages.

Rationale [ edit ] The essence of abstraction is preserving information that is relevant in a given context, and forgetting information that is irrelevant in that context.

– John V. Guttag [ 5 ] Computing mostly operates independently of the concrete world. The hardware implements a model of computation that is interchangeable with others.

[ 6 ] The software is structured in architectures to enable humans to create the enormous systems by concentrating on a few issues at a time. These architectures are made of specific choices of abstractions.

Greenspun's tenth rule is an aphorism on how such an architecture is both inevitable and complex.

Language abstraction is a central form of abstraction in computing: new artificial languages are developed to express specific aspects of a system.

Modeling languages help in planning.

Computer languages can be processed with a computer. An example of this abstraction process is the generational development of programming language from the first-generation programming language ( machine language ) to the second-generation programming language ( assembly language ) and the third-generation programming language ( high-level programming language ). Each stage can be used as a stepping stone for the next stage. The language abstraction continues for example in scripting languages and domain-specific languages .

Within a programming language, some features let the programmer create new abstractions. These include subroutines , modules , polymorphism , and software components . Some other abstractions such as software design patterns and architectural styles remain invisible to a translator and operate only in the design of a system.

Some abstractions try to limit the range of concepts a programmer needs to be aware of, by completely hiding the abstractions they are built on. The software engineer and writer Joel Spolsky has criticized these efforts by claiming that all abstractions are leaky – that they can never completely hide the details below; [ 7 ] however, this does not negate the usefulness of abstraction.

Some abstractions are designed to inter-operate with other abstractions – for example, a programming language may contain a foreign function interface for making calls to the lower-level language.

Abstraction features [ edit ] Programming languages [ edit ] Further information: Programming language Different programming languages provide different types of abstraction, depending on the intended applications for the language. For example: In object-oriented programming languages such as C++ , Object Pascal , or Java , the concept of abstraction has become a declarative statement – using the syntax function ( parameters ) = 0; (in C++ ) or the reserved words (keywords) abstract [ 8 ] and interface [ 9 ] (in Java ). After such a declaration, it is the responsibility of the programmer to implement a class to instantiate the object of the declaration.

Functional programming languages commonly exhibit abstractions related to functions, such as lambda abstractions (making a term into a function of some variable) and higher-order functions (parameters are functions).

[ 10 ] Modern members of the Lisp programming language family such as Clojure , Scheme and Common Lisp support macro systems to allow syntactic abstraction. Other programming languages such as Scala also have macros, or very similar metaprogramming features (for example, Haskell has Template Haskell , OCaml has MetaOCaml ). These can allow programs to omit boilerplate code , abstract away tedious function call sequences, implement new control flow structures, and implement domain-specific languages (DSLs), which allow domain-specific concepts to be expressed in concise and elegant ways. All of these, when used correctly, improve both the programmer's efficiency and the clarity of source code by making the intended purpose more explicit. A consequence of syntactic abstraction is also that any Lisp dialect, and almost any programming language, can in principle, be implemented in any modern Lisp with significantly reduced (but still non-trivial in most cases) effort when compared to "more traditional" programming languages such as Python , C or Java .

Specification methods [ edit ] Further information: Formal specification Analysts have developed various methods to formally specify software systems. Some known methods include: Abstract-model based method (VDM, Z); Algebraic techniques (Larch, CLEAR, OBJ, ACT ONE, CASL); Process-based techniques (LOTOS, SDL, Estelle); Trace-based techniques (SPECIAL, TAM); Knowledge-based techniques (Refine, Gist).

Specification languages [ edit ] Further information: Specification language Specification languages generally rely on abstractions of one kind or another, since specifications are typically defined earlier in a project, (and at a more abstract level) than an eventual implementation. The Unified Modeling Language (UML) specification language, for example, allows the definition of abstract classes, which in a waterfall project, remain abstract during the architecture and specification phase of the project.

Control abstraction [ edit ] Further information: Control flow Programming languages offer control abstraction as one of the main purposes of their use. Computer machines understand operations at the very low level such as moving some bits from one location of the memory to another location and producing the sum of two sequences of bits. Programming languages allow this to be done in the higher level. For example, consider this statement written in a Pascal -like fashion: a := (1 + 2) * 5 To a human, this seems a fairly simple and obvious calculation ( "one plus two is three, times five is fifteen" ). However, the low-level steps necessary to carry out this evaluation, and return the value "15", and then assign that value to the variable "a", are actually quite subtle and complex. The values need to be converted to binary representation (often a much more complicated task than one would think) and the calculations decomposed (by the compiler or interpreter) into assembly instructions (again, which are much less intuitive to the programmer: operations such as shifting a binary register left, or adding the binary complement of the contents of one register to another, are simply not how humans think about the abstract arithmetical operations of addition or multiplication). Finally, assigning the resulting value of "15" to the variable labeled "a", so that "a" can be used later, involves additional 'behind-the-scenes' steps of looking up a variable's label and the resultant location in physical or virtual memory, storing the binary representation of "15" to that memory location, etc.

Without control abstraction, a programmer would need to specify all the register/binary-level steps each time they simply wanted to add or multiply a couple of numbers and assign the result to a variable. Such duplication of effort has two serious negative consequences: it forces the programmer to constantly repeat fairly common tasks every time a similar operation is needed it forces the programmer to program for the particular hardware and instruction set Structured programming [ edit ] Further information: Structured programming Structured programming involves the splitting of complex program tasks into smaller pieces with clear flow-control and interfaces between components, with a reduction of the complexity potential for side-effects.

In a simple program, this may aim to ensure that loops have single or obvious exit points and (where possible) to have single exit points from functions and procedures.

In a larger system, it may involve breaking down complex tasks into many different modules. Consider a system which handles payroll on ships and at shore offices: The uppermost level may feature a menu of typical end-user operations.

Within that could be standalone executables or libraries for tasks such as signing on and off employees or printing checks.

Within each of those standalone components there could be many different source files, each containing the program code to handle a part of the problem, with only selected interfaces available to other parts of the program. A sign on program could have source files for each data entry screen and the database interface (which may itself be a standalone third party library or a statically linked set of library routines).

Either the database or the payroll application also has to initiate the process of exchanging data with between ship and shore, and that data transfer task will often contain many other components.

These layers produce the effect of isolating the implementation details of one component and its assorted internal methods from the others. Object-oriented programming embraces and extends this concept.

Data abstraction [ edit ] Further information: Abstract data type Data abstraction enforces a clear separation between the abstract properties of a data type and the concrete details of its implementation. The abstract properties are those that are visible to client code that makes use of the data type—the interface to the data type—while the concrete implementation is kept entirely private, and indeed can change, for example to incorporate efficiency improvements over time. The idea is that such changes are not supposed to have any impact on client code, since they involve no difference in the abstract behaviour.

For example, one could define an abstract data type called lookup table which uniquely associates keys with values , and in which values may be retrieved by specifying their corresponding keys. Such a lookup table may be implemented in various ways: as a hash table , a binary search tree , or even a simple linear list of (key:value) pairs. As far as client code is concerned, the abstract properties of the type are the same in each case.

Of course, this all relies on getting the details of the interface right in the first place, since any changes there can have major impacts on client code. As one way to look at this: the interface forms a contract on agreed behaviour between the data type and client code; anything not spelled out in the contract is subject to change without notice.

Manual data abstraction [ edit ] While much of data abstraction occurs through computer science and automation, there are times when this process is done manually and without programming intervention. One way this can be understood is through data abstraction within the process of conducting a systematic review of the literature. In this methodology, data is abstracted by one or several abstractors when conducting a meta-analysis , with errors reduced through dual data abstraction followed by independent checking, known as adjudication .

[ 11 ] Abstraction in object oriented programming [ edit ] Further information: Object (computer science) In object-oriented programming theory, abstraction involves the facility to define objects that represent abstract "actors" that can perform work, report on and change their state, and "communicate" with other objects in the system. The term encapsulation refers to the hiding of state details, but extending the concept of data type from earlier programming languages to associate behavior most strongly with the data, and standardizing the way that different data types interact, is the beginning of abstraction . When abstraction proceeds into the operations defined, enabling objects of different types to be substituted, it is called polymorphism . When it proceeds in the opposite direction, inside the types or classes, structuring them to simplify a complex set of relationships, it is called delegation or inheritance .

Various object-oriented programming languages offer similar facilities for abstraction, all to support a general strategy of polymorphism in object-oriented programming, which includes the substitution of one data type for another in the same or similar role. Although not as generally supported, a configuration or image or package may predetermine a great many of these bindings at compile time , link time , or load time . This would leave only a minimum of such bindings to change at run-time .

Common Lisp Object System or Self , for example, feature less of a class-instance distinction and more use of delegation for polymorphism . Individual objects and functions are abstracted more flexibly to better fit with a shared functional heritage from Lisp .

C++ exemplifies another extreme: it relies heavily on templates and overloading and other static bindings at compile-time, which in turn has certain flexibility problems.

Although these examples offer alternate strategies for achieving the same abstraction, they do not fundamentally alter the need to support abstract nouns in code – all programming relies on an ability to abstract verbs as functions, nouns as data structures, and either as processes.

Consider for example a sample Java fragment to represent some common farm "animals" to a level of abstraction suitable to model simple aspects of their hunger and feeding. It defines an Animal class to represent both the state of the animal and its functions: public class Animal extends LivingThing { private Location loc ; private double energyReserves ; public boolean isHungry () { return energyReserves < 2.5 ; } public void eat ( Food food ) { // Consume food energyReserves += food .

getCalories (); } public void moveTo ( Location location ) { // Move to new location this .

loc = location ; } } With the above definition, one could create objects of type Animal and call their methods like this: thePig = new Animal (); theCow = new Animal (); if ( thePig .

isHungry ()) { thePig .

eat ( tableScraps ); } if ( theCow .

isHungry ()) { theCow .

eat ( grass ); } theCow .

moveTo ( theBarn ); In the above example, the class Animal is an abstraction used in place of an actual animal, LivingThing is a further abstraction (in this case a generalisation) of Animal .

If one requires a more differentiated hierarchy of animals – to differentiate, say, those who provide milk from those who provide nothing except meat at the end of their lives – that is an intermediary level of abstraction, probably DairyAnimal (cows, goats) who would eat foods suitable to giving good milk, and MeatAnimal (pigs, steers) who would eat foods to give the best meat-quality.

Such an abstraction could remove the need for the application coder to specify the type of food, so they could concentrate instead on the feeding schedule. The two classes could be related using inheritance or stand alone, and the programmer could define varying degrees of polymorphism between the two types. These facilities tend to vary drastically between languages, but in general each can achieve anything that is possible with any of the others. A great many operation overloads, data type by data type, can have the same effect at compile-time as any degree of inheritance or other means to achieve polymorphism. The class notation is simply a coder's convenience.

Object-oriented design [ edit ] Further information: Object-oriented design Decisions regarding what to abstract and what to keep under the control of the coder become the major concern of object-oriented design and domain analysis —actually determining the relevant relationships in the real world is the concern of object-oriented analysis or legacy analysis .

In general, to determine appropriate abstraction, one must make many small decisions about scope (domain analysis), determine what other systems one must cooperate with (legacy analysis), then perform a detailed object-oriented analysis which is expressed within project time and budget constraints as an object-oriented design. In our simple example, the domain is the barnyard, the live pigs and cows and their eating habits are the legacy constraints, the detailed analysis is that coders must have the flexibility to feed the animals what is available and thus there is no reason to code the type of food into the class itself, and the design is a single simple Animal class of which pigs and cows are instances with the same functions. A decision to differentiate DairyAnimal would change the detailed analysis but the domain and legacy analysis would be unchanged—thus it is entirely under the control of the programmer, and it is called an abstraction in object-oriented programming as distinct from abstraction in domain or legacy analysis.

Considerations [ edit ] When discussing formal semantics of programming languages , formal methods or abstract interpretation , abstraction refers to the act of considering a less detailed, but safe, definition of the observed program behaviors. For instance, one may observe only the final result of program executions instead of considering all the intermediate steps of executions. Abstraction is defined to a concrete (more precise) model of execution.

Abstraction may be exact or faithful with respect to a property if one can answer a question about the property equally well on the concrete or abstract model. For instance, if one wishes to know what the result of the evaluation of a mathematical expression involving only integers +, -, ×, is worth modulo n , then one needs only perform all operations modulo n (a familiar form of this abstraction is casting out nines ).

Abstractions, however, though not necessarily exact , should be sound . That is, it should be possible to get sound answers from them—even though the abstraction may simply yield a result of undecidability . For instance, students in a class may be abstracted by their minimal and maximal ages; if one asks whether a certain person belongs to that class, one may simply compare that person's age with the minimal and maximal ages; if his age lies outside the range, one may safely answer that the person does not belong to the class; if it does not, one may only answer "I don't know".

The level of abstraction included in a programming language can influence its overall usability . The Cognitive dimensions framework includes the concept of abstraction gradient in a formalism. This framework allows the designer of a programming language to study the trade-offs between abstraction and other characteristics of the design, and how changes in abstraction influence the language usability.

Abstractions can prove useful when dealing with computer programs, because non-trivial properties of computer programs are essentially undecidable (see Rice's theorem ). As a consequence, automatic methods for deriving information on the behavior of computer programs either have to drop termination (on some occasions, they may fail, crash or never yield out a result), soundness (they may provide false information), or precision (they may answer "I don't know" to some questions).

Abstraction is the core concept of abstract interpretation .

Model checking generally takes place on abstract versions of the studied systems.

Levels of abstraction [ edit ] Further information: Abstraction layer Computer science commonly presents levels (or, less commonly, layers ) of abstraction, wherein each level represents a different model of the same information and processes, but with varying amounts of detail. Each level uses a system of expression involving a unique set of objects and compositions that apply only to a particular domain.

[ 12 ] Each relatively abstract, "higher" level builds on a relatively concrete, "lower" level, which tends to provide an increasingly "granular" representation. For example, gates build on electronic circuits, binary on gates, machine language on binary, programming language on machine language, applications and operating systems on programming languages. Each level is embodied, but not determined, by the level beneath it, making it a language of description that is somewhat self-contained.

Database systems [ edit ] Further information: Database management system Since many users of database systems lack in-depth familiarity with computer data-structures, database developers often hide complexity through the following levels: Data abstraction levels of a database system Physical level – The lowest level of abstraction describes how a system actually stores data. The physical level describes complex low-level data structures in detail.

Logical level – The next higher level of abstraction describes what data the database stores, and what relationships exist among those data. The logical level thus describes an entire database in terms of a small number of relatively simple structures. Although implementation of the simple structures at the logical level may involve complex physical level structures, the user of the logical level does not need to be aware of this complexity. This is referred to as physical data independence .

Database administrators , who must decide what information to keep in a database, use the logical level of abstraction.

View level – The highest level of abstraction describes only part of the entire database. Even though the logical level uses simpler structures, complexity remains because of the variety of information stored in a large database. Many users of a database system do not need all this information; instead, they need to access only a part of the database. The view level of abstraction exists to simplify their interaction with the system. The system may provide many views for the same database.

Layered architecture [ edit ] Further information: Abstraction layer The ability to provide a design of different levels of abstraction can simplify the design considerably enable different role players to effectively work at various levels of abstraction support the portability of software artifacts (model-based ideally) Systems design and business process design can both use this. Some design processes specifically generate designs that contain various levels of abstraction.

Layered architecture partitions the concerns of the application into stacked groups (layers).
It is a technique used in designing computer software, hardware, and communications in which system or network components are isolated in layers so that changes can be made in one layer without affecting the others.

See also [ edit ] Abstraction principle (computer programming) Abstraction inversion for an anti-pattern of one danger in abstraction Abstract data type for an abstract description of a set of data Algorithm for an abstract description of a computational procedure Bracket abstraction for making a term into a function of a variable Data modeling for structuring data independent of the processes that use it Encapsulation for abstractions that hide implementation details Greenspun's Tenth Rule for an aphorism about an (the?) optimum point in the space of abstractions Higher-order function for abstraction where functions produce or consume other functions Lambda abstraction for making a term into a function of some variable List of abstractions (computer science) Refinement for the opposite of abstraction in computing Integer (computer science) Heuristic (computer science) References [ edit ] ^ Colburn, Timothy; Shute, Gary (5 June 2007). "Abstraction in Computer Science".

Minds and Machines .

17 (2): 169– 184.

doi : 10.1007/s11023-007-9061-7 .

ISSN 0924-6495 .

S2CID 5927969 .

^ Kramer, Jeff (1 April 2007). "Is abstraction the key to computing?".

Communications of the ACM .

50 (4): 36– 42.

doi : 10.1145/1232743.1232745 .

ISSN 0001-0782 .

S2CID 12481509 .

^ Ben-Ari, Mordechai (1 March 1998).

"Constructivism in computer science education" .

ACM SIGCSE Bulletin .

30 (1): 257, 257– 261.

doi : 10.1145/274790.274308 .

ISSN 0097-8418 .

^ Liskov, Barbara (1 May 1988). "Keynote address - data abstraction and hierarchy".

Addendum to the proceedings on Object-oriented programming systems, languages and applications (Addendum) - OOPSLA '87 . Vol. 23. ACM. pp.

17– 34.

doi : 10.1145/62138.62141 .

ISBN 0897912667 .

S2CID 14219043 .

{{ cite book }} : |journal= ignored ( help ) ^ Guttag, John V. (18 January 2013).

Introduction to Computation and Programming Using Python (Spring 2013 ed.). Cambridge, Massachusetts: The MIT Press.

ISBN 978-0262519632 .

^ Floridi, Luciano (September 2008).

"The Method of Levels of Abstraction" .

Minds and Machines .

18 (3): 303– 329.

doi : 10.1007/s11023-008-9113-7 .

hdl : 2299/2998 .

ISSN 0924-6495 .

S2CID 7522925 .

^ Spolsky, Joel (11 November 2002).

"The Law of Leaky Abstractions" .

^ "Abstract Methods and Classes" .

The Java Tutorials . Oracle . Retrieved 4 September 2014 .

^ "Using an Interface as a Type" .

The Java Tutorials . Oracle . Retrieved 4 September 2014 .

^ This article is based on material taken from Abstraction at the Free On-line Dictionary of Computing prior to 1 November 2008 and incorporated under the "relicensing" terms of the GFDL , version 1.3 or later.

^ E, Jian-Yu; Saldanha, Ian J.; Canner, Joseph; Schmid, Christopher H.; Le, Jimmy T.; Li, Tianjing (2020). "Adjudication rather than experience of data abstraction matters more in reducing errors in abstracting data in systematic reviews".

Research Synthesis Methods .

11 (3): 354– 362.

doi : 10.1002/jrsm.1396 .

ISSN 1759-2879 .

PMID 31955502 .

S2CID 210829764 .

^ Luciano Floridi , Levellism and the Method of Abstraction IEG – Research Report 22.11.04 Further reading [ edit ] Abelson, Harold ; Sussman, Gerald Jay ; Sussman, Julie (25 July 1996).

Structure and Interpretation of Computer Programs (2 ed.). MIT Press.

ISBN 978-0-262-01153-2 . Archived from the original on 26 February 2009 . Retrieved 22 June 2012 .

Spolsky, Joel (11 November 2002).

"The Law of Leaky Abstractions" .

Joel on Software .

Abstraction/information hiding – CS211 course, Cornell University.

Roberts, Eric S. (1997).

Programming Abstractions in C A Second Course in Computer Science .

Palermo, Jeffrey (29 July 2008).

"The Onion Architecture" .

Jeffrey Palermo .

Vishkin, Uzi (January 2011).

"Using simple abstraction to reinvent computing for parallelism" .

Communications of the ACM .

54 (1): 75– 85.

doi : 10.1145/1866739.1866757 .

External links [ edit ] SimArch example of layered architecture for distributed simulation systems.

v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Systems design Requirements Functional requirement Non-functional requirement Capacity Users Compute Memory Storage Network Web traffic Interface API SOAP REST GraphQL gRPC Webhook High-level design Client Load balancing Application server Message queue Integration Vertical Peer-to-peer API gateway pub-sub Event source ETL Batch Stream Orchestration Architectures Monolithic Microservices Event-driven Client–server Serverless Circuit breaker Rate limiting Database Relational NoSQL Graph Key–value LSM tree Time series Column oriented Principles Consistency Reliability CAP theorem Maintainability Configurability Modularity Durability Scalability Stateless Asynchronous I/O Loose coupling Availability Fault tolerance Failover Single point of failure Replication Consistent hashing Circuit breaker Latency Cache CDN Shard Database index Pre-caching Storage Object storage Block storage Observability Logging Metrics Tracing Error rate Queries per second Notification system Anomaly detection Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Commons Category NewPP limit report
Parsed by mw‐web.codfw.main‐7c956d68b4‐7528t
Cached time: 20250817070811
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.430 seconds
Real time usage: 0.525 seconds
Preprocessor visited node count: 1806/1000000
Revision size: 32069/2097152 bytes
Post‐expand include size: 84522/2097152 bytes
Template argument size: 1707/2097152 bytes
Highest expansion depth: 12/100
Expensive parser function count: 14/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 70214/5000000 bytes
Lua time usage: 0.246/10.000 seconds
Lua memory usage: 5827464/52428800 bytes
Number of Wikibase entities loaded: 0/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  424.257      1 -total
 36.31%  154.060      1 Template:Reflist
 25.74%  109.218      6 Template:Cite_journal
 20.97%   88.984      3 Template:Navbox
 20.29%   86.098      1 Template:Software_engineering
 15.47%   65.649      1 Template:Short_description
  9.09%   38.575      2 Template:Pagetype
  7.89%   33.473     11 Template:Further
  6.30%   26.722      4 Template:Cite_book
  5.59%   23.724      5 Template:Cite_web Saved in parser cache with key enwiki:pcache:60491:|#|:idhash:canonical and timestamp 20250817070811 and revision id 1297123979. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Abstraction_(computer_science)&oldid=1297123979 " Categories : Data management Abstraction Software engineering Object-oriented programming Hidden categories: CS1 errors: periodical ignored Articles with short description Short description matches Wikidata Use dmy dates from December 2019 Articles with example Java code Articles with example Pascal code This page was last edited on 24 June 2025, at 07:51 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Abstraction (computer science) 32 languages Add topic

