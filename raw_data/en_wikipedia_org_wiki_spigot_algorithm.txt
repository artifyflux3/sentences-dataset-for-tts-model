Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Example 2 References 3 Further reading Toggle the table of contents Spigot algorithm 4 languages Deutsch فارسی 한국어 Русский Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Algorithm for computing the value of a transcendental number A spigot algorithm is an algorithm for computing the value of a transcendental number (such as π or e ) that generates the digits of the number sequentially from left to right providing increasing precision as the algorithm proceeds.  Spigot algorithms also aim to minimize the amount of intermediate storage required. The name comes from the sense of the word "spigot" for a tap or valve controlling the flow of a liquid.  Spigot algorithms can be contrasted with algorithms that store and process complete numbers to produce successively more accurate approximations to the desired transcendental.

Interest in spigot algorithms was spurred in the early days of computational mathematics by extreme constraints on memory, and such an algorithm for calculating the digits of e appeared in a paper by Sale in 1968.

[ 1 ] In 1970, Abdali presented a more general algorithm to compute the sums of series in which the ratios of successive terms can be expressed as quotients of integer functions of term positions. This algorithm is applicable to many familiar series for trigonometric functions, logarithms, and transcendental numbers because these series satisfy the above condition.

[ 2 ] The name "spigot algorithm" seems to have been coined by Stanley Rabinowitz and Stan Wagon , whose algorithm for calculating the digits of π is sometimes referred to as " the spigot algorithm for π ".

[ 3 ] The spigot algorithm of Rabinowitz and Wagon is bounded , in the sense that the number of terms of the infinite series that will be processed must be specified in advance. The term " streaming algorithm " [ 4 ] indicates an approach without this restriction.  This allows the calculation to run indefinitely varying the amount of intermediate storage as the calculation progresses.

A variant of the spigot approach uses an algorithm which can be used to compute a single arbitrary digit of the transcendental without computing the preceding digits: an example is the Bailey–Borwein–Plouffe formula , a digit extraction algorithm for π which produces base 16 digits.  The inevitable truncation of the underlying infinite series of the algorithm means that the accuracy of the result may be limited by the number of terms calculated.

Example [ edit ] This example illustrates the working of a spigot algorithm by calculating the binary digits of the natural logarithm of 2 (sequence A068426 in the OEIS ) using the identity ln ⁡ ⁡ ( 2 ) = ∑ ∑ k = 1 ∞ ∞ 1 k 2 k .

{\displaystyle \ln(2)=\sum _{k=1}^{\infty }{\frac {1}{k2^{k}}}\,.} To start calculating binary digits from, as an example, the 8th place we multiply this identity by 2 7 (since 7 = 8 − 1): 2 7 ln ⁡ ⁡ ( 2 ) = 2 7 ∑ ∑ k = 1 ∞ ∞ 1 k 2 k .

{\displaystyle 2^{7}\ln(2)=2^{7}\sum _{k=1}^{\infty }{\frac {1}{k2^{k}}}\,.} We then divide the infinite sum into a "head", in which the exponents of 2 are greater than or equal to zero, and a "tail", in which the exponents of 2 are negative: 2 7 ln ⁡ ⁡ ( 2 ) = ∑ ∑ k = 1 7 2 7 − − k k + ∑ ∑ k = 8 ∞ ∞ 1 k 2 k − − 7 .

{\displaystyle 2^{7}\ln(2)=\sum _{k=1}^{7}{\frac {2^{7-k}}{k}}+\sum _{k=8}^{\infty }{\frac {1}{k2^{k-7}}}\,.} We are only interested in the fractional part of this value, so we can replace each of the summands in the "head" by 2 7 − − k k mod 1 = 2 7 − − k mod k k .

{\displaystyle {\frac {2^{7-k}}{k}}{\bmod {1}}={\frac {2^{7-k}{\bmod {k}}}{k}}\,.} Calculating each of these terms and adding them to a running total where we again only keep the fractional part, we have: k A = 2 7− k B = A mod k C = ⁠ B / k ⁠ Sum of C mod 1 1 64 0 0 0 2 32 0 0 0 3 16 1 ⁠ 1 / 3 ⁠ ⁠ 1 / 3 ⁠ 4 8 0 0 ⁠ 1 / 3 ⁠ 5 4 4 ⁠ 4 / 5 ⁠ ⁠ 2 / 15 ⁠ 6 2 2 ⁠ 1 / 3 ⁠ ⁠ 7 / 15 ⁠ 7 1 1 ⁠ 1 / 7 ⁠ ⁠ 64 / 105 ⁠ We add a few terms in the "tail", noting that the error introduced by truncating the sum is less than the final term: k D = ⁠ 1 / k 2 k −7 ⁠ Sum of D Maximum error 8 ⁠ 1 / 16 ⁠ ⁠ 1 / 16 ⁠ ⁠ 1 / 16 ⁠ 9 ⁠ 1 / 36 ⁠ ⁠ 13 / 144 ⁠ ⁠ 1 / 36 ⁠ 10 ⁠ 1 / 80 ⁠ ⁠ 37 / 360 ⁠ ⁠ 1 / 80 ⁠ Adding the "head" and the first few terms of the "tail" together we get: 2 7 ln ⁡ ⁡ ( 2 ) mod 1 ≈ ≈ 64 105 + 37 360 = 0.10011100 … … 2 + 0.00011010 … … 2 = 0.1011 … … 2 , {\displaystyle 2^{7}\ln(2){\bmod {1}}\approx {\frac {64}{105}}+{\frac {37}{360}}=0.10011100\ldots _{2}+0.00011010\ldots _{2}=0.1011\ldots _{2}\,,} so the 8th to 11th binary digits in the binary expansion of ln(2) are 1, 0, 1, 1. Note that we have not calculated the values of the first seven binary digits – indeed, all information about them has been intentionally discarded by using modular arithmetic in the "head" sum.

The same approach can be used to calculate digits of the binary expansion of ln(2) starting from an arbitrary n th position. The number of terms in the "head" sum increases linearly with n , but the complexity of each term only increases with the logarithm of n if an efficient method of modular exponentiation is used. The precision of calculations and intermediate results and the number of terms taken from the "tail" sum are all independent of n , and only depend on the number of binary digits that are being calculated – single precision arithmetic can be used to calculate around 12 binary digits, regardless of the starting position.

References [ edit ] ^ Sale, AHJ (1968).

"The calculation of e to many significant digits" .

The Computer Journal .

11 (2): 229– 230.

doi : 10.1093/comjnl/11.2.229 .

^ Abdali, S Kamal (1970).

"Special Series Summation with Arbitrary Precision" (PDF) .

Communications of the ACM .

13 (9): 570.

doi : 10.1145/362736.362756 .

^ Rabinowitz, Stanley; Wagon, Stan (1995).

"A Spigot Algorithm for the Digits of Pi" (PDF) .

American Mathematical Monthly .

102 (3): 195– 203.

doi : 10.2307/2975006 .

JSTOR 2975006 . Retrieved 8 May 2013 .

^ Gibbons, Jeremy (24 May 2004).

"Unbounded Spigot Algorithms for the Digits of Pi" (PDF) .

Further reading [ edit ] Arndt, Jorg; Haenel, Christoph, π unleashed , Springer Verlag, 2000.

Weisstein, Eric W.

"Spigot algorithm" .

MathWorld .

NewPP limit report
Parsed by mw‐web.codfw.main‐6cc77c66b8‐qgsjj
Cached time: 20250812045804
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1]
CPU time usage: 0.179 seconds
Real time usage: 0.278 seconds
Preprocessor visited node count: 1164/1000000
Revision size: 6728/2097152 bytes
Post‐expand include size: 19114/2097152 bytes
Template argument size: 931/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 1/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 30501/5000000 bytes
Lua time usage: 0.097/10.000 seconds
Lua memory usage: 4541326/52428800 bytes
Number of Wikibase entities loaded: 0/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  203.034      1 -total
 47.66%   96.763      1 Template:Reflist
 39.47%   80.143      3 Template:Cite_journal
 30.46%   61.841      1 Template:Short_description
 15.80%   32.089      2 Template:Pagetype
 10.88%   22.089     20 Template:Sfrac
  9.12%   18.509      3 Template:Main_other
  8.32%   16.900      1 Template:SDcat
  6.95%   14.119      1 Template:MathWorld
  2.79%    5.660      1 Template:SfnRef Saved in parser cache with key enwiki:pcache:1235183:|#|:idhash:canonical and timestamp 20250812045804 and revision id 1305257355. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Spigot_algorithm&oldid=1305257355 " Category : Computer arithmetic algorithms Hidden categories: Articles with short description Short description matches Wikidata This page was last edited on 11 August 2025, at 00:44 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Spigot algorithm 4 languages Add topic

