Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 History 2 Formal definition Toggle Formal definition subsection 2.1 Π type 2.2 Σ type 2.2.1 Example as existential quantification 3 Systems of the lambda cube Toggle Systems of the lambda cube subsection 3.1 First order dependent type theory 3.2 Second order dependent type theory 3.3 Higher order dependently typed polymorphic lambda calculus 4 Simultaneous programming language and logic 5 Comparison of languages with dependent types 6 See also 7 References 8 Further reading 9 External links Toggle the table of contents Dependent type 10 languages العربية 閩南語 / Bân-lâm-gí Čeština Ελληνικά Français 한국어 日本語 Русский Українська 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Type whose definition depends on a value Type systems General concepts Type safety Strong vs. weak typing Major categories Static vs.

dynamic Manifest vs.

inferred Nominal vs.

structural Duck typing Minor categories Abstract Dependent Flow-sensitive Gradual Intersection Latent Refinement Substructural Unique Session v t e In computer science and logic , a dependent type is a type whose definition depends on a value. It is an overlapping feature of type theory and type systems . In intuitionistic type theory , dependent types are used to encode logic's quantifiers like "for all" and "there exists". In functional programming languages like Agda , ATS , Rocq (previously known as Coq ), F* , Epigram , Idris , and Lean , dependent types help reduce bugs by enabling the programmer to assign types that further restrain the set of possible implementations.

Two common examples of dependent types are dependent functions and dependent pairs . The return type of a dependent function may depend on the value (not just type) of one of its arguments. For instance, a function that takes a positive integer n {\displaystyle n} may return an array of length n {\displaystyle n} , where the array length is part of the type of the array. (Note that this is different from polymorphism and generic programming , both of which include the type as an argument.) A dependent pair may have a second value, the type of which depends on the first value. Sticking with the array example, a dependent pair may be used to pair an array with its length in a type-safe way.

Dependent types add complexity to a type system. Deciding the equality of dependent types in a program may require computations. If arbitrary values are allowed in dependent types, then deciding type equality may involve deciding whether two arbitrary programs produce the same result; hence the decidability of type checking may depend on the given type theory's semantics of equality, that is, whether the type theory is intensional or extensional .

[ 1 ] History [ edit ] In 1934, Haskell Curry noticed that the types used in typed lambda calculus , and in its combinatory logic counterpart, followed the same pattern as axioms in propositional logic . Going further, for every proof in the logic, there was a matching function (term) in the programming language. One of Curry's examples was the correspondence between simply typed lambda calculus and intuitionistic logic .

[ 2 ] Predicate logic is an extension of propositional logic, adding quantifiers.

Howard and de Bruijn extended lambda calculus to match this more powerful logic by creating types for dependent functions, which correspond to "for all", and dependent pairs, which correspond to "there exists".

[ 3 ] Because of this, and other work by Howard, propositions-as-types is known as the Curry–Howard correspondence .

Formal definition [ edit ] Loosely speaking, dependent types are similar to the type of an indexed family of sets . More formally, given a type A : U {\displaystyle A:{\mathcal {U}}} in a universe of types U {\displaystyle {\mathcal {U}}} , one may have a family of types B : A → → U {\displaystyle B:A\to {\mathcal {U}}} , which assigns to each term a : A {\displaystyle a:A} a type B ( a ) : U {\displaystyle B(a):{\mathcal {U}}} . We say that the type B ( a ) {\displaystyle B(a)} varies with a {\displaystyle a} .

Π type [ edit ] A function whose type of return value varies with its argument (i.e. there is no fixed codomain ) is a dependent function and the type of this function is called dependent product type , pi-type ( Π type ) or dependent function type .

[ 4 ] From a family of types B : A → → U {\displaystyle B:A\to {\mathcal {U}}} we may construct the type of dependent functions ∏ ∏ x : A B ( x ) {\textstyle \prod _{x:A}B(x)} , whose terms are functions that take a term a : A {\displaystyle a:A} and return a term in B ( a ) {\displaystyle B(a)} . For this example, the dependent function type is typically written as ∏ ∏ x : A B ( x ) {\textstyle \prod _{x:A}B(x)} or ∏ ∏ ( x : A ) B ( x ) {\textstyle \prod {(x:A)}B(x)} .

If B : A → → U {\displaystyle B:A\to {\mathcal {U}}} is a constant function, the corresponding dependent product type is equivalent to an ordinary function type . That is, ∏ ∏ x : A B {\textstyle \prod _{x:A}B} is judgmentally equal to A → → B {\displaystyle A\to B} when B {\displaystyle B} does not depend on x {\displaystyle x} .

The name 'Π-type' comes from the idea that these may be viewed as a Cartesian product of types. Π-types can also be understood as models of universal quantifiers .

For example, if we write Vec ⁡ ⁡ ( R , n ) {\displaystyle \operatorname {Vec} (\mathbb {R} ,n)} for n -tuples of real numbers , then ∏ ∏ n : N Vec ⁡ ⁡ ( R , n ) {\textstyle \prod _{n:\mathbb {N} }\operatorname {Vec} (\mathbb {R} ,n)} would be the type of a function which, given a natural number n , returns a tuple of real numbers of size n . The usual function space arises as a special case when the range type does not actually depend on the input. E.g.

∏ ∏ n : N R {\textstyle \prod _{n:\mathbb {N} }{\mathbb {R} }} is the type of functions from natural numbers to the real numbers, which is written as N → → R {\displaystyle \mathbb {N} \to \mathbb {R} } in typed lambda calculus.

For a more concrete example, taking A {\displaystyle A} to be the type of unsigned integers from 0 to 255 (the ones that fit into 8 bits or 1 byte) and B ( a ) = X a {\displaystyle B(a)=X_{a}} for a : A {\displaystyle a:A} , then ∏ ∏ x : A B ( x ) {\textstyle \prod _{x:A}B(x)} devolves into the product of X 0 × × X 1 × × X 2 × × … … × × X 253 × × X 254 × × X 255 {\displaystyle X_{0}\times X_{1}\times X_{2}\times \ldots \times X_{253}\times X_{254}\times X_{255}} .

Σ type [ edit ] The dual of the dependent product type is the dependent pair type , dependent sum type , sigma-type , or (confusingly) dependent product type .

[ 4 ] Sigma-types can also be understood as existential quantifiers . Continuing the above example, if, in the universe of types U {\displaystyle {\mathcal {U}}} , there is a type A : U {\displaystyle A:{\mathcal {U}}} and a family of types B : A → → U {\displaystyle B:A\to {\mathcal {U}}} , then there is a dependent pair type ∑ ∑ x : A B ( x ) {\textstyle \sum _{x:A}B(x)} . (The alternative notations are similar to that of Π types.) The dependent pair type captures the idea of an ordered pair where the type of the second term is dependent on the value of the first. If ( a , b ) : ∑ ∑ x : A B ( x ) , {\textstyle (a,b):\sum _{x:A}B(x),} then a : A {\displaystyle a:A} and b : B ( a ) {\displaystyle b:B(a)} . If B {\displaystyle B} is a constant function, then the dependent pair type becomes (is judgementally equal to) the product type , that is, an ordinary Cartesian product A × × B {\displaystyle A\times B} .

[ 4 ] For a more concrete example, taking A {\displaystyle A} to again be type of unsigned integers from 0 to 255, and B ( a ) {\displaystyle B(a)} to again be equal to X a {\displaystyle X_{a}} for 256 more arbitrary X a {\displaystyle X_{a}} , then ∑ ∑ x : A B ( x ) {\textstyle \sum _{x:A}B(x)} devolves into the sum X 0 + X 1 + X 2 + … … + X 253 + X 254 + X 255 {\displaystyle X_{0}+X_{1}+X_{2}+\ldots +X_{253}+X_{254}+X_{255}} .

Example as existential quantification [ edit ] Let A : U {\displaystyle A:{\mathcal {U}}} be some type, and let B : A → → U {\displaystyle B:A\to {\mathcal {U}}} . By the Curry–Howard correspondence, B {\displaystyle B} can be interpreted as a logical predicate on terms of A {\displaystyle A} . For a given a : A {\displaystyle a:A} , whether the type B ( a ) {\displaystyle B(a)} is inhabited indicates whether a {\displaystyle a} satisfies this predicate. The correspondence can be extended to existential quantification and dependent pairs: the proposition ∃ ∃ a ∈ ∈ A B ( a ) {\displaystyle \exists {a}{\in }A\,B(a)} is true if and only if the type ∑ ∑ a : A B ( a ) {\textstyle \sum _{a:A}B(a)} is inhabited.

For example, m : N {\displaystyle m:\mathbb {N} } is less than or equal to n : N {\displaystyle n:\mathbb {N} } if and only if there exists another natural number k : N {\displaystyle k:\mathbb {N} } such that m + k = n {\displaystyle m+k=n} . In logic, this statement is codified by existential quantification: m ≤ ≤ n ⟺ ⟺ ∃ ∃ k ∈ ∈ N m + k = n .

{\displaystyle m\leq n\iff \exists {k}{\in }\mathbb {N} \,m+k=n.} This proposition corresponds to the dependent pair type: ∑ ∑ k : N m + k = n .

{\displaystyle \sum _{k:\mathbb {N} }m+k=n.} That is, a proof of the statement that m {\displaystyle m} is less than or equal to n {\displaystyle n} is a pair that contains both a non-negative number k {\displaystyle k} , which is the difference between m {\displaystyle m} and n {\displaystyle n} , and a proof of the equality m + k = n {\displaystyle m+k=n} .

Systems of the lambda cube [ edit ] Henk Barendregt developed the lambda cube as a means of classifying type systems along three axes.  The eight corners of the resulting cube-shaped diagram each correspond to a type system, with simply typed lambda calculus in the least expressive corner, and calculus of constructions in the most expressive.  The three axes of the cube correspond to three different augmentations of the simply typed lambda calculus: the addition of dependent types, the addition of polymorphism, and the addition of higher kinded type constructors (functions from types to types, for example).  The lambda cube is generalized further by pure type systems .

First order dependent type theory [ edit ] The system λ λ Π Π {\displaystyle \lambda \Pi } of pure first order dependent types, corresponding to the logical framework LF , is obtained by generalising the function space type of the simply typed lambda calculus to the dependent product type.

Second order dependent type theory [ edit ] The system λ λ Π Π 2 {\displaystyle \lambda \Pi 2} of second order dependent types is obtained from λ λ Π Π {\displaystyle \lambda \Pi } by allowing quantification over type constructors. In this theory the dependent product operator subsumes both the → → {\displaystyle \to } operator of simply typed lambda calculus and the ∀ ∀ {\displaystyle \forall } binder of System F .

Higher order dependently typed polymorphic lambda calculus [ edit ] The higher order system λ λ Π Π ω ω {\displaystyle \lambda \Pi \omega } extends λ λ Π Π 2 {\displaystyle \lambda \Pi 2} to all four forms of abstraction from the lambda cube : functions from terms to terms, types to types, terms to types and types to terms. The system corresponds to the calculus of constructions whose derivative, the calculus of inductive constructions is the underlying system of Rocq.

Simultaneous programming language and logic [ edit ] The Curry–Howard correspondence implies that types can be constructed that express arbitrarily complex mathematical properties. If the user can supply a constructive proof that a type is inhabited (i.e., that a value of that type exists) then a compiler can check the proof and convert it into executable computer code that computes the value by carrying out the construction. The proof checking feature makes dependently typed languages closely related to proof assistants . The code-generation aspect provides a powerful approach to formal program verification and proof-carrying code , since the code is derived directly from a mechanically verified mathematical proof.

Comparison of languages with dependent types [ edit ] See also: Proof assistant § Comparison Language Actively developed Paradigm [ a ] Tactics Proof terms Termination checking Types can depend on [ b ] Universes Proof irrelevance Program extraction Extraction erases irrelevant terms Agda Yes [ 5 ] Purely functional Few/limited [ c ] Yes Yes (optional) Any term Yes (optional) [ d ] Proof-irrelevant arguments [ 7 ] Proof-irrelevant propositions [ 8 ] Haskell , JavaScript Yes [ 7 ] ATS Yes [ 9 ] Functional / imperative No [ 10 ] Yes Yes Static terms [ 11 ] ?

Yes Yes Yes Cayenne No Purely functional No Yes No Any term No No ?

?

Gallina ( Rocq (previously known as Coq )) Yes [ 12 ] Purely functional Yes Yes Yes Any term Yes [ e ] Yes [ 13 ] Haskell , Scheme , OCaml Yes Dependent ML No [ f ] ?

?

Yes ?

Natural numbers ?

?

?

?

F* Yes [ 14 ] Functional and imperative Yes [ 15 ] Yes Yes (optional) Any pure term Yes Yes OCaml , F# , and C Yes Guru No [ 16 ] Purely functional [ 17 ] hypjoin [ 18 ] Yes [ 17 ] Yes Any term No Yes Carraway Yes Idris Yes [ 19 ] Purely functional [ 20 ] Yes [ 21 ] Yes Yes (optional) Any term Yes No Yes Yes [ 21 ] Lean Yes Purely functional Yes Yes Yes Any term Yes Yes Yes Yes Matita Yes [ 22 ] Purely functional Yes Yes Yes Any term Yes Yes OCaml Yes NuPRL Yes Purely functional Yes Yes Yes Any term Yes ?

Yes ?

PVS Yes ?

Yes ?

?

?

?

?

?

?

Sage Archived 2020-11-09 at the Wayback Machine No [ g ] Purely functional No No No ?

No ?

?

?

SPARK Yes [ 23 ] Imperative Yes [ 24 ] Yes [ 25 ] Yes [ 26 ] Any term [ h ] ?

?

Ada and C [ 27 ] Yes [ 28 ] Twelf Yes Logic programming ?

Yes Yes (optional) Any (LF) term No No ?

?

^ This refers to the core language, not to any tactic (theorem proving procedure ) or code generation sublanguage.

^ Subject to semantic constraints, such as universe constraints ^ Ring solver [ 6 ] ^ Optional universes, optional universe polymorphism, and optional explicitly specified universes ^ Universes, automatically inferred universe constraints (not the same as Agda's universe polymorphism) and optional explicit printing of universe constraints ^ Has been superseded by ATS ^ Last Sage paper and last code snapshot are both dated 2006 ^ Static_Predicate for restricted terms, Dynamic_Predicate for Assert-like checking of any term in type cast See also [ edit ] Typed lambda calculus Intuitionistic type theory Design by contract References [ edit ] ^ Hofmann, Martin (1995), Extensional concepts in intensional type theory (PDF) ^ Sørensen, Morten Heine B.; Urzyczyn, Pawel (1998), Lectures on the Curry-Howard Isomorphism , CiteSeerX 10.1.1.17.7385 ^ Bove, Ana; Dybjer, Peter (2008).

Dependent Types at Work (PDF) (Report). Chalmers University of Technology.

^ a b c Altenkirch, Thorsten; Danielsson, Nils Anders; Löh, Andres; Oury, Nicolas (2010).

"ΠΣ: Dependent Types without the Sugar" (PDF) . In Blume, Matthias; Kobayashi, Naoki; Vidal, Germán (eds.).

Functional and Logic Programming, 10th International Symposium, FLOPS 2010, Sendai, Japan, April 19-21, 2010. Proceedings . Lecture Notes in Computer Science. Vol. 6009. Springer. pp.

40– 55.

doi : 10.1007/978-3-642-12251-4_5 .

^ "Agda download page" .

^ "Agda Ring Solver" .

^ a b "Announce: Agda 2.2.8" . Archived from the original on 2011-07-18 . Retrieved 2010-09-28 .

^ "Agda 2.6.0 changelog" .

^ "ATS2 downloads" .

^ "email from ATS inventor Hongwei Xi" .

^ Xi, Hongwei (March 2017).

"Applied Type System: An Approach to Practical Programming with Theorem-Proving" (PDF) .

arXiv : 1703.08683 .

^ "Coq changes in Subversion repository" .

^ "Introduction of SProp in Coq 8.10" .

^ "F* changes on GitHub" .

GitHub .

^ "F* v0.9.5.0 release notes on GitHub" .

GitHub .

^ "Guru SVN" .

^ a b Aaron Stump (6 April 2009).

"Verified Programming in Guru" (PDF) . Archived from the original (PDF) on 29 December 2009 . Retrieved 28 September 2010 .

^ Petcher, Adam (May 2008).

Deciding Joinability Modulo Ground Equations in Operational Type Theory (PDF) (MSc). Washington University . Retrieved 14 October 2010 .

^ "Idris git repository" .

GitHub . 17 May 2022.

^ Brady, Edwin.

"Idris, a language with dependent types — extended abstract" (PDF) .

CiteSeerX 10.1.1.150.9442 .

^ a b Brady, Edwin.

"How does Idris compare to other dependently-typed programming languages?" .

^ "Matita SVN" . Archived from the original on 2006-05-08 . Retrieved 2010-09-29 .

^ "SPARK installation using ALIRE" .

^ "§3.2.4 Subtype Predicates" .

Ada Reference Manual (2012 ed.).

^ "5.11.6. SPARK Lemma Library" .

SPARK User's Guide (25.0 ed.).

^ "5.2.8. Contracts for Termination" .

SPARK User's Guide (25.0 ed.).

^ "1.2. Calling and Using CCG" .

GNAT Pro Common Code Generator Users's Guide Supplement (25.0 ed.).

^ "Compiling with a non-SPARK Aware Compiler" .

SPARK User's Guide (25.0 ed.).

Further reading [ edit ] Martin-Löf, Per (1984).

Intuitionistic Type Theory (PDF) . Bibliopolis.

Nordström, Bengt; Petersson, Kent; Smith, Jan M. (1990).

Programming in Martin-Löf's Type Theory: An Introduction . Oxford University Press.

ISBN 9780198538141 .

Barendregt, H. (1992).

"Lambda calculi with types" . In Abramsky, S.; Gabbay, D.; Maibaum, T. (eds.).

Handbook of Logic in Computer Science .

Oxford Science Publications .

doi : 10.1017/CBO9781139032636 .

hdl : 2066/17231 .

Brandl, Helmut (2022).

Calculus of Constructions McBride, Conor ; McKinna, James (January 2004).

"The view from the left" .

Journal of Functional Programming .

14 (1): 69– 111.

doi : 10.1017/s0956796803004829 .

S2CID 6232997 .

Altenkirch, Thorsten ; McBride, Conor ; McKinna, James (2006).

"Why dependent types matter" (PDF) .

Proceedings of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2006, Charleston, South Carolina, USA, January 11-13 .

ISBN 1-59593-027-2 .

Norell, Ulf (September 2007).

Towards a practical programming language based on dependent type theory (PDF) (PhD). Göteborg, Sweden: Department of Computer Science and Engineering, Chalmers University of Technology.

ISBN 978-91-7291-996-9 .

Oury, Nicolas; Swierstra, Wouter (2008).

"The Power of Pi" (PDF) .

ICFP '08: Proceedings of the 13th ACM SIGPLAN international conference on Functional programming . pp.

39– 50.

doi : 10.1145/1411204.1411213 .

ISBN 9781595939197 .

S2CID 16176901 .

Norell, Ulf (2009).

"Dependently Typed Programming in Agda" (PDF) . In Koopman, P.; Plasmeijer, R.; Swierstra, D. (eds.).

Advanced Functional Programming. AFP 2008 . Lecture Notes in Computer Science. Vol. 5832. Springer. pp.

230– 266.

doi : 10.1007/978-3-642-04652-0_5 .

ISBN 978-3-642-04651-3 .

Sitnikovski, Boro (2018).

Gentle Introduction to Dependent Types with Idris . Lean Publishing.

ISBN 978-1723139413 .

McBride, Conor ; Nordvall-Forsberg, Fredrik (2022).

"Type systems for programs respecting dimensions" (PDF) .

Advanced Mathematical and Computational Tools in Metrology and Testing XII . Advances in Mathematics for Applied Sciences. World Scientific. pp.

331– 345.

doi : 10.1142/9789811242380_0020 .

ISBN 9789811242380 .

S2CID 243831207 .

External links [ edit ] Dependently Typed Programming 2008 Dependently Typed Programming 2010 Dependently Typed Programming 2011 "Dependent type" at the Haskell Wiki dependent type theory at the n Lab dependent type at the n Lab dependent product type at the n Lab dependent sum type at the n Lab dependent product at the n Lab dependent sum at the n Lab v t e Major topics in Foundations of Mathematics Mathematical logic Peano axioms Mathematical induction Formal system Axiomatic system Hilbert system Natural deduction Mathematical proof Model theory Mathematical constructivism Modal logic List of mathematical logic topics Set theory Set Naive set theory Axiomatic set theory Zermelo set theory Zermelo–Fraenkel set theory Constructive set theory Descriptive set theory Determinacy Russell's paradox List of set theory topics Type theory Axiom of reducibility Simple type theory Dependent type theory Intuitionistic type theory Homotopy type theory Univalent foundations Girard's paradox Category theory Category Topos theory Category of sets Higher category theory ∞-groupoid ∞-topos theory Mathematical structuralism Glossary of category theory List of category theory topics NewPP limit report
Parsed by mw‐web.codfw.main‐6cc77c66b8‐mcvcm
Cached time: 20250812011352
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.715 seconds
Real time usage: 0.996 seconds
Preprocessor visited node count: 3326/1000000
Revision size: 26446/2097152 bytes
Post‐expand include size: 94586/2097152 bytes
Template argument size: 2235/2097152 bytes
Highest expansion depth: 9/100
Expensive parser function count: 2/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 145376/5000000 bytes
Lua time usage: 0.389/10.000 seconds
Lua memory usage: 6146762/52428800 bytes
Number of Wikibase entities loaded: 0/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  730.086      1 -total
 43.11%  314.713      2 Template:Reflist
 24.33%  177.645     23 Template:Cite_web
 11.92%   87.055      1 Template:Type_systems
 11.69%   85.360      1 Template:Sidebar
 11.51%   84.050      2 Template:Citation
  9.98%   72.854      1 Template:Short_description
  7.91%   57.714      1 Template:Sort-under
  7.50%   54.772      8 Template:Cite_book
  6.14%   44.827      2 Template:Pagetype Saved in parser cache with key enwiki:pcache:1949487:|#|:idhash:canonical and timestamp 20250812011352 and revision id 1305046478. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Dependent_type&oldid=1305046478 " Categories : Foundations of mathematics Dependently typed programming Type theory Type systems Hidden categories: Articles with short description Short description is different from Wikidata Webarchive template wayback links This page was last edited on 9 August 2025, at 18:58 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Dependent type 10 languages Add topic

