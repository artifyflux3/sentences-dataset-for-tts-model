Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 History 2 Definition Toggle Definition subsection 2.1 Definition: as m -ary function 2.2 Definition: as iterated 1-ary function 3 Computation Toggle Computation subsection 3.1 Computation by LOOP program 3.2 Computation by TRS, based on 2-ary function 3.3 Computation by TRS, based on iterated 1-ary function 3.4 Computation by TRS, based on hyperoperators 3.5 Huge numbers 4 Table of values 5 Properties Toggle Properties subsection 5.1 General remarks 5.2 Not primitive recursive 6 Inverse 7 Usage Toggle Usage subsection 7.1 In computational complexity 7.2 In discrete geometry 7.3 As a benchmark 8 See also 9 Notes 10 References 11 Bibliography 12 External links Toggle the table of contents Ackermann function 27 languages العربية Català Čeština Deutsch Español Esperanto فارسی Français Galego 한국어 Italiano עברית Lombard Magyar Nederlands 日本語 Piemontèis Polski Português Русский Српски / srpski Suomi Svenska Türkçe Українська Tiếng Việt 中文 Edit links Article Talk English Read View source View history Tools Tools move to sidebar hide Actions Read View source View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikifunctions Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Quickly growing function This article is about the mathematical function. For other uses, see Ackermann (disambiguation) .

In computability theory , the Ackermann function , named after Wilhelm Ackermann , is one of the simplest [ 1 ] and earliest-discovered examples of a total computable function that is not primitive recursive . All primitive recursive functions are total and computable, but the Ackermann function illustrates that not all total computable functions are primitive recursive.

After Ackermann's publication [ 2 ] of his function (which had three non-negative integer arguments), many authors modified it to suit various purposes, so that today "the Ackermann function" may refer to any of numerous variants of the original function. One common version is the two-argument Ackermann–Péter function developed by Rózsa Péter and Raphael Robinson . This function is defined from the recurrence relation A ⁡ ⁡ ( m + 1 , n + 1 ) = A ⁡ ⁡ ( m , A ⁡ ⁡ ( m + 1 , n ) ) {\displaystyle \operatorname {A} (m+1,n+1)=\operatorname {A} (m,\operatorname {A} (m+1,n))} with appropriate base cases . Its value grows very rapidly; for example, A ⁡ ⁡ ( 4 , 2 ) {\displaystyle \operatorname {A} (4,2)} results in 2 65536 − − 3 {\displaystyle 2^{65536}-3} , an integer with 19,729 decimal digits.

[ 3 ] History In the late 1920s, the mathematicians Gabriel Sudan and Wilhelm Ackermann , students of David Hilbert , were studying the foundations of computation. Both Sudan and Ackermann are credited [ 4 ] with discovering total computable functions (termed simply "recursive" in some references) that are not primitive recursive . Sudan published the lesser-known Sudan function , then shortly afterwards and independently, in 1928, Ackermann published his function φ φ {\displaystyle \varphi } (from Greek, the letter phi ). Ackermann's three-argument function, φ φ ( m , n , p ) {\displaystyle \varphi (m,n,p)} , is defined such that for p = 0 , 1 , 2 {\displaystyle p=0,1,2} , it reproduces the basic operations of addition , multiplication , and exponentiation as φ φ ( m , n , 0 ) = m + n φ φ ( m , n , 1 ) = m × × n φ φ ( m , n , 2 ) = m n {\displaystyle {\begin{aligned}\varphi (m,n,0)&=m+n\\\varphi (m,n,1)&=m\times n\\\varphi (m,n,2)&=m^{n}\end{aligned}}} and for p > 2 {\displaystyle p>2} it extends these basic operations in a way that can be compared to the hyperoperations : φ φ ( m , n , 3 ) = m [ 4 ] ( n + 1 ) φ φ ( m , n , p ) ⪆ ⪆ m [ p + 1 ] ( n + 1 ) for p > 3 {\displaystyle {\begin{aligned}\varphi (m,n,3)&=m[4](n+1)\\\varphi (m,n,p)&\gtrapprox m[p+1](n+1)&&{\text{for }}p>3\end{aligned}}} (Aside from its historic role as a total-computable-but-not-primitive-recursive function, Ackermann's original function is seen to extend the basic arithmetic operations beyond exponentiation, although not as seamlessly as do variants of Ackermann's function that are specifically designed for that purpose—such as Goodstein's hyperoperation sequence.) In On the Infinite , [ 5 ] David Hilbert hypothesized that the Ackermann function was not primitive recursive, but it was Ackermann, Hilbert's personal secretary and former student, who actually proved the hypothesis in his paper On Hilbert's Construction of the Real Numbers .

[ 2 ] [ 6 ] Rózsa Péter [ 7 ] and Raphael Robinson [ 8 ] later developed a two-variable version of the Ackermann function that became preferred by almost all authors.

The generalized hyperoperation sequence , e.g.

G ( m , a , b ) = a [ m ] b {\displaystyle G(m,a,b)=a[m]b} , is a version of the Ackermann function as well.

[ 9 ] In 1963 R.C. Buck based an intuitive two-variable [ n 1 ] variant F {\displaystyle \operatorname {F} } on the hyperoperation sequence : [ 10 ] [ 11 ] F ⁡ ⁡ ( m , n ) = 2 [ m ] n .

{\displaystyle \operatorname {F} (m,n)=2[m]n.} Compared to most other versions, Buck's function has no unessential offsets: F ⁡ ⁡ ( 0 , n ) = 2 [ 0 ] n = n + 1 F ⁡ ⁡ ( 1 , n ) = 2 [ 1 ] n = 2 + n F ⁡ ⁡ ( 2 , n ) = 2 [ 2 ] n = 2 × × n F ⁡ ⁡ ( 3 , n ) = 2 [ 3 ] n = 2 n F ⁡ ⁡ ( 4 , n ) = 2 [ 4 ] n = 2 2 2 .

.

.

2 ⋮ ⋮ {\displaystyle {\begin{aligned}\operatorname {F} (0,n)&=2[0]n=n+1\\\operatorname {F} (1,n)&=2[1]n=2+n\\\operatorname {F} (2,n)&=2[2]n=2\times n\\\operatorname {F} (3,n)&=2[3]n=2^{n}\\\operatorname {F} (4,n)&=2[4]n=2^{2^{2^{{}^{.^{.^{{}_{.}2}}}}}}\\&\quad \vdots \end{aligned}}} Many other versions of Ackermann function have been investigated.

[ 12 ] [ 13 ] Definition Definition: as m -ary function Ackermann's original three-argument function φ φ ( m , n , p ) {\displaystyle \varphi (m,n,p)} is defined recursively as follows for nonnegative integers m , n , {\displaystyle m,n,} and p {\displaystyle p} : φ φ ( m , n , 0 ) = m + n φ φ ( m , 0 , 1 ) = 0 φ φ ( m , 0 , 2 ) = 1 φ φ ( m , 0 , p ) = m for p > 2 φ φ ( m , n , p ) = φ φ ( m , φ φ ( m , n − − 1 , p ) , p − − 1 ) for n , p > 0 {\displaystyle {\begin{aligned}\varphi (m,n,0)&=m+n\\\varphi (m,0,1)&=0\\\varphi (m,0,2)&=1\\\varphi (m,0,p)&=m&&{\text{for }}p>2\\\varphi (m,n,p)&=\varphi (m,\varphi (m,n-1,p),p-1)&&{\text{for }}n,p>0\end{aligned}}} Of the various two-argument versions, the one developed by Péter and Robinson (called "the" Ackermann function by most authors) is defined for nonnegative integers m {\displaystyle m} and n {\displaystyle n} as follows: A ⁡ ⁡ ( 0 , n ) = n + 1 A ⁡ ⁡ ( m + 1 , 0 ) = A ⁡ ⁡ ( m , 1 ) A ⁡ ⁡ ( m + 1 , n + 1 ) = A ⁡ ⁡ ( m , A ⁡ ⁡ ( m + 1 , n ) ) {\displaystyle {\begin{array}{lcl}\operatorname {A} (0,n)&=&n+1\\\operatorname {A} (m+1,0)&=&\operatorname {A} (m,1)\\\operatorname {A} (m+1,n+1)&=&\operatorname {A} (m,\operatorname {A} (m+1,n))\end{array}}} The Ackermann function has also been expressed in relation to the hyperoperation sequence : [ 14 ] [ 15 ] A ( m , n ) = { n + 1 m = 0 2 [ m ] ( n + 3 ) − − 3 m > 0 {\displaystyle A(m,n)={\begin{cases}n+1&m=0\\2[m](n+3)-3&m>0\\\end{cases}}} or, written in Knuth's up-arrow notation (extended to integer indices ≥ ≥ − − 2 {\displaystyle \geq -2} ): A ( m , n ) = { n + 1 m = 0 2 ↑ ↑ m − − 2 ( n + 3 ) − − 3 m > 0 {\displaystyle A(m,n)={\begin{cases}n+1&m=0\\2\uparrow ^{m-2}(n+3)-3&m>0\\\end{cases}}} or, equivalently, in terms of Buck's function F: [ 10 ] A ( m , n ) = { n + 1 m = 0 F ( m , n + 3 ) − − 3 m > 0 {\displaystyle A(m,n)={\begin{cases}n+1&m=0\\F(m,n+3)-3&m>0\\\end{cases}}} By induction on m {\displaystyle m} , one can show that F ( m , n ) ≤ ≤ A ( m , n ) {\displaystyle F(m,n)\leq A(m,n)} for all m , n ∈ ∈ N 0 {\displaystyle m,n\in \mathbb {N} _{0}} .

Definition: as iterated 1-ary function Define f n {\displaystyle f^{n}} as the n -th iterate of f {\displaystyle f} : f 0 ( x ) = x f n + 1 ( x ) = f ( f n ( x ) ) {\displaystyle {\begin{array}{rll}f^{0}(x)&=&x\\f^{n+1}(x)&=&f(f^{n}(x))\end{array}}} Iteration is the process of composing a function with itself a certain number of times.

Function composition is an associative operation, so f ( f n ( x ) ) = f n ( f ( x ) ) {\displaystyle f(f^{n}(x))=f^{n}(f(x))} .

Conceiving the Ackermann function as a sequence of unary functions, one can set A m ⁡ ⁡ ( n ) = A ⁡ ⁡ ( m , n ) {\displaystyle \operatorname {A} _{m}(n)=\operatorname {A} (m,n)} .

The function then becomes a sequence A 0 , A 1 , A 2 , .

.

.

{\displaystyle \operatorname {A} _{0},\operatorname {A} _{1},\operatorname {A} _{2},...} of unary [ n 2 ] functions, defined from iteration : A 0 ⁡ ⁡ ( n ) = n + 1 A m + 1 ⁡ ⁡ ( n ) = A m n + 1 ⁡ ⁡ ( 1 ) .

{\displaystyle {\begin{array}{lcl}\operatorname {A} _{0}(n)&=&n+1\\\operatorname {A} _{m+1}(n)&=&\operatorname {A} _{m}^{n+1}(1)\,.\end{array}}} Computation Computation by LOOP program The functions A i {\displaystyle \operatorname {A} _{i}} fit into the (finite-level) fast-growing hierarchy (FGH) of functions [ 16 ] FGH 0 ⁡ ⁡ ( n ) = n + 1 FGH m + 1 ⁡ ⁡ ( n ) = FGH m n ⁡ ⁡ ( n ) .

{\displaystyle {\begin{array}{lcl}\operatorname {FGH} _{0}(n)&=&n+1\\\operatorname {FGH} _{m+1}(n)&=&\operatorname {FGH} _{m}^{n}(n)\,.\end{array}}} The following inequality holds: [ 17 ] ∀ ∀ m > 1 , ∀ ∀ n > 1 : A m ⁡ ⁡ ( n ) < FGH m ⁡ ⁡ ( n ) {\displaystyle \forall m>1,\forall n>1:\operatorname {A} _{m}(n)<\operatorname {FGH} _{m}(n)} For fixed k {\displaystyle k} , the function FGH k ⁡ ⁡ ( n ) {\displaystyle \operatorname {FGH} _{k}(n)} can be computed by a LOOP program of nesting depth k {\displaystyle k} : [ 18 ] # INPUT (n) LOOP n : # nesting depth: 1 LOOP n : # nesting depth: 2 ...

# ...

LOOP n : # nesting depth: k n += 1 # # OUTPUT (n) The function A k ⁡ ⁡ ( n ) {\displaystyle \operatorname {A} _{k}(n)} can also be computed by a LOOP-k program.

[ 19 ] (The program (schema) is not listed here.) It is obvious that A ⁡ ⁡ ( m , n ) {\displaystyle \operatorname {A} (m,n)} , not being a primitive recursive function —see below—, cannot be computed by a LOOP program.

Computation by TRS, based on 2-ary function The recursive definition of the Ackermann function can naturally be transposed to a term rewriting system (TRS) .

The definition of the 2-ary Ackermann function leads to the obvious reduction rules [ 20 ] [ 21 ] (r1) A ( 0 , n ) → → S ( n ) (r2) A ( S ( m ) , 0 ) → → A ( m , S ( 0 ) ) (r3) A ( S ( m ) , S ( n ) ) → → A ( m , A ( S ( m ) , n ) ) {\displaystyle {\begin{array}{lll}{\text{(r1)}}&A(0,n)&\rightarrow &S(n)\\{\text{(r2)}}&A(S(m),0)&\rightarrow &A(m,S(0))\\{\text{(r3)}}&A(S(m),S(n))&\rightarrow &A(m,A(S(m),n))\end{array}}} Example Compute A ( 1 , 2 ) → → ∗ ∗ 4 {\displaystyle A(1,2)\rightarrow _{*}4} The reduction sequence is [ n 3 ] Leftmost-outermost (one-step) strategy : Leftmost-innermost (one-step) strategy : A ( S ( 0 ) , S ( S ( 0 ) ) ) _ _ {\displaystyle {\underline {A(S(0),S(S(0)))}}} A ( S ( 0 ) , S ( S ( 0 ) ) ) _ _ {\displaystyle {\underline {A(S(0),S(S(0)))}}} → → r 3 A ( 0 , A ( S ( 0 ) , S ( 0 ) ) _ _ ) {\displaystyle \rightarrow _{r3}{\underline {A(0,A(S(0),S(0))}})} → → r 3 A ( 0 , A ( S ( 0 ) , S ( 0 ) ) _ _ ) {\displaystyle \rightarrow _{r3}A(0,{\underline {A(S(0),S(0))}})} → → r 1 S ( A ( S ( 0 ) , S ( 0 ) ) _ _ ) {\displaystyle \rightarrow _{r1}S({\underline {A(S(0),S(0))}})} → → r 3 A ( 0 , A ( 0 , A ( S ( 0 ) , 0 ) _ _ ) ) {\displaystyle \rightarrow _{r3}A(0,A(0,{\underline {A(S(0),0)}}))} → → r 3 S ( A ( 0 , A ( S 0 , 0 ) ) _ _ ) {\displaystyle \rightarrow _{r3}S({\underline {A(0,A(S0,0))}})} → → r 2 A ( 0 , A ( 0 , A ( 0 , S ( 0 ) ) _ _ ) ) {\displaystyle \rightarrow _{r2}A(0,A(0,{\underline {A(0,S(0))}}))} → → r 1 S ( S ( A ( S ( 0 ) , 0 ) _ _ ) ) {\displaystyle \rightarrow _{r1}S(S({\underline {A(S(0),0)}}))} → → r 1 A ( 0 , A ( 0 , S ( S ( 0 ) ) ) _ _ ) {\displaystyle \rightarrow _{r1}A(0,{\underline {A(0,S(S(0)))}})} → → r 2 S ( S ( A ( 0 , S ( 0 ) ) _ _ ) ) {\displaystyle \rightarrow _{r2}S(S({\underline {A(0,S(0))}}))} → → r 1 A ( 0 , S ( S ( S ( 0 ) ) ) ) _ _ {\displaystyle \rightarrow _{r1}{\underline {A(0,S(S(S(0))))}}} → → r 1 S ( S ( S ( S ( 0 ) ) ) ) {\displaystyle \rightarrow _{r1}S(S(S(S(0))))} → → r 1 S ( S ( S ( S ( 0 ) ) ) ) {\displaystyle \rightarrow _{r1}S(S(S(S(0))))} To compute A ⁡ ⁡ ( m , n ) {\displaystyle \operatorname {A} (m,n)} one can use a stack , which initially contains the elements ⟨ ⟨ m , n ⟩ ⟩ {\displaystyle \langle m,n\rangle } .

Then repeatedly the two top elements are replaced according to the rules [ n 4 ] (r1) 0 , n → → ( n + 1 ) (r2) ( m + 1 ) , 0 → → m , 1 (r3) ( m + 1 ) , ( n + 1 ) → → m , ( m + 1 ) , n {\displaystyle {\begin{array}{lllllllll}{\text{(r1)}}&0&,&n&\rightarrow &(n+1)\\{\text{(r2)}}&(m+1)&,&0&\rightarrow &m&,&1\\{\text{(r3)}}&(m+1)&,&(n+1)&\rightarrow &m&,&(m+1)&,&n\end{array}}} Schematically, starting from ⟨ ⟨ m , n ⟩ ⟩ {\displaystyle \langle m,n\rangle } : WHILE stackLength <> 1
{ POP 2 elements; PUSH 1 or 2 or 3 elements, applying the rules r1, r2, r3
} The pseudocode is published in Grossman & Zeitman (1988) .

For example, on input ⟨ ⟨ 2 , 1 ⟩ ⟩ {\displaystyle \langle 2,1\rangle } , the stack configurations reflect the reduction [ n 5 ] 2 , 1 _ _ {\displaystyle {\underline {2,1}}} A ( 2 , 1 ) _ _ {\displaystyle {\underline {A(2,1)}}} → → 1 , 2 , 0 _ _ {\displaystyle \rightarrow 1,{\underline {2,0}}} → → r 1 A ( 1 , A ( 2 , 0 ) _ _ ) {\displaystyle \rightarrow _{r1}A(1,{\underline {A(2,0)}})} → → 1 , 1 , 1 _ _ {\displaystyle \rightarrow 1,{\underline {1,1}}} → → r 2 A ( 1 , A ( 1 , 1 ) _ _ ) {\displaystyle \rightarrow _{r2}A(1,{\underline {A(1,1)}})} → → 1 , 0 , 1 , 0 _ _ {\displaystyle \rightarrow 1,0,{\underline {1,0}}} → → r 3 A ( 1 , A ( 0 , A ( 1 , 0 ) _ _ ) ) {\displaystyle \rightarrow _{r3}A(1,A(0,{\underline {A(1,0)}}))} → → 1 , 0 , 0 , 1 _ _ {\displaystyle \rightarrow 1,0,{\underline {0,1}}} → → r 2 A ( 1 , A ( 0 , A ( 0 , 1 ) _ _ ) ) {\displaystyle \rightarrow _{r2}A(1,A(0,{\underline {A(0,1)}}))} → → 1 , 0 , 2 _ _ {\displaystyle \rightarrow 1,{\underline {0,2}}} → → r 1 A ( 1 , A ( 0 , 2 ) _ _ ) {\displaystyle \rightarrow _{r1}A(1,{\underline {A(0,2)}})} → → 1 , 3 _ _ {\displaystyle \rightarrow {\underline {1,3}}} → → r 1 A ( 1 , 3 ) _ _ {\displaystyle \rightarrow _{r1}{\underline {A(1,3)}}} → → 0 , 1 , 2 _ _ {\displaystyle \rightarrow 0,{\underline {1,2}}} → → r 3 A ( 0 , A ( 1 , 2 ) _ _ ) {\displaystyle \rightarrow _{r3}A(0,{\underline {A(1,2)}})} → → 0 , 0 , 1 , 1 _ _ {\displaystyle \rightarrow 0,0,{\underline {1,1}}} → → r 3 A ( 0 , A ( 0 , A ( 1 , 1 ) _ _ ) ) {\displaystyle \rightarrow _{r3}A(0,A(0,{\underline {A(1,1)}}))} → → 0 , 0 , 0 , 1 , 0 _ _ {\displaystyle \rightarrow 0,0,0,{\underline {1,0}}} → → r 3 A ( 0 , A ( 0 , A ( 0 , A ( 1 , 0 ) _ _ ) ) ) {\displaystyle \rightarrow _{r3}A(0,A(0,A(0,{\underline {A(1,0)}})))} → → 0 , 0 , 0 , 0 , 1 _ _ {\displaystyle \rightarrow 0,0,0,{\underline {0,1}}} → → r 2 A ( 0 , A ( 0 , A ( 0 , A ( 0 , 1 ) _ _ ) ) ) {\displaystyle \rightarrow _{r2}A(0,A(0,A(0,{\underline {A(0,1)}})))} → → 0 , 0 , 0 , 2 _ _ {\displaystyle \rightarrow 0,0,{\underline {0,2}}} → → r 1 A ( 0 , A ( 0 , A ( 0 , 2 ) _ _ ) ) {\displaystyle \rightarrow _{r1}A(0,A(0,{\underline {A(0,2)}}))} → → 0 , 0 , 3 _ _ {\displaystyle \rightarrow 0,{\underline {0,3}}} → → r 1 A ( 0 , A ( 0 , 3 ) _ _ ) {\displaystyle \rightarrow _{r1}A(0,{\underline {A(0,3)}})} → → 0 , 4 _ _ {\displaystyle \rightarrow {\underline {0,4}}} → → r 1 A ( 0 , 4 ) _ _ {\displaystyle \rightarrow _{r1}{\underline {A(0,4)}}} → → 5 {\displaystyle \rightarrow 5} → → r 1 5 {\displaystyle \rightarrow _{r1}5} Remarks The leftmost-innermost strategy is implemented in 225 computer languages on Rosetta Code .

For all m , n {\displaystyle m,n} the computation of A ( m , n ) {\displaystyle A(m,n)} takes no more than ( A ( m , n ) + 1 ) m {\displaystyle (A(m,n)+1)^{m}} steps.

[ 22 ] Grossman & Zeitman (1988) pointed out that in the computation of A ⁡ ⁡ ( m , n ) {\displaystyle \operatorname {A} (m,n)} the maximum length of the stack is A ⁡ ⁡ ( m , n ) {\displaystyle \operatorname {A} (m,n)} , as long as m > 0 {\displaystyle m>0} .

Their own algorithm, inherently iterative, computes A ⁡ ⁡ ( m , n ) {\displaystyle \operatorname {A} (m,n)} within O ( m A ⁡ ⁡ ( m , n ) ) {\displaystyle {\mathcal {O}}(m\operatorname {A} (m,n))} time and within O ( m ) {\displaystyle {\mathcal {O}}(m)} space.

Computation by TRS, based on iterated 1-ary function The definition of the iterated 1-ary Ackermann functions leads to different reduction rules (r4) A ( S ( 0 ) , 0 , n ) → → S ( n ) (r5) A ( S ( 0 ) , S ( m ) , n ) → → A ( S ( n ) , m , S ( 0 ) ) (r6) A ( S ( S ( x ) ) , m , n ) → → A ( S ( 0 ) , m , A ( S ( x ) , m , n ) ) {\displaystyle {\begin{array}{lll}{\text{(r4)}}&A(S(0),0,n)&\rightarrow &S(n)\\{\text{(r5)}}&A(S(0),S(m),n)&\rightarrow &A(S(n),m,S(0))\\{\text{(r6)}}&A(S(S(x)),m,n)&\rightarrow &A(S(0),m,A(S(x),m,n))\end{array}}} As function composition is associative, instead of rule r6 one can define (r7) A ( S ( S ( x ) ) , m , n ) → → A ( S ( x ) , m , A ( S ( 0 ) , m , n ) ) {\displaystyle {\begin{array}{lll}{\text{(r7)}}&A(S(S(x)),m,n)&\rightarrow &A(S(x),m,A(S(0),m,n))\end{array}}} Like in the previous section the computation of A m 1 ⁡ ⁡ ( n ) {\displaystyle \operatorname {A} _{m}^{1}(n)} can be implemented with a stack.

Initially the stack contains the three elements ⟨ ⟨ 1 , m , n ⟩ ⟩ {\displaystyle \langle 1,m,n\rangle } .

Then repeatedly the three top elements are replaced according to the rules [ n 4 ] (r4) 1 , 0 , n → → ( n + 1 ) (r5) 1 , ( m + 1 ) , n → → ( n + 1 ) , m , 1 (r6) ( x + 2 ) , m , n → → 1 , m , ( x + 1 ) , m , n {\displaystyle {\begin{array}{lllllllll}{\text{(r4)}}&1&,0&,n&\rightarrow &(n+1)\\{\text{(r5)}}&1&,(m+1)&,n&\rightarrow &(n+1)&,m&,1\\{\text{(r6)}}&(x+2)&,m&,n&\rightarrow &1&,m&,(x+1)&,m&,n\\\end{array}}} Schematically, starting from ⟨ ⟨ 1 , m , n ⟩ ⟩ {\displaystyle \langle 1,m,n\rangle } : WHILE stackLength <> 1
{ POP 3 elements; PUSH 1 or 3 or 5 elements, applying the rules r4, r5, r6;
} Example On input ⟨ ⟨ 1 , 2 , 1 ⟩ ⟩ {\displaystyle \langle 1,2,1\rangle } the successive stack configurations are 1 , 2 , 1 _ _ → → r 5 2 , 1 , 1 _ _ → → r 6 1 , 1 , 1 , 1 , 1 _ _ → → r 5 1 , 1 , 2 , 0 , 1 _ _ → → r 6 1 , 1 , 1 , 0 , 1 , 0 , 1 _ _ → → r 4 1 , 1 , 1 , 0 , 2 _ _ → → r 4 1 , 1 , 3 _ _ → → r 5 4 , 0 , 1 _ _ → → r 6 1 , 0 , 3 , 0 , 1 _ _ → → r 6 1 , 0 , 1 , 0 , 2 , 0 , 1 _ _ → → r 6 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 _ _ → → r 4 1 , 0 , 1 , 0 , 1 , 0 , 2 _ _ → → r 4 1 , 0 , 1 , 0 , 3 _ _ → → r 4 1 , 0 , 4 _ _ → → r 4 5 {\displaystyle {\begin{aligned}&{\underline {1,2,1}}\rightarrow _{r5}{\underline {2,1,1}}\rightarrow _{r6}1,1,{\underline {1,1,1}}\rightarrow _{r5}1,1,{\underline {2,0,1}}\rightarrow _{r6}1,1,1,0,{\underline {1,0,1}}\\&\rightarrow _{r4}1,1,{\underline {1,0,2}}\rightarrow _{r4}{\underline {1,1,3}}\rightarrow _{r5}{\underline {4,0,1}}\rightarrow _{r6}1,0,{\underline {3,0,1}}\rightarrow _{r6}1,0,1,0,{\underline {2,0,1}}\\&\rightarrow _{r6}1,0,1,0,1,0,{\underline {1,0,1}}\rightarrow _{r4}1,0,1,0,{\underline {1,0,2}}\rightarrow _{r4}1,0,{\underline {1,0,3}}\rightarrow _{r4}{\underline {1,0,4}}\rightarrow _{r4}5\end{aligned}}} The corresponding equalities are A 2 ( 1 ) = A 1 2 ( 1 ) = A 1 ( A 1 ( 1 ) ) = A 1 ( A 0 2 ( 1 ) ) = A 1 ( A 0 ( A 0 ( 1 ) ) ) = A 1 ( A 0 ( 2 ) ) = A 1 ( 3 ) = A 0 4 ( 1 ) = A 0 ( A 0 3 ( 1 ) ) = A 0 ( A 0 ( A 0 2 ( 1 ) ) ) = A 0 ( A 0 ( A 0 ( A 0 ( 1 ) ) ) ) = A 0 ( A 0 ( A 0 ( 2 ) ) ) = A 0 ( A 0 ( 3 ) ) = A 0 ( 4 ) = 5 {\displaystyle {\begin{aligned}&A_{2}(1)=A_{1}^{2}(1)=A_{1}(A_{1}(1))=A_{1}(A_{0}^{2}(1))=A_{1}(A_{0}(A_{0}(1)))\\&=A_{1}(A_{0}(2))=A_{1}(3)=A_{0}^{4}(1)=A_{0}(A_{0}^{3}(1))=A_{0}(A_{0}(A_{0}^{2}(1)))\\&=A_{0}(A_{0}(A_{0}(A_{0}(1))))=A_{0}(A_{0}(A_{0}(2)))=A_{0}(A_{0}(3))=A_{0}(4)=5\end{aligned}}} When reduction rule r7 is used instead of rule r6, the replacements in the stack will follow (r7) ( x + 2 ) , m , n → → ( x + 1 ) , m , 1 , m , n {\displaystyle {\begin{array}{lllllllll}{\text{(r7)}}&(x+2)&,m&,n&\rightarrow &(x+1)&,m&,1&,m&,n\end{array}}} The successive stack configurations will then be 1 , 2 , 1 _ _ → → r 5 2 , 1 , 1 _ _ → → r 7 1 , 1 , 1 , 1 , 1 _ _ → → r 5 1 , 1 , 2 , 0 , 1 _ _ → → r 7 1 , 1 , 1 , 0 , 1 , 0 , 1 _ _ → → r 4 1 , 1 , 1 , 0 , 2 _ _ → → r 4 1 , 1 , 3 _ _ → → r 5 4 , 0 , 1 _ _ → → r 7 3 , 0 , 1 , 0 , 1 _ _ → → r 4 3 , 0 , 2 _ _ → → r 7 2 , 0 , 1 , 0 , 2 _ _ → → r 4 2 , 0 , 3 _ _ → → r 7 1 , 0 , 1 , 0 , 3 _ _ → → r 4 1 , 0 , 4 _ _ → → r 4 5 {\displaystyle {\begin{aligned}&{\underline {1,2,1}}\rightarrow _{r5}{\underline {2,1,1}}\rightarrow _{r7}1,1,{\underline {1,1,1}}\rightarrow _{r5}1,1,{\underline {2,0,1}}\rightarrow _{r7}1,1,1,0,{\underline {1,0,1}}\\&\rightarrow _{r4}1,1,{\underline {1,0,2}}\rightarrow _{r4}{\underline {1,1,3}}\rightarrow _{r5}{\underline {4,0,1}}\rightarrow _{r7}3,0,{\underline {1,0,1}}\rightarrow _{r4}{\underline {3,0,2}}\\&\rightarrow _{r7}2,0,{\underline {1,0,2}}\rightarrow _{r4}{\underline {2,0,3}}\rightarrow _{r7}1,0,{\underline {1,0,3}}\rightarrow _{r4}{\underline {1,0,4}}\rightarrow _{r4}5\end{aligned}}} The corresponding equalities are A 2 ( 1 ) = A 1 2 ( 1 ) = A 1 ( A 1 ( 1 ) ) = A 1 ( A 0 2 ( 1 ) ) = A 1 ( A 0 ( A 0 ( 1 ) ) ) = A 1 ( A 0 ( 2 ) ) = A 1 ( 3 ) = A 0 4 ( 1 ) = A 0 3 ( A 0 ( 1 ) ) = A 0 3 ( 2 ) = A 0 2 ( A 0 ( 2 ) ) = A 0 2 ( 3 ) = A 0 ( A 0 ( 3 ) ) = A 0 ( 4 ) = 5 {\displaystyle {\begin{aligned}&A_{2}(1)=A_{1}^{2}(1)=A_{1}(A_{1}(1))=A_{1}(A_{0}^{2}(1))=A_{1}(A_{0}(A_{0}(1)))\\&=A_{1}(A_{0}(2))=A_{1}(3)=A_{0}^{4}(1)=A_{0}^{3}(A_{0}(1))=A_{0}^{3}(2)\\&=A_{0}^{2}(A_{0}(2))=A_{0}^{2}(3)=A_{0}(A_{0}(3))=A_{0}(4)=5\end{aligned}}} Remarks On any given input the TRSs presented so far converge in the same number of steps. They also use the same reduction rules (in this comparison the rules r1, r2, r3 are considered "the same as" the rules r4, r5, r6/r7 respectively). For example, the reduction of A ( 2 , 1 ) {\displaystyle A(2,1)} converges in 14 steps: 6 × r1, 3 × r2, 5 × r3. The reduction of A 2 ( 1 ) {\displaystyle A_{2}(1)} converges in the same 14 steps: 6 × r4, 3 × r5, 5 × r6/r7. The TRSs differ in the order in which the reduction rules are applied.

When A i ( n ) {\displaystyle A_{i}(n)} is computed following the rules {r4, r5, r6}, the maximum length of the stack stays below 2 × × A ( i , n ) {\displaystyle 2\times A(i,n)} . When reduction rule r7 is used instead of rule r6, the maximum length of the stack is only 2 ( i + 2 ) {\displaystyle 2(i+2)} . The length of the stack reflects the recursion depth. As the reduction according to the rules {r4, r5, r7} involves a smaller maximum depth of recursion, [ n 6 ] this computation is more efficient in that respect.

Computation by TRS, based on hyperoperators As Sundblad (1971) — or Porto & Matos (1980) — showed explicitly, the Ackermann function can be expressed in terms of the hyperoperation sequence: A ( m , n ) = { n + 1 m = 0 2 [ m ] ( n + 3 ) − − 3 m > 0 {\displaystyle A(m,n)={\begin{cases}n+1&m=0\\2[m](n+3)-3&m>0\\\end{cases}}} or, after removal of the constant 2 from the parameter list, in terms of Buck's function A ( m , n ) = { n + 1 m = 0 F ( m , n + 3 ) − − 3 m > 0 {\displaystyle A(m,n)={\begin{cases}n+1&m=0\\F(m,n+3)-3&m>0\\\end{cases}}} Buck's function F ⁡ ⁡ ( m , n ) = 2 [ m ] n {\displaystyle \operatorname {F} (m,n)=2[m]n} , [ 10 ] a variant of Ackermann function by itself, can be computed with the following reduction rules: (b1) F ( S ( 0 ) , 0 , n ) → → S ( n ) (b2) F ( S ( 0 ) , S ( 0 ) , 0 ) → → S ( S ( 0 ) ) (b3) F ( S ( 0 ) , S ( S ( 0 ) ) , 0 ) → → 0 (b4) F ( S ( 0 ) , S ( S ( S ( m ) ) ) , 0 ) → → S ( 0 ) (b5) F ( S ( 0 ) , S ( m ) , S ( n ) ) → → F ( S ( n ) , m , F ( S ( 0 ) , S ( m ) , 0 ) ) (b6) F ( S ( S ( x ) ) , m , n ) → → F ( S ( 0 ) , m , F ( S ( x ) , m , n ) ) {\displaystyle {\begin{array}{lll}{\text{(b1)}}&F(S(0),0,n)&\rightarrow &S(n)\\{\text{(b2)}}&F(S(0),S(0),0)&\rightarrow &S(S(0))\\{\text{(b3)}}&F(S(0),S(S(0)),0)&\rightarrow &0\\{\text{(b4)}}&F(S(0),S(S(S(m))),0)&\rightarrow &S(0)\\{\text{(b5)}}&F(S(0),S(m),S(n))&\rightarrow &F(S(n),m,F(S(0),S(m),0))\\{\text{(b6)}}&F(S(S(x)),m,n)&\rightarrow &F(S(0),m,F(S(x),m,n))\end{array}}} Instead of rule b6 one can define the rule (b7) F ( S ( S ( x ) ) , m , n ) → → F ( S ( x ) , m , F ( S ( 0 ) , m , n ) ) {\displaystyle {\begin{array}{lll}{\text{(b7)}}&F(S(S(x)),m,n)&\rightarrow &F(S(x),m,F(S(0),m,n))\end{array}}} To compute the Ackermann function it suffices to add three reduction rules (r8) A ( 0 , n ) → → S ( n ) (r9) A ( S ( m ) , n ) → → P ( F ( S ( 0 ) , S ( m ) , S ( S ( S ( n ) ) ) ) ) (r10) P ( S ( S ( S ( m ) ) ) ) → → m {\displaystyle {\begin{array}{lll}{\text{(r8)}}&A(0,n)&\rightarrow &S(n)\\{\text{(r9)}}&A(S(m),n)&\rightarrow &P(F(S(0),S(m),S(S(S(n)))))\\{\text{(r10)}}&P(S(S(S(m))))&\rightarrow &m\\\end{array}}} These rules take care of the base case A(0,n), the alignment (n+3) and the fudge (-3).

Example Compute A ( 2 , 1 ) → → ∗ ∗ 5 {\displaystyle A(2,1)\rightarrow _{*}5} using reduction rule b7 {\displaystyle {\text{b7}}} : [ n 5 ] using reduction rule b6 {\displaystyle {\text{b6}}} : [ n 5 ] A ( 2 , 1 ) _ _ {\displaystyle {\underline {A(2,1)}}} A ( 2 , 1 ) _ _ {\displaystyle {\underline {A(2,1)}}} → → r 9 P ( F ( 1 , 2 , 4 ) _ _ ) {\displaystyle \rightarrow _{r9}P({\underline {F(1,2,4)}})} → → r 9 P ( F ( 1 , 2 , 4 ) _ _ ) {\displaystyle \rightarrow _{r9}P({\underline {F(1,2,4)}})} → → b 5 P ( F ( 4 , 1 , F ( 1 , 2 , 0 ) _ _ ) ) {\displaystyle \rightarrow _{b5}P(F(4,1,{\underline {F(1,2,0)}}))} → → b 5 P ( F ( 4 , 1 , F ( 1 , 2 , 0 ) _ _ ) ) {\displaystyle \rightarrow _{b5}P(F(4,1,{\underline {F(1,2,0)}}))} → → b 3 P ( F ( 4 , 1 , 0 ) _ _ ) {\displaystyle \rightarrow _{b3}P({\underline {F(4,1,0)}})} → → b 3 P ( F ( 4 , 1 , 0 ) _ _ ) {\displaystyle \rightarrow _{b3}P({\underline {F(4,1,0)}})} → → b 7 P ( F ( 3 , 1 , F ( 1 , 1 , 0 ) _ _ ) ) {\displaystyle \rightarrow _{b7}P(F(3,1,{\underline {F(1,1,0)}}))} → → b 6 P ( F ( 1 , 1 , F ( 3 , 1 , 0 ) _ _ ) ) {\displaystyle \rightarrow _{b6}P(F(1,1,{\underline {F(3,1,0)}}))} → → b 2 P ( F ( 3 , 1 , 2 ) _ _ ) {\displaystyle \rightarrow _{b2}P({\underline {F(3,1,2)}})} → → b 6 P ( F ( 1 , 1 , F ( 1 , 1 , F ( 2 , 1 , 0 ) _ _ ) ) ) {\displaystyle \rightarrow _{b6}P(F(1,1,F(1,1,{\underline {F(2,1,0)}})))} → → b 7 P ( F ( 2 , 1 , F ( 1 , 1 , 2 ) _ _ ) ) {\displaystyle \rightarrow _{b7}P(F(2,1,{\underline {F(1,1,2)}}))} → → b 6 P ( F ( 1 , 1 , F ( 1 , 1 , F ( 1 , 1 , F ( 1 , 1 , 0 ) _ _ ) ) ) ) {\displaystyle \rightarrow _{b6}P(F(1,1,F(1,1,F(1,1,{\underline {F(1,1,0)}}))))} → → b 5 P ( F ( 2 , 1 , F ( 2 , 0 , F ( 1 , 1 , 0 ) _ _ ) ) ) {\displaystyle \rightarrow _{b5}P(F(2,1,F(2,0,{\underline {F(1,1,0)}})))} → → b 2 P ( F ( 1 , 1 , F ( 1 , 1 , F ( 1 , 1 , 2 ) _ _ ) ) ) {\displaystyle \rightarrow _{b2}P(F(1,1,F(1,1,{\underline {F(1,1,2)}})))} → → b 2 P ( F ( 2 , 1 , F ( 2 , 0 , 2 ) _ _ ) ) {\displaystyle \rightarrow _{b2}P(F(2,1,{\underline {F(2,0,2)}}))} → → b 5 P ( F ( 1 , 1 , F ( 1 , 1 , F ( 2 , 0 , F ( 1 , 1 , 0 ) _ _ ) ) ) ) {\displaystyle \rightarrow _{b5}P(F(1,1,F(1,1,F(2,0,{\underline {F(1,1,0)}}))))} → → b 7 P ( F ( 2 , 1 , F ( 1 , 0 , F ( 1 , 0 , 2 ) _ _ ) ) ) {\displaystyle \rightarrow _{b7}P(F(2,1,F(1,0,{\underline {F(1,0,2)}})))} → → b 2 P ( F ( 1 , 1 , F ( 1 , 1 , F ( 2 , 0 , 2 ) _ _ ) ) ) {\displaystyle \rightarrow _{b2}P(F(1,1,F(1,1,{\underline {F(2,0,2)}})))} → → b 1 P ( F ( 2 , 1 , F ( 1 , 0 , 3 ) _ _ ) ) {\displaystyle \rightarrow _{b1}P(F(2,1,{\underline {F(1,0,3)}}))} → → b 6 P ( F ( 1 , 1 , F ( 1 , 1 , F ( 1 , 0 , F ( 1 , 0 , 2 ) _ _ ) ) ) ) {\displaystyle \rightarrow _{b6}P(F(1,1,F(1,1,F(1,0,{\underline {F(1,0,2)}}))))} → → b 1 P ( F ( 2 , 1 , 4 ) _ _ ) {\displaystyle \rightarrow _{b1}P({\underline {F(2,1,4)}})} → → b 1 P ( F ( 1 , 1 , F ( 1 , 1 , F ( 1 , 0 , 3 ) _ _ ) ) ) {\displaystyle \rightarrow _{b1}P(F(1,1,F(1,1,{\underline {F(1,0,3)}})))} → → b 7 P ( F ( 1 , 1 , F ( 1 , 1 , 4 ) _ _ ) ) {\displaystyle \rightarrow _{b7}P(F(1,1,{\underline {F(1,1,4)}}))} → → b 1 P ( F ( 1 , 1 , F ( 1 , 1 , 4 ) _ _ ) ) {\displaystyle \rightarrow _{b1}P(F(1,1,{\underline {F(1,1,4)}}))} → → b 5 P ( F ( 1 , 1 , F ( 4 , 0 , F ( 1 , 1 , 0 ) _ _ ) ) ) {\displaystyle \rightarrow _{b5}P(F(1,1,F(4,0,{\underline {F(1,1,0)}})))} → → b 5 P ( F ( 1 , 1 , F ( 4 , 0 , F ( 1 , 1 , 0 ) _ _ ) ) ) {\displaystyle \rightarrow _{b5}P(F(1,1,F(4,0,{\underline {F(1,1,0)}})))} → → b 2 P ( F ( 1 , 1 , F ( 4 , 0 , 2 ) _ _ ) ) {\displaystyle \rightarrow _{b2}P(F(1,1,{\underline {F(4,0,2)}}))} → → b 2 P ( F ( 1 , 1 , F ( 4 , 0 , 2 ) _ _ ) ) {\displaystyle \rightarrow _{b2}P(F(1,1,{\underline {F(4,0,2)}}))} → → b 7 P ( F ( 1 , 1 , F ( 3 , 0 , F ( 1 , 0 , 2 ) _ _ ) ) ) {\displaystyle \rightarrow _{b7}P(F(1,1,F(3,0,{\underline {F(1,0,2)}})))} → → b 6 P ( F ( 1 , 1 , F ( 1 , 0 , F ( 3 , 0 , 2 ) _ _ ) ) ) {\displaystyle \rightarrow _{b6}P(F(1,1,F(1,0,{\underline {F(3,0,2)}})))} → → b 1 P ( F ( 1 , 1 , F ( 3 , 0 , 3 ) _ _ ) ) {\displaystyle \rightarrow _{b1}P(F(1,1,{\underline {F(3,0,3)}}))} → → b 6 P ( F ( 1 , 1 , F ( 1 , 0 , F ( 1 , 0 , F ( 2 , 0 , 2 ) _ _ ) ) ) ) {\displaystyle \rightarrow _{b6}P(F(1,1,F(1,0,F(1,0,{\underline {F(2,0,2)}}))))} → → b 7 P ( F ( 1 , 1 , F ( 2 , 0 , F ( 1 , 0 , 3 ) _ _ ) ) ) {\displaystyle \rightarrow _{b7}P(F(1,1,F(2,0,{\underline {F(1,0,3)}})))} → → b 6 P ( F ( 1 , 1 , F ( 1 , 0 , F ( 1 , 0 , F ( 1 , 0 , F ( 1 , 0 , 2 ) _ _ ) ) ) ) ) {\displaystyle \rightarrow _{b6}P(F(1,1,F(1,0,F(1,0,F(1,0,{\underline {F(1,0,2)}})))))} → → b 1 P ( F ( 1 , 1 , F ( 2 , 0 , 4 ) _ _ ) ) {\displaystyle \rightarrow _{b1}P(F(1,1,{\underline {F(2,0,4)}}))} → → b 1 P ( F ( 1 , 1 , F ( 1 , 0 , F ( 1 , 0 , F ( 1 , 0 , 3 ) _ _ ) ) ) ) {\displaystyle \rightarrow _{b1}P(F(1,1,F(1,0,F(1,0,{\underline {F(1,0,3)}}))))} → → b 7 P ( F ( 1 , 1 , F ( 1 , 0 , F ( 1 , 0 , 4 ) _ _ ) ) ) {\displaystyle \rightarrow _{b7}P(F(1,1,F(1,0,{\underline {F(1,0,4)}})))} → → b 1 P ( F ( 1 , 1 , F ( 1 , 0 , F ( 1 , 0 , 4 ) _ _ ) ) ) {\displaystyle \rightarrow _{b1}P(F(1,1,F(1,0,{\underline {F(1,0,4)}})))} → → b 1 P ( F ( 1 , 1 , F ( 1 , 0 , 5 ) _ _ ) ) {\displaystyle \rightarrow _{b1}P(F(1,1,{\underline {F(1,0,5)}}))} → → b 1 P ( F ( 1 , 1 , F ( 1 , 0 , 5 ) _ _ ) ) {\displaystyle \rightarrow _{b1}P(F(1,1,{\underline {F(1,0,5)}}))} → → b 1 P ( F ( 1 , 1 , 6 ) _ _ ) {\displaystyle \rightarrow _{b1}P({\underline {F(1,1,6)}})} → → b 1 P ( F ( 1 , 1 , 6 ) _ _ ) {\displaystyle \rightarrow _{b1}P({\underline {F(1,1,6)}})} → → b 5 P ( F ( 6 , 0 , F ( 1 , 1 , 0 ) _ _ ) ) {\displaystyle \rightarrow _{b5}P(F(6,0,{\underline {F(1,1,0)}}))} → → b 5 P ( F ( 6 , 0 , F ( 1 , 1 , 0 ) _ _ ) ) {\displaystyle \rightarrow _{b5}P(F(6,0,{\underline {F(1,1,0)}}))} → → b 2 P ( F ( 6 , 0 , 2 ) _ _ ) {\displaystyle \rightarrow _{b2}P({\underline {F(6,0,2)}})} → → b 2 P ( F ( 6 , 0 , 2 ) _ _ ) {\displaystyle \rightarrow _{b2}P({\underline {F(6,0,2)}})} → → b 7 P ( F ( 5 , 0 , F ( 1 , 0 , 2 ) _ _ ) ) {\displaystyle \rightarrow _{b7}P(F(5,0,{\underline {F(1,0,2)}}))} → → b 6 P ( F ( 1 , 0 , F ( 5 , 0 , 2 ) _ _ ) ) {\displaystyle \rightarrow _{b6}P(F(1,0,{\underline {F(5,0,2)}}))} → → b 1 P ( F ( 5 , 0 , 3 ) _ _ ) {\displaystyle \rightarrow _{b1}P({\underline {F(5,0,3)}})} → → b 6 P ( F ( 1 , 0 , F ( 1 , 0 , F ( 4 , 0 , 2 ) _ _ ) ) ) {\displaystyle \rightarrow _{b6}P(F(1,0,F(1,0,{\underline {F(4,0,2)}})))} → → b 7 P ( F ( 4 , 0 , F ( 1 , 0 , 3 ) _ _ ) ) {\displaystyle \rightarrow _{b7}P(F(4,0,{\underline {F(1,0,3)}}))} → → b 6 P ( F ( 1 , 0 , F ( 1 , 0 , F ( 1 , 0 , F ( 3 , 0 , 2 ) _ _ ) ) ) ) {\displaystyle \rightarrow _{b6}P(F(1,0,F(1,0,F(1,0,{\underline {F(3,0,2)}}))))} → → b 1 P ( F ( 4 , 0 , 4 ) _ _ ) {\displaystyle \rightarrow _{b1}P({\underline {F(4,0,4)}})} → → b 6 P ( F ( 1 , 0 , F ( 1 , 0 , F ( 1 , 0 , F ( 1 , 0 , F ( 2 , 0 , 2 ) _ _ ) ) ) ) ) {\displaystyle \rightarrow _{b6}P(F(1,0,F(1,0,F(1,0,F(1,0,{\underline {F(2,0,2)}})))))} → → b 7 P ( F ( 3 , 0 , F ( 1 , 0 , 4 ) _ _ ) ) {\displaystyle \rightarrow _{b7}P(F(3,0,{\underline {F(1,0,4)}}))} → → b 6 P ( F ( 1 , 0 , F ( 1 , 0 , F ( 1 , 0 , F ( 1 , 0 , F ( 1 , 0 , F ( 1 , 0 , 2 ) _ _ ) ) ) ) ) ) {\displaystyle \rightarrow _{b6}P(F(1,0,F(1,0,F(1,0,F(1,0,F(1,0,{\underline {F(1,0,2)}}))))))} → → b 1 P ( F ( 3 , 0 , 5 ) _ _ ) {\displaystyle \rightarrow _{b1}P({\underline {F(3,0,5)}})} → → b 1 P ( F ( 1 , 0 , F ( 1 , 0 , F ( 1 , 0 , F ( 1 , 0 , F ( 1 , 0 , 3 ) _ _ ) ) ) ) ) {\displaystyle \rightarrow _{b1}P(F(1,0,F(1,0,F(1,0,F(1,0,{\underline {F(1,0,3)}})))))} → → b 7 P ( F ( 2 , 0 , F ( 1 , 0 , 5 ) _ _ ) ) {\displaystyle \rightarrow _{b7}P(F(2,0,{\underline {F(1,0,5)}}))} → → b 1 P ( F ( 1 , 0 , F ( 1 , 0 , F ( 1 , 0 , F ( 1 , 0 , 4 ) _ _ ) ) ) ) {\displaystyle \rightarrow _{b1}P(F(1,0,F(1,0,F(1,0,{\underline {F(1,0,4)}}))))} → → b 1 P ( F ( 2 , 0 , 6 ) _ _ ) {\displaystyle \rightarrow _{b1}P({\underline {F(2,0,6)}})} → → b 1 P ( F ( 1 , 0 , F ( 1 , 0 , F ( 1 , 0 , 5 ) _ _ ) ) ) {\displaystyle \rightarrow _{b1}P(F(1,0,F(1,0,{\underline {F(1,0,5)}})))} → → b 7 P ( F ( 1 , 0 , F ( 1 , 0 , 6 ) _ _ ) ) {\displaystyle \rightarrow _{b7}P(F(1,0,{\underline {F(1,0,6)}}))} → → b 1 P ( F ( 1 , 0 , F ( 1 , 0 , 6 ) _ _ ) ) {\displaystyle \rightarrow _{b1}P(F(1,0,{\underline {F(1,0,6)}}))} → → b 1 P ( F ( 1 , 0 , 7 ) _ _ ) {\displaystyle \rightarrow _{b1}P({\underline {F(1,0,7)}})} → → b 1 P ( F ( 1 , 0 , 7 ) _ _ ) {\displaystyle \rightarrow _{b1}P({\underline {F(1,0,7)}})} → → b 1 P ( 8 ) _ _ {\displaystyle \rightarrow _{b1}{\underline {P(8)}}} → → b 1 P ( 8 ) _ _ {\displaystyle \rightarrow _{b1}{\underline {P(8)}}} → → r 10 5 {\displaystyle \rightarrow _{r10}5} → → r 10 5 {\displaystyle \rightarrow _{r10}5} The matching equalities are when the TRS with the reduction rule b6 {\displaystyle {\text{b6}}} is applied: A ( 2 , 1 ) + 3 = F ( 2 , 4 ) = ⋯ ⋯ = F 6 ( 0 , 2 ) = F ( 0 , F 5 ( 0 , 2 ) ) = F ( 0 , F ( 0 , F 4 ( 0 , 2 ) ) ) = F ( 0 , F ( 0 , F ( 0 , F 3 ( 0 , 2 ) ) ) ) = F ( 0 , F ( 0 , F ( 0 , F ( 0 , F 2 ( 0 , 2 ) ) ) ) ) = F ( 0 , F ( 0 , F ( 0 , F ( 0 , F ( 0 , F ( 0 , 2 ) ) ) ) ) ) = F ( 0 , F ( 0 , F ( 0 , F ( 0 , F ( 0 , 3 ) ) ) ) ) = F ( 0 , F ( 0 , F ( 0 , F ( 0 , 4 ) ) ) ) = F ( 0 , F ( 0 , F ( 0 , 5 ) ) ) = F ( 0 , F ( 0 , 6 ) ) = F ( 0 , 7 ) = 8 {\displaystyle {\begin{aligned}&A(2,1)+3=F(2,4)=\dots =F^{6}(0,2)=F(0,F^{5}(0,2))=F(0,F(0,F^{4}(0,2)))\\&=F(0,F(0,F(0,F^{3}(0,2))))=F(0,F(0,F(0,F(0,F^{2}(0,2)))))=F(0,F(0,F(0,F(0,F(0,F(0,2))))))\\&=F(0,F(0,F(0,F(0,F(0,3)))))=F(0,F(0,F(0,F(0,4))))=F(0,F(0,F(0,5)))=F(0,F(0,6))=F(0,7)=8\end{aligned}}} when the TRS with the reduction rule b7 {\displaystyle {\text{b7}}} is applied: A ( 2 , 1 ) + 3 = F ( 2 , 4 ) = ⋯ ⋯ = F 6 ( 0 , 2 ) = F 5 ( 0 , F ( 0 , 2 ) ) = F 5 ( 0 , 3 ) = F 4 ( 0 , F ( 0 , 3 ) ) = F 4 ( 0 , 4 ) = F 3 ( 0 , F ( 0 , 4 ) ) = F 3 ( 0 , 5 ) = F 2 ( 0 , F ( 0 , 5 ) ) = F 2 ( 0 , 6 ) = F ( 0 , F ( 0 , 6 ) ) = F ( 0 , 7 ) = 8 {\displaystyle {\begin{aligned}&A(2,1)+3=F(2,4)=\dots =F^{6}(0,2)=F^{5}(0,F(0,2))=F^{5}(0,3)=F^{4}(0,F(0,3))=F^{4}(0,4)\\&=F^{3}(0,F(0,4))=F^{3}(0,5)=F^{2}(0,F(0,5))=F^{2}(0,6)=F(0,F(0,6))=F(0,7)=8\end{aligned}}} Remarks The computation of A i ⁡ ⁡ ( n ) {\displaystyle \operatorname {A} _{i}(n)} according to the rules {b1 - b5, b6, r8 - r10} is deeply recursive. The maximum depth of nested F {\displaystyle F} s is A ( i , n ) + 1 {\displaystyle A(i,n)+1} . The culprit is the order in which iteration is executed: F n + 1 ( x ) = F ( F n ( x ) ) {\displaystyle F^{n+1}(x)=F(F^{n}(x))} . The first F {\displaystyle F} disappears only after the whole sequence is unfolded.

The computation according to the rules {b1 - b5, b7, r8 - r10} is more efficient in that respect. The iteration F n + 1 ( x ) = F n ( F ( x ) ) {\displaystyle F^{n+1}(x)=F^{n}(F(x))} simulates the repeated loop over a block of code.

[ n 7 ] The nesting is limited to ( i + 1 ) {\displaystyle (i+1)} , one recursion level per iterated function.

Meyer & Ritchie (1967) showed this correspondence.

These considerations concern the recursion depth only. Either way of iterating leads to the same number of reduction steps, involving the same rules (when the rules b6 and b7 are considered "the same"). The reduction of A ( 2 , 1 ) {\displaystyle A(2,1)} for instance converges in 35 steps: 12 × b1, 4 × b2, 1 × b3, 4 × b5, 12 × b6/b7, 1 × r9, 1 × r10. The modus iterandi only affects the order in which the reduction rules are applied.

A real gain of execution time can only be achieved by not recalculating subresults over and over again.

Memoization is an optimization technique where the results of function calls are cached and returned when the same inputs occur again. See for instance Ward (1993) .

Grossman & Zeitman (1988) published a cunning algorithm which computes A ( i , n ) {\displaystyle A(i,n)} within O ( i A ( i , n ) ) {\displaystyle {\mathcal {O}}(iA(i,n))} time and within O ( i ) {\displaystyle {\mathcal {O}}(i)} space.

Huge numbers To demonstrate how the computation of A ( 4 , 3 ) {\displaystyle A(4,3)} results in many steps and in a large number: [ n 5 ] A ( 4 , 3 ) → → A ( 3 , A ( 4 , 2 ) ) → → A ( 3 , A ( 3 , A ( 4 , 1 ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 4 , 0 ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 3 , 1 ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 2 , A ( 3 , 0 ) ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 2 , A ( 2 , 1 ) ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 2 , A ( 1 , A ( 2 , 0 ) ) ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 2 , A ( 1 , A ( 1 , 1 ) ) ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 2 , A ( 1 , A ( 0 , A ( 1 , 0 ) ) ) ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 2 , A ( 1 , A ( 0 , A ( 0 , 1 ) ) ) ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 2 , A ( 1 , A ( 0 , 2 ) ) ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 2 , A ( 1 , 3 ) ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 2 , A ( 0 , A ( 1 , 2 ) ) ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 2 , A ( 0 , A ( 0 , A ( 1 , 1 ) ) ) ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 2 , A ( 0 , A ( 0 , A ( 0 , A ( 1 , 0 ) ) ) ) ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 2 , A ( 0 , A ( 0 , A ( 0 , A ( 0 , 1 ) ) ) ) ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 2 , A ( 0 , A ( 0 , A ( 0 , 2 ) ) ) ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 2 , A ( 0 , A ( 0 , 3 ) ) ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 2 , A ( 0 , 4 ) ) ) ) ) → → A ( 3 , A ( 3 , A ( 3 , A ( 2 , 5 ) ) ) ) ⋮ ⋮ → → A ( 3 , A ( 3 , A ( 3 , 13 ) ) ) ⋮ ⋮ → → A ( 3 , A ( 3 , 65533 ) ) ⋮ ⋮ → → A ( 3 , 2 65536 − − 3 ) ⋮ ⋮ → → 2 2 65536 − − 3.

{\displaystyle {\begin{aligned}A(4,3)&\rightarrow A(3,A(4,2))\\&\rightarrow A(3,A(3,A(4,1)))\\&\rightarrow A(3,A(3,A(3,A(4,0))))\\&\rightarrow A(3,A(3,A(3,A(3,1))))\\&\rightarrow A(3,A(3,A(3,A(2,A(3,0)))))\\&\rightarrow A(3,A(3,A(3,A(2,A(2,1)))))\\&\rightarrow A(3,A(3,A(3,A(2,A(1,A(2,0))))))\\&\rightarrow A(3,A(3,A(3,A(2,A(1,A(1,1))))))\\&\rightarrow A(3,A(3,A(3,A(2,A(1,A(0,A(1,0)))))))\\&\rightarrow A(3,A(3,A(3,A(2,A(1,A(0,A(0,1)))))))\\&\rightarrow A(3,A(3,A(3,A(2,A(1,A(0,2))))))\\&\rightarrow A(3,A(3,A(3,A(2,A(1,3)))))\\&\rightarrow A(3,A(3,A(3,A(2,A(0,A(1,2))))))\\&\rightarrow A(3,A(3,A(3,A(2,A(0,A(0,A(1,1)))))))\\&\rightarrow A(3,A(3,A(3,A(2,A(0,A(0,A(0,A(1,0))))))))\\&\rightarrow A(3,A(3,A(3,A(2,A(0,A(0,A(0,A(0,1))))))))\\&\rightarrow A(3,A(3,A(3,A(2,A(0,A(0,A(0,2)))))))\\&\rightarrow A(3,A(3,A(3,A(2,A(0,A(0,3))))))\\&\rightarrow A(3,A(3,A(3,A(2,A(0,4)))))\\&\rightarrow A(3,A(3,A(3,A(2,5))))\\&\qquad \vdots \\&\rightarrow A(3,A(3,A(3,13)))\\&\qquad \vdots \\&\rightarrow A(3,A(3,65533))\\&\qquad \vdots \\&\rightarrow A(3,2^{65536}-3)\\&\qquad \vdots \\&\rightarrow 2^{2^{65536}}-3.\\\end{aligned}}} Table of values Computing the Ackermann function can be restated in terms of an infinite table. First, place the natural numbers along the top row. To determine a number in the table, take the number immediately to the left. Then use that number to look up the required number in the column given by that number and one row up. If there is no number to its left, simply look at the column headed "1" in the previous row. Here is a small upper-left portion of the table: Values of A ( m , n ) n m 0 1 2 3 4 n 0 1 2 3 4 5 n + 1 {\displaystyle n+1} 1 2 3 4 5 6 n + 2 = 2 + ( n + 3 ) − − 3 {\displaystyle n+2=2+(n+3)-3} 2 3 5 7 9 11 2 n + 3 = 2 ⋅ ⋅ ( n + 3 ) − − 3 {\displaystyle 2n+3=2\cdot (n+3)-3} 3 5 13 29 61 125 2 ( n + 3 ) − − 3 {\displaystyle 2^{(n+3)}-3} 4 13 65533 2 65536 – 3 2 2 65536 − − 3 {\displaystyle {2^{2^{65536}}}-3} 2 2 2 65536 − − 3 {\displaystyle {2^{2^{2^{65536}}}}-3} 2 2 ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ 2 ⏟ ⏟ n + 3 − − 3 {\displaystyle {\begin{matrix}\underbrace {{2^{2}}^{{\cdot }^{{\cdot }^{{\cdot }^{2}}}}} _{n+3}-3\end{matrix}}} = 2 2 2 − − 3 {\displaystyle ={2^{2^{2}}}-3} = 2 ↑ ↑ ↑ ↑ 3 − − 3 {\displaystyle =2\uparrow \uparrow 3-3} = 2 2 2 2 − − 3 {\displaystyle ={2^{2^{2^{2}}}}-3} = 2 ↑ ↑ ↑ ↑ 4 − − 3 {\displaystyle =2\uparrow \uparrow 4-3} = 2 2 2 2 2 − − 3 {\displaystyle ={2^{2^{2^{2^{2}}}}}-3} = 2 ↑ ↑ ↑ ↑ 5 − − 3 {\displaystyle =2\uparrow \uparrow 5-3} = 2 2 2 2 2 2 − − 3 {\displaystyle ={2^{2^{2^{2^{2^{2}}}}}}-3} = 2 ↑ ↑ ↑ ↑ 6 − − 3 {\displaystyle =2\uparrow \uparrow 6-3} = 2 2 2 2 2 2 2 − − 3 {\displaystyle ={2^{2^{2^{2^{2^{2^{2}}}}}}}-3} = 2 ↑ ↑ ↑ ↑ 7 − − 3 {\displaystyle =2\uparrow \uparrow 7-3} = 2 ↑ ↑ ↑ ↑ ( n + 3 ) − − 3 {\displaystyle =2\uparrow \uparrow (n+3)-3} 5 65533 = 2 ↑ ↑ ↑ ↑ ( 2 ↑ ↑ ↑ ↑ 2 ) − − 3 {\displaystyle =2\uparrow \uparrow (2\uparrow \uparrow 2)-3} = 2 ↑ ↑ ↑ ↑ ↑ ↑ 3 − − 3 {\displaystyle =2\uparrow \uparrow \uparrow 3-3} 2 ↑ ↑ ↑ ↑ ↑ ↑ 4 − − 3 {\displaystyle 2\uparrow \uparrow \uparrow 4-3} 2 ↑ ↑ ↑ ↑ ↑ ↑ 5 − − 3 {\displaystyle 2\uparrow \uparrow \uparrow 5-3} 2 ↑ ↑ ↑ ↑ ↑ ↑ 6 − − 3 {\displaystyle 2\uparrow \uparrow \uparrow 6-3} 2 ↑ ↑ ↑ ↑ ↑ ↑ 7 − − 3 {\displaystyle 2\uparrow \uparrow \uparrow 7-3} 2 ↑ ↑ ↑ ↑ ↑ ↑ ( n + 3 ) − − 3 {\displaystyle 2\uparrow \uparrow \uparrow (n+3)-3} 6 2 ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ 3 − − 3 {\displaystyle 2\uparrow \uparrow \uparrow \uparrow 3-3} 2 ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ 4 − − 3 {\displaystyle 2\uparrow \uparrow \uparrow \uparrow 4-3} 2 ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ 5 − − 3 {\displaystyle 2\uparrow \uparrow \uparrow \uparrow 5-3} 2 ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ 6 − − 3 {\displaystyle 2\uparrow \uparrow \uparrow \uparrow 6-3} 2 ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ 7 − − 3 {\displaystyle 2\uparrow \uparrow \uparrow \uparrow 7-3} 2 ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ( n + 3 ) − − 3 {\displaystyle 2\uparrow \uparrow \uparrow \uparrow (n+3)-3} m ( 2 ↑ ↑ m − − 2 3 ) − − 3 {\displaystyle (2\uparrow ^{m-2}3)-3} ( 2 ↑ ↑ m − − 2 4 ) − − 3 {\displaystyle (2\uparrow ^{m-2}4)-3} ( 2 ↑ ↑ m − − 2 5 ) − − 3 {\displaystyle (2\uparrow ^{m-2}5)-3} ( 2 ↑ ↑ m − − 2 6 ) − − 3 {\displaystyle (2\uparrow ^{m-2}6)-3} ( 2 ↑ ↑ m − − 2 7 ) − − 3 {\displaystyle (2\uparrow ^{m-2}7)-3} ( 2 ↑ ↑ m − − 2 ( n + 3 ) ) − − 3 {\displaystyle (2\uparrow ^{m-2}(n+3))-3} The numbers here which are only expressed with recursive exponentiation or Knuth arrows are very large and would take up too much space to notate in plain decimal digits.

Despite the large values occurring in this early section of the table, some even larger numbers have been defined, such as Graham's number , which cannot be written with any small number of Knuth arrows. This number is constructed with a technique similar to applying the Ackermann function to itself recursively.

This is a repeat of the above table, but with the values replaced by the relevant expression from the function definition to show the pattern clearly: Values of A ( m , n ) n m 0 1 2 3 4 n 0 0+1 1+1 2+1 3+1 4+1 n + 1 1 A (0, 1) A (0, A (1, 0)) = A (0, 2) A (0, A (1, 1)) = A (0, 3) A (0, A (1, 2)) = A (0, 4) A (0, A (1, 3)) = A (0, 5) A (0, A (1, n −1)) 2 A (1, 1) A (1, A (2, 0)) = A (1, 3) A (1, A (2, 1)) = A (1, 5) A (1, A (2, 2)) = A (1, 7) A (1, A (2, 3)) = A (1, 9) A (1, A (2, n −1)) 3 A (2, 1) A (2, A (3, 0)) = A (2, 5) A (2, A (3, 1)) = A (2, 13) A (2, A (3, 2)) = A (2, 29) A (2, A (3, 3)) = A (2, 61) A (2, A (3, n −1)) 4 A (3, 1) A (3, A (4, 0)) = A (3, 13) A (3, A (4, 1)) = A (3, 65533) A (3, A (4, 2)) A (3, A (4, 3)) A (3, A (4, n −1)) 5 A (4, 1) A (4, A (5, 0)) A (4, A (5, 1)) A (4, A (5, 2)) A (4, A (5, 3)) A (4, A (5, n −1)) 6 A (5, 1) A (5, A (6, 0)) A (5, A (6, 1)) A (5, A (6, 2)) A (5, A (6, 3)) A (5, A (6, n −1)) Properties General remarks It may not be immediately obvious that the evaluation of A ( m , n ) {\displaystyle A(m,n)} always terminates. However, the recursion is bounded because in each recursive application either m {\displaystyle m} decreases, or m {\displaystyle m} remains the same and n {\displaystyle n} decreases. Each time that n {\displaystyle n} reaches zero, m {\displaystyle m} decreases, so m {\displaystyle m} eventually reaches zero as well. (Expressed more technically, in each case the pair ( m , n ) {\displaystyle (m,n)} decreases in the lexicographic order on pairs, which is a well-ordering , just like the ordering of single non-negative integers; this means one cannot go down in the ordering infinitely many times in succession.) However, when m {\displaystyle m} decreases there is no upper bound on how much n {\displaystyle n} can increase — and it will often increase greatly.

For small values of m like 1, 2, or 3, the Ackermann function grows relatively slowly with respect to n (at most exponentially ). For m ≥ ≥ 4 {\displaystyle m\geq 4} , however, it grows much more quickly; even A ( 4 , 2 ) {\displaystyle A(4,2)} is about 2.00353 × 10 19 728 , and the decimal expansion of A ( 4 , 3 ) {\displaystyle A(4,3)} is very large by any typical measure, about 2.12004 × 10 6.03123 × 10 19 727 .

An interesting aspect is that the only arithmetic operation it ever uses is addition of 1. Its fast growing power is based solely on nested recursion. This also implies that its running time is at least proportional to its output, and so is also extremely huge. In actuality, for most cases the running time is far larger than the output; see above.

A single-argument version f ( n ) = A ( n , n ) {\displaystyle f(n)=A(n,n)} that increases both m {\displaystyle m} and n {\displaystyle n} at the same time dwarfs every primitive recursive function, including very fast-growing functions such as the exponential function , the factorial function, multi- and superfactorial functions, and even functions defined using Knuth's up-arrow notation (except when the indexed up-arrow is used). It can be seen that f ( n ) {\displaystyle f(n)} is roughly comparable to f ω ω ( n ) {\displaystyle f_{\omega }(n)} in the fast-growing hierarchy . This extreme growth can be exploited to show that f {\displaystyle f} which is obviously computable on a machine with infinite memory such as a Turing machine and so is a computable function , grows faster than any primitive recursive function and is therefore not primitive recursive.

Not primitive recursive The Ackermann function grows faster than any primitive recursive function and therefore is not itself primitive recursive.

Proof sketch : Primitive recursive functions are built from basic functions using composition and primitive recursion, and all grow within a certain rate. We define, constructively, a hierarchy of total functions FGH k ⁡ ⁡ ( n ) {\displaystyle \operatorname {FGH} _{k}(n)} by: FGH 0 ⁡ ⁡ ( n ) = n + 1 , FGH k + 1 ⁡ ⁡ ( n ) = FGH k n ⁡ ⁡ ( n ) {\displaystyle \operatorname {FGH} _{0}(n)=n+1,\quad \operatorname {FGH} _{k+1}(n)=\operatorname {FGH} _{k}^{n}(n)} where FGH k n {\displaystyle \operatorname {FGH} _{k}^{n}} denotes n {\displaystyle n} -fold iteration of FGH k {\displaystyle \operatorname {FGH} _{k}} on input n {\displaystyle n} .

[ 23 ] This hierarchy grows strictly faster with increasing k {\displaystyle k} , and every primitive recursive function is eventually bounded above by some F G H k {\displaystyle FGH_{k}} . This can be shown by structural induction on the definitions of primitive recursive functions.

However, the Ackermann function A ⁡ ⁡ ( m , n ) {\displaystyle \operatorname {A} (m,n)} eventually exceeds every FGH k {\displaystyle \operatorname {FGH} _{k}} ; for every k {\displaystyle k} , there exists m {\displaystyle m} such that A ⁡ ⁡ ( m , n ) > FGH k ⁡ ⁡ ( n ) {\displaystyle \operatorname {A} (m,n)>\operatorname {FGH} _{k}(n)} for sufficiently large n {\displaystyle n} . Thus, A {\displaystyle \operatorname {A} } grows faster than any primitive recursive function and is therefore not primitive recursive.

Inverse Since the function f ( n ) = A ( n , n ) considered above grows very rapidly, its inverse function , f −1 , grows very slowly. This inverse Ackermann function f −1 is usually denoted by α . In fact, α ( n ) is less than 5 for any practical input size n , since A (4, 4) is on the order of 2 2 2 2 16 {\displaystyle 2^{2^{2^{2^{16}}}}} .

This inverse appears in the time complexity of some algorithms, such as the disjoint-set data structure and Chazelle 's algorithm for minimum spanning trees . Sometimes Ackermann's original function or other variations are used in these settings, but they all grow at similarly high rates. In particular, some modified functions simplify the expression by eliminating the −3 and similar terms.

A two-parameter variation of the inverse Ackermann function can be defined as follows, where ⌊ ⌊ x ⌋ ⌋ {\displaystyle \lfloor x\rfloor } is the floor function : α α ( m , n ) = min { i ≥ ≥ 1 : A ( i , ⌊ ⌊ m / n ⌋ ⌋ ) ≥ ≥ log 2 ⁡ ⁡ n } .

{\displaystyle \alpha (m,n)=\min\{i\geq 1:A(i,\lfloor m/n\rfloor )\geq \log _{2}n\}.} This function arises in more precise analyses of the algorithms mentioned above, and gives a more refined time bound. In the disjoint-set data structure, m represents the number of operations while n represents the number of elements; in the minimum spanning tree algorithm, m represents the number of edges while n represents the number of vertices. Several slightly different definitions of α ( m , n ) exist; for example, log 2 n is sometimes replaced by n , and the floor function is sometimes replaced by a ceiling .

Other studies might define an inverse function of one where m is set to a constant, such that the inverse applies to a particular row.

[ 24 ] The inverse of the Ackermann function is primitive recursive, since it is graph primitive recursive, and it is upper bounded by a primitive recursive function.

[ 25 ] Usage In computational complexity The Ackermann function appears in the time complexity of some algorithms , [ 26 ] such as vector addition systems [ 27 ] and Petri net reachability , thus showing they are computationally infeasible for large instances.

[ 28 ] The inverse of the Ackermann function appears in some time complexity results. For instance, the disjoint-set data structure takes amortized time per operation proportional to the inverse Ackermann function, [ 29 ] and cannot be made faster within the cell-probe model of computational complexity.

[ 30 ] In discrete geometry Certain problems in discrete geometry related to Davenport–Schinzel sequences have complexity bounds in which the inverse Ackermann function α α ( n ) {\displaystyle \alpha (n)} appears. For instance, for n {\displaystyle n} line segments in the plane, the unbounded face of the arrangement of the segments has complexity O ( n α α ( n ) ) {\displaystyle O(n\alpha (n))} , and some systems of n {\displaystyle n} line segments have an unbounded face of complexity Ω Ω ( n α α ( n ) ) {\displaystyle \Omega (n\alpha (n))} .

[ 31 ] As a benchmark The Ackermann function, due to its definition in terms of extremely deep recursion, can be used as a benchmark of a compiler 's ability to optimize recursion. The first published use of Ackermann's function in this way was in 1970 by Dragoș Vaida [ 32 ] and, almost simultaneously, in 1971, by Yngve Sundblad.

[ 14 ] Sundblad's seminal paper was taken up by Brian Wichmann (co-author of the Whetstone benchmark ) in a trilogy of papers written between 1975 and 1982.

[ 33 ] [ 34 ] [ 35 ] See also Wikifunctions has a Ackermann function .

Computability theory Double recursion Fast-growing hierarchy Goodstein function Primitive recursive function Recursion (computer science) Notes ^ with parameter order reversed ^ ' curried ' ^ In each step the underlined redex is rewritten.

^ a b here: leftmost-innermost strategy!

^ a b c d For better readability S(0) is notated as 1, S(S(0)) is notated as 2, S(S(S(0))) is notated as 3, etc...

^ The maximum depth of recursion refers to the number of levels of activation of a procedure which exist during the deepest call of the procedure.

Cornelius & Kirby (1975) ^ LOOP n+1 TIMES DO F References ^ Monin & Hinchey 2003 , p. 61.

^ a b Ackermann 1928 .

^ "Decimal expansion of A(4,2)" .

kosara.net . 27 August 2000. Archived from the original on 20 January 2010.

^ Calude, Marcus & Tevy 1979 .

^ Hilbert 1926 , p. 185.

^ van Heijenoort 1977 .

^ Péter 1935 .

^ Robinson 1948 .

^ Ritchie 1965 , p. 1028.

^ a b c Buck 1963 .

^ Meeussen & Zantema 1992 , p. 6.

^ Munafo 1999a .

^ Ritchie 1965 .

^ a b Sundblad 1971 .

^ Porto & Matos 1980 .

^ Odifreddi 1999 , p. 298.

^ "The Ackermann hierarchy vs. the fast growing hierarchy" .

StackExchange .

^ Indentation according to the off-side rule ( INDENT ... DEDENT ), like in Python : for _ in range ( n ): n += 1 ^ Meyer & Ritchie 1967 .

^ Grossman & Zeitman 1988 .

^ Paulson 2021 .

^ Cohen 1987 , p. 56, Proposition 3.16 (see in proof).

^ Another sequence of functions, E n {\displaystyle \operatorname {E} _{n}} , defining the Grzegorczyk hierarchy , is frequently used to partition the primitive recursive functions into "growth classes". However, FGH n {\displaystyle \operatorname {FGH} _{n}} (or A n {\displaystyle \operatorname {A} _{n}} ) and E n {\displaystyle \operatorname {E} _{n}} do not align in their indexing.

^ Pettie 2002 .

^ Matos 2014 .

^ Brubaker 2023 .

^ Czerwiński & Orlikowski 2022 .

^ Leroux 2022 .

^ Tarjan 1975 .

^ Fredman & Saks 1989 .

^ Wiernik & Sharir 1988 .

^ Vaida 1970 .

^ Wichmann 1976 .

^ Wichmann 1977 .

^ Wichmann 1982 .

Bibliography Ackermann, Wilhelm (1928).

"Zum Hilbertschen Aufbau der reellen Zahlen" [On the Hilbertian construction of the real numbers].

Mathematische Annalen (in German).

99 : 118– 133.

doi : 10.1007/BF01459088 .

S2CID 123431274 .

Buck, R. C.

(1963). "Mathematical Induction and Recursive Definitions".

American Mathematical Monthly .

70 (2): 128– 135.

doi : 10.2307/2312881 .

JSTOR 2312881 .

Calude, Cristian ; Marcus, Solomon ; Tevy, Ionel (November 1979).

"The first example of a recursive function which is not primitive recursive" .

Historia Math .

6 (4): 380– 84.

doi : 10.1016/0315-0860(79)90024-7 .

Cohen, Daniel E. (January 1987).

Computability and logic . Halsted Press.

ISBN 9780745800349 .

Cornelius, B. J.; Kirby, G. H. (1975). "Depth of recursion and the Ackermann function".

BIT Numerical Mathematics .

15 (2): 144– 150.

doi : 10.1007/BF01932687 .

S2CID 120532578 .

Czerwiński, Wojciech; Orlikowski, Łukasz (7 February 2022).

Reachability in Vector Addition Systems is Ackermann-complete . Proceedings of the 2021 IEEE 62nd Annual Symposium on Foundations of Computer Science.

arXiv : 2104.13866 .

doi : 10.1109/FOCS52979.2021.00120 .

Fredman, M.

; Saks, M. (May 1989). "The cell probe complexity of dynamic data structures".

Proceedings of the twenty-first annual ACM symposium on Theory of computing – STOC '89 . pp.

345– 354.

doi : 10.1145/73007.73040 .

ISBN 0897913078 .

S2CID 13470414 .

Grossman, Jerrold W.; Zeitman, R. Suzanne (May 1988). "An inherently iterative computation of ackermann's function".

Theoretical Computer Science .

57 ( 2– 3): 327– 330.

doi : 10.1016/0304-3975(88)90046-1 .

van Heijenoort, Jean (1977) [reprinted with corrections, first published in 1967].

From Frege to Gödel: A Source Book in Mathematical Logic, 1879–1931 . Harvard University Press.

Hilbert, David (1926). "Über das Unendliche" [On the infinite].

Mathematische Annalen (in German).

95 : 161– 190.

doi : 10.1007/BF01206605 .

S2CID 121888793 .

Leroux, Jérôme (7 February 2022).

The Reachability Problem for Petri Nets is Not Primitive Recursive . Proceedings of the 2021 IEEE 62nd Annual Symposium on Foundations of Computer Science.

arXiv : 2104.12695 .

doi : 10.1109/FOCS52979.2021.00121 .

Löb, M. H.; Wainer, S. S. (1970).

"Hierarchies of number-theoretic functions. I." Archiv für mathematische Logik und Grundlagenforschung .

13 : 39– 51.

doi : 10.1007/BF01967649 .

Matos, Armando B (7 May 2014).

"The inverse of the Ackermann function is primitive recursive" (PDF) .

Archived (PDF) from the original on 9 October 2022.

Meeussen, V. C. S.; Zantema, H. (1992).

Derivation lengths in term rewriting from interpretations in the naturals (PDF) (Report). University of Utrecht Department of Computer Science.

ISSN 0924-3275 .

Archived (PDF) from the original on 9 October 2022.

Meyer, Albert R.

; Ritchie, Dennis MacAlistair (1967). "The complexity of loop programs".

Proceedings of the 1967 22nd national conference . ACM '67: Proceedings of the 1967 22nd national conference. pp.

465– 469.

doi : 10.1145/800196.806014 .

Monin, Jean-Francois; Hinchey, M. G. (2003).

Understanding Formal Methods . Springer. p. 61.

ISBN 9781852332471 .

Munafo, Robert (1999a).

"Versions of Ackermann's Function" .

Large Numbers at MROB . Retrieved 6 November 2021 .

Munafo, Robert (1999b).

"Inventing New Operators and Functions" .

Large Numbers at MROB . Retrieved 6 November 2021 .

Odifreddi, Piergiorgio (1999).

Classical recursion theory. Vol. II . Studies in Logic and the Foundations of Mathematics. Vol. 143. Amsterdam: North-Holland.

ISBN 978-0-444-50205-6 .

MR 1718169 .

Paulson, Lawrence C. (2021).

"Ackermann's Function in Iterative Form: A Proof Assistant Experiment" . Retrieved 19 October 2021 .

Péter, Rózsa (1935). "Konstruktion nichtrekursiver Funktionen" [Construction of non-recursive functions].

Mathematische Annalen (in German).

111 : 42– 60.

doi : 10.1007/BF01472200 .

S2CID 121107217 .

Pettie, S. (2002). "An inverse-Ackermann style lower bound for the online minimum spanning tree verification problem".

The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. Proceedings . pp.

155– 163.

doi : 10.1109/SFCS.2002.1181892 .

ISBN 0-7695-1822-2 .

S2CID 8636108 .

Porto, António; Matos, Armando B. (1 September 1980).

"Ackermann and the superpowers" (PDF) .

ACM SIGACT News .

12 (3): 90– 95.

doi : 10.1145/1008861.1008872 .

S2CID 29780652 .

Archived (PDF) from the original on 9 October 2022.

Original version 1980, published in ACM SIGACT News , modified on 20 October 2012 and 23 January 2016 (working paper) Ritchie, Robert Wells (November 1965).

"Classes of recursive functions based on Ackermann's function" .

Pacific Journal of Mathematics .

15 (3): 1027– 1044.

doi : 10.2140/pjm.1965.15.1027 .

Robinson, Raphael Mitchel (1948).

"Recursion and Double Recursion" .

Bulletin of the American Mathematical Society .

54 (10): 987– 93.

doi : 10.1090/S0002-9904-1948-09121-2 .

Sundblad, Yngve (March 1971). "The Ackermann function. A theoretical, computational, and formula manipulative study".

BIT Numerical Mathematics .

11 (1): 107– 119.

doi : 10.1007/BF01935330 .

S2CID 123416408 .

Tarjan, Robert Endre (1975). "Efficiency of a Good But Not Linear Set Union Algorithm".

Journal of the ACM .

22 (2): 215– 225.

doi : 10.1145/321879.321884 .

hdl : 1813/5942 .

S2CID 11105749 .

Vaida, Dragoș (1970). "Compiler Validation for an Algol-like Language".

Bulletin Mathématique de la Société des Sciences Mathématiques de la République Socialiste de Roumanie . Nouvelle série. 14 (62) (4): 487– 502.

JSTOR 43679758 .

Wainer, S. S. (1970). "A classification of the ordinal recursive functions".

Archiv für mathematische Logik und Grundlagenforschung .

13 : 136– 153.

doi : 10.1007/bf01973619 .

Ward, Martin P. (16 July 1993).

Iterative Procedures for Computing Ackerman's Function .

CiteSeerX 10.1.1.35.9907 .

Wichmann, Brian A. (March 1976). "Ackermann's function: A study in the efficiency of calling procedures".

BIT Numerical Mathematics .

16 : 103– 110.

CiteSeerX 10.1.1.108.4125 .

doi : 10.1007/BF01940783 .

S2CID 16993343 .

Wichmann, Brian A. (July 1977). "How to call procedures, or second thoughts on Ackermann's function".

BIT Numerical Mathematics .

16 (3): 103– 110.

doi : 10.1002/spe.4380070303 .

S2CID 206507320 .

Wichmann, Brian A. (July 1982).

"Latest results from the procedure calling test, Ackermann's function" (PDF) .

Archived (PDF) from the original on 9 October 2022.

External links "Ackermann function" .

Encyclopedia of Mathematics .

EMS Press . 2001 [1994].

Weisstein, Eric W.

"Ackermann function" .

MathWorld .

This article incorporates public domain material from Paul E. Black.

"Ackermann's function" .

Dictionary of Algorithms and Data Structures .

NIST .

An animated Ackermann function calculator Aaronson, Scott (1999).

"Who Can Name the Bigger Number?" .

Ackermann functions . Includes a table of some values.

Brubaker, Ben (4 December 2023).

"An Easy-Sounding Problem Yields Numbers Too Big for Our Universe" .

Munafo, Robert.

"Large Numbers" .

describes several variations on the definition of A .

Nivasch, Gabriel (October 2021).

"Inverse Ackermann without pain" .

Archived from the original on 21 August 2007 . Retrieved 18 June 2023 .

Seidel, Raimund.

"Understanding the inverse Ackermann function" (PDF) .

The Ackermann function written in different programming languages , (on Rosetta Code ) Smith, Harry J.

"Ackermann's Function" . Archived from the original on 26 October 2009.

) Some study and programming.

Wiernik, Ady; Sharir, Micha (1988).

"Planar realizations of nonlinear Davenport–Schinzel sequences by segments" .

Discrete & Computational Geometry .

3 (1): 15– 47.

doi : 10.1007/BF02187894 .

MR 0918177 .

v t e Hyperoperations Primary Successor (0) Addition (1) Multiplication (2) Exponentiation (3) Tetration (4) Pentation (5) Hexation (6) Inverse for left argument Predecessor (0) Subtraction (1) Division (2) Root extraction (3) Super-root (4) Inverse for right argument Predecessor (0) Subtraction (1) Division (2) Logarithm (3) Super-logarithm (4) Related articles Ackermann function Conway chained arrow notation Grzegorczyk hierarchy Knuth's up-arrow notation Steinhaus–Moser notation v t e Large numbers Examples in numerical order Hundred Thousand Ten thousand Hundred thousand Million Billion Trillion Quadrillion Quintillion Sextillion Septillion Octillion Nonillion Decillion Eddington number Googol Shannon number Googolplex Skewes's number Moser's number Graham's number TREE(3) SSCG(3) BH(3) Rayo's number Expression methods Notations Scientific notation Knuth's up-arrow notation Conway chained arrow notation Steinhaus–Moser notation Operators Hyperoperation Tetration Pentation Ackermann function Grzegorczyk hierarchy Fast-growing hierarchy Related articles (alphabetical order) Busy beaver Extended real number line Indefinite and fictitious numbers Infinitesimal Largest known prime number List of numbers Long and short scales Number systems Number names Orders of magnitude Power of two Power of three Power of 10 Sagan Unit Names History NewPP limit report
Parsed by mw‐web.codfw.main‐6cc77c66b8‐brls5
Cached time: 20250811234926
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 1.435 seconds
Real time usage: 2.069 seconds
Preprocessor visited node count: 9652/1000000
Revision size: 63897/2097152 bytes
Post‐expand include size: 142992/2097152 bytes
Template argument size: 7464/2097152 bytes
Highest expansion depth: 17/100
Expensive parser function count: 9/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 154564/5000000 bytes
Lua time usage: 0.771/10.000 seconds
Lua memory usage: 10078301/52428800 bytes
Number of Wikibase entities loaded: 1/500 Transclusion expansion time report (%,ms,calls,template)
100.00% 1387.528      1 -total
 16.29%  226.097      2 Template:Reflist
 10.74%  149.084     13 Template:Cite_web
  9.60%  133.159     18 Template:Cite_journal
  9.30%  129.056     35 Template:Sfn
  8.99%  124.687      1 Template:Short_description
  6.77%   93.956      2 Template:Pagetype
  6.13%   85.056    114 Template:Space
  5.91%   82.048      3 Template:Navbox
  5.59%   77.517      1 Template:Hyperoperations Saved in parser cache with key enwiki:pcache:2925:|#|:idhash:canonical and timestamp 20250811234926 and revision id 1296966976. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Ackermann_function&oldid=1296966976 " Categories : Arithmetic Large integers Special functions Theory of computation Computability theory Hidden categories: Wikipedia semi-protected pages Articles with short description Short description is different from Wikidata Use dmy dates from October 2024 Use shortened footnotes from November 2022 CS1 German-language sources (de) CS1: long volume value This page was last edited on 23 June 2025, at 11:24 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Ackermann function 27 languages Add topic

