Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Overview 2 Criticism 3 History 4 Languages and paradigms Toggle Languages and paradigms subsection 4.1 Machine code 4.2 Assembly 4.3 Procedural languages 4.4 Object-oriented programming 4.5 Declarative languages 4.6 Other paradigms 5 See also 6 References 7 External links Toggle the table of contents Programming paradigm 53 languages العربية Asturianu Azərbaycanca বাংলা Беларуская (тарашкевіца) Български Bosanski Català Čeština Dansk Deutsch Eesti Ελληνικά Español Esperanto Euskara فارسی Français Galego 한국어 Bahasa Indonesia Italiano עברית Kiswahili Latina Latviešu Magyar Македонски മലയാളം Bahasa Melayu Mirandés Nederlands 日本語 Norsk bokmål Piemontèis Polski Português Qaraqalpaqsha Română Русский Shqip Simple English Српски / srpski Srpskohrvatski / српскохрватски Suomi Svenska ไทย Türkçe Українська اردو Tiếng Việt 粵語 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia High-level computer programming conceptualization This article is about classification of programming languages. For definition of the term "programming model", see Programming model .

A programming paradigm is a relatively high-level way to conceptualize and structure the implementation of a computer program . A programming language can be classified as supporting one or more paradigms.

[ 1 ] Paradigms are separated along and described by different dimensions of programming. Some paradigms are about implications of the execution model , such as allowing side effects , or whether the sequence of operations is defined by the execution model. Other paradigms are about the way code is organized, such as grouping into units that include both state and behavior. Yet others are about syntax and grammar .

Some common programming paradigms include (shown in hierarchical relationship ): [ 2 ] [ 3 ] [ 4 ] Imperative – code directly controls execution flow and state change, explicit statements that change a program state procedural – organized as procedures that call each other object-oriented – organized as objects that contain both data structure and associated behavior, uses data structures consisting of data fields and methods together with their interactions (objects) to design programs Class-based – object-oriented programming in which inheritance is achieved by defining classes of objects, versus the objects themselves Prototype-based – object-oriented programming that avoids classes and implements inheritance via cloning of instances Declarative – code declares properties of the desired result, but not how to compute it, describes what computation should perform, without specifying detailed state changes functional – a desired result is declared as the value of a series of function evaluations, uses evaluation of mathematical functions and avoids state and mutable data logic – a desired result is declared as the answer to a question about a system of facts and rules, uses explicit mathematical logic for programming reactive – a desired result is declared with data streams and the propagation of change Concurrent programming – has language constructs for concurrency, these may involve multi-threading, support for distributed computing, message passing, shared resources (including shared memory), or futures Actor programming – concurrent computation with actors that make local decisions in response to the environment (capable of selfish or competitive behaviour) Constraint programming – relations between variables are expressed as constraints (or constraint networks), directing allowable solutions (uses constraint satisfaction or simplex algorithm ) Dataflow programming – forced recalculation of formulas when data values change (e.g.

spreadsheets ) Distributed programming – has support for multiple autonomous computers that communicate via computer networks Generic programming – uses algorithms written in terms of to-be-specified-later types that are then instantiated as needed for specific types provided as parameters Metaprogramming – writing programs that write or manipulate other programs (or themselves) as their data, or that do part of the work at compile time that would otherwise be done at runtime Template metaprogramming – metaprogramming methods in which a compiler uses templates to generate temporary source code, which is merged by the compiler with the rest of the source code and then compiled Reflective programming – metaprogramming methods in which a program modifies or extends itself Pipeline programming – a simple syntax change to add syntax to nest function calls to language originally designed with none Rule-based programming – a network of rules of thumb that comprise a knowledge base and can be used for expert systems and problem deduction & resolution Visual programming – manipulating program elements graphically rather than by specifying them textually (e.g.

Simulink ); also termed diagrammatic programming' Overview [ edit ] Overview of the various programming paradigms according to Peter Van Roy [ 5 ] : 5 [ 6 ] Programming paradigms come from computer science research into existing practices of software development . The findings allow for describing and comparing programming practices and the languages used to code programs. For perspective, other fields of research study software engineering processes and describe various methodologies to describe and compare them.

A programming language can be described in terms of paradigms. Some languages support only one paradigm. For example, Smalltalk supports object-oriented and Haskell supports functional. Most languages support multiple paradigms. For example, a program written in C++ , Object Pascal , or PHP can be purely procedural , purely object-oriented , or can contain aspects of both paradigms, or others.

When using a language that supports multiple paradigms, the developer chooses which paradigm elements to use. But, this choice may not involve considering paradigms per se. The developer often uses the features of a language as the language provides them and to the extent that the developer knows them. Categorizing the resulting code by paradigm is often an academic activity done in retrospect.

Languages categorized as imperative paradigm have two main features: they state the order in which operations occur, with constructs that explicitly control that order, and they allow side effects, in which state can be modified at one point in time, within one unit of code, and then later read at a different point in time inside a different unit of code.  The communication between the units of code is not explicit.

In contrast, languages in the declarative paradigm do not state the order in which to execute operations. Instead, they supply a number of available operations in the system, along with the conditions under which each is allowed to execute.

[ 7 ] The implementation of the language's execution model tracks which operations are free to execute and chooses the order independently. More at Comparison of multi-paradigm programming languages .

In object-oriented programming, code is organized into objects that contain state that is owned by and (usually) controlled by the code of the object.  Most object-oriented languages are also imperative languages.

In object-oriented programming, programs are treated as a set of interacting objects. In functional programming , programs are treated as a sequence of stateless function evaluations. When programming computers or systems with many processors, in process-oriented programming , programs are treated as sets of concurrent processes that act on a logical shared data structures .

Many programming paradigms are as well known for the techniques they forbid as for those they support . For instance, pure functional programming disallows side-effects , while structured programming disallows the goto construct. Partly for this reason, new paradigms are often regarded as doctrinaire or overly rigid by those accustomed to older ones.

[ 8 ] Yet, avoiding certain techniques can make it easier to understand program behavior, and to prove theorems about program correctness.

Programming paradigms can also be compared with programming models , which allows invoking an execution model by using only an API. Programming models can also be classified into paradigms based on features of the execution model.

For parallel computing , using a programming model instead of a language is common.  The reason is that details of the parallel hardware leak into the abstractions used to program the hardware.  This causes the programmer to have to map patterns in the algorithm onto patterns in the execution model (which have been inserted due to leakage of hardware into the abstraction).  As a consequence, no one parallel programming language maps well to all computation problems.  Thus, it is more convenient to use a base sequential language and insert API calls to parallel execution models via a programming model.  Such parallel programming models can be classified according to abstractions that reflect the hardware, such as shared memory , distributed memory with message passing , notions of place visible in the code, and so forth.  These can be considered flavors of programming paradigm that apply to only parallel languages and programming models.

Criticism [ edit ] Some programming language researchers criticise the notion of paradigms as a classification of programming languages, e.g. Harper, [ 9 ] and Krishnamurthi.

[ 10 ] They argue that many programming languages cannot be strictly classified into one paradigm, but rather include features from several paradigms. See Comparison of multi-paradigm programming languages .

History [ edit ] Different approaches to programming have developed over time. Classification of each approach was either described at the time the approach was first developed, but often not until some time later, retrospectively. An early approach consciously identified as such is structured programming , advocated since the mid 1960s. The concept of a programming paradigm as such dates at least to 1978, in the Turing Award lecture of Robert W. Floyd , entitled The Paradigms of Programming , which cites the notion of paradigm as used by Thomas Kuhn in his The Structure of Scientific Revolutions (1962).

[ 11 ] Early programming languages did not have clearly defined programming paradigms and sometimes programs made extensive use of goto statements. Liberal use of which lead to spaghetti code which is difficult to understand and maintain. This led to the development of structured programming paradigms that disallowed the use of goto statements; only allowing the use of more structured programming constructs.

[ 12 ] Languages and paradigms [ edit ] Machine code [ edit ] Machine code is the lowest-level of computer programming as it is machine instructions that define behavior at the lowest level of abstract possible for a computer. As it is the most prescriptive way to code it is classified as imperative.

It is sometimes called the first-generation programming language .

Assembly [ edit ] Assembly language introduced mnemonics for machine instructions and memory addresses . Assembly is classified as imperative and is sometimes called the second-generation programming language .

In the 1960s, assembly languages were developed to support library COPY and quite sophisticated conditional macro generation and preprocessing abilities, CALL to subroutine , external variables and common sections (globals), enabling significant code re-use and isolation from hardware specifics via the use of logical operators such as READ/WRITE/GET/PUT. Assembly was, and still is, used for time-critical systems and often in embedded systems as it gives the most control of what the machine does.

Procedural languages [ edit ] Procedural languages , also called the third-generation programming languages are the first described as high-level languages . They support vocabulary related to the problem being solved. For example, COmmon Business Oriented Language ( COBOL ) –  uses terms like file , move and copy .

FORmula TRANslation ( FORTRAN ) –  using mathematical language terminology, it was developed mainly for scientific and engineering problems.

ALGOrithmic Language ( ALGOL ) –  focused on being an appropriate language to define algorithms , while using mathematical language terminology, targeting scientific and engineering problems, just like FORTRAN.

Programming Language One ( PL/I ) –  a hybrid commercial-scientific general purpose language supporting pointers .

Beginners All purpose Symbolic Instruction Code ( BASIC ) –  it was developed to enable more people to write programs.

C –  a general-purpose programming language, initially developed by Dennis Ritchie between 1969 and 1973 at AT&T Bell Labs .

These languages are classified as procedural paradigm. They directly control the step by step process that a computer program follows. The efficacy and efficiency of such a program is therefore highly dependent on the programmer's skill.

Object-oriented programming [ edit ] Main article: Object-oriented programming In attempt to improve on procedural languages, object-oriented programming (OOP) languages were created, such as Simula , Smalltalk , C++ , Eiffel , Python , PHP , Java , and C# . In these languages, data and methods to manipulate the data are in the same code unit called an object . This encapsulation ensures that the only way that an object can access data is via methods of the object that contains the data. Thus, an object's inner workings may be changed without affecting code that uses the object.

There is controversy raised by Alexander Stepanov , Richard Stallman [ 13 ] and other programmers, concerning the efficacy of the OOP paradigm versus the procedural paradigm. The need for every object to have associative methods leads some skeptics to associate OOP with software bloat ; an attempt to resolve this dilemma came through polymorphism .

Although most OOP languages are third-generation, it is possible to create an object-oriented assembler language.

High Level Assembly (HLA) is an example of this that fully supports advanced data types and object-oriented assembly language programming –  despite its early origins. Thus, differing programming paradigms can be seen rather like motivational memes of their advocates, rather than necessarily representing progress from one level to the next.

[ citation needed ] Precise comparisons of competing paradigms' efficacy are frequently made more difficult because of new and differing terminology applied to similar entities and processes together with numerous implementation distinctions across languages.

Declarative languages [ edit ] A declarative programming program describes what the problem is, not how to solve it. The program is structured as a set of properties to find in the expected result, not as a procedure to follow. Given a database or a set of rules, the computer tries to find a solution matching all the desired properties. An archetype of a declarative language is the fourth generation language SQL , and the family of functional languages and logic programming.

Functional programming is a subset of declarative programming. Programs written using this paradigm use functions , blocks of code intended to behave like mathematical functions . Functional languages discourage changes in the value of variables through assignment , making a great deal of use of recursion instead.

The logic programming paradigm views computation as automated reasoning over a body of knowledge. Facts about the problem domain are expressed as logic formulas, and programs are executed by applying inference rules over them until an answer to the problem is found, or the set of formulas is proved inconsistent.

Other paradigms [ edit ] Symbolic programming is a paradigm that describes programs able to manipulate formulas and program components as data.

[ 4 ] Programs can thus effectively modify themselves, and appear to "learn", making them suited for applications such as artificial intelligence , expert systems , natural-language processing and computer games. Languages that support this paradigm include Lisp and Prolog .

[ 14 ] Differentiable programming structures programs so that they can be differentiated throughout, usually via automatic differentiation .

[ 15 ] [ 16 ] Literate programming , as a form of imperative programming , structures programs as a human-centered web, as in a hypertext essay: documentation is integral to the program, and the program is structured following the logic of prose exposition, rather than compiler convenience.

Symbolic programming techniques such as reflective programming (reflection), which allow a program to refer to itself, might also be considered as a programming paradigm. However, this is compatible with the major paradigms and thus is not a real paradigm in its own right.

See also [ edit ] Computer programming portal Domain-specific language Flow-based programming Modeling language Programming domain Turing completeness Von Neumann programming languages References [ edit ] ^ "Multi-Paradigm Programming Language" .

Mozilla Developer Network .

Mozilla Foundation . Jun 21, 2013. Archived from the original on 21 August 2013.

^ Nørmark, Kurt.

Overview of the four main programming paradigms . Aalborg University, 9 May 2011. Retrieved 22 September 2012.

^ Frans Coenen (1999-10-11).

"Characteristics of declarative programming languages" .

cgi.csc.liv.ac.uk .

Archived from the original on 2014-02-27 . Retrieved 2014-02-20 .

^ a b Michael A. Covington (2010-08-23).

"CSCI/ARTI 4540/6540: First Lecture on Symbolic Programming and LISP" (PDF) . University of Georgia. Archived from the original (PDF) on 2012-03-07 . Retrieved 2013-11-20 .

^ Peter Van Roy (2009-05-12).

"Programming Paradigms: What Every Programmer Should Know" (PDF) . info.ucl.ac.be . Retrieved 2014-01-27 .

^ Peter Van-Roy; Seif Haridi (2004).

Concepts, Techniques, and Models of Computer Programming . MIT Press.

ISBN 978-0-262-22069-9 .

^ "Programming paradigms: What are the principles of programming?" .

IONOS Digitalguide . 20 April 2020.

Archived from the original on Jun 29, 2022 . Retrieved 2022-05-03 .

^ Frank Rubin (March 1987).

" 'GOTO Considered Harmful' Considered Harmful" (PDF) .

Communications of the ACM .

30 (3): 195– 196.

doi : 10.1145/214748.315722 .

S2CID 6853038 . Archived from the original (PDF) on March 20, 2009.

^ Harper, Robert (1 May 2017).

"What, if anything, is a programming-paradigm?" .

FifteenEightyFour . Cambridge University Press.

^ Krishnamurthi, Shriram (November 2008).

"Teaching programming languages in a post-linnaean age" .

ACM SIGPLAN Notices .

43 (11). ACM: 81– 83.

doi : 10.1145/1480828.1480846 .

S2CID 35714982 .

.

^ Floyd, R. W. (1979).

"The paradigms of programming" .

Communications of the ACM .

22 (8): 455– 460.

doi : 10.1145/359138.359140 .

^ Soroka, Barry I. (2006).

Java 5: Objects First . Jones & Bartlett Learning.

ISBN 9780763737207 .

^ "Mode inheritance, cloning, hooks & OOP (Google Groups Discussion)" .

^ "Business glossary: Symbolic programming definition" .

allbusiness.com . Retrieved 2014-07-30 .

^ Wang, Fei; Decker, James; Wu, Xilun; Essertel, Gregory; Rompf, Tiark (2018), Bengio, S.; Wallach, H.; Larochelle, H.; Grauman, K. (eds.), "Backpropagation with Callbacks: Foundations for Efficient and Expressive Differentiable Programming" (PDF) , Advances in Neural Information Processing Systems 31 , Curran Associates, Inc., pp.

10201– 10212 , retrieved 2019-02-13 ^ Innes, Mike (2018).

"On Machine Learning and Programming Languages" (PDF) .

SysML Conference 2018 . Archived from the original (PDF) on 2018-09-20 . Retrieved 2019-02-13 .

External links [ edit ] Wikimedia Commons has media related to Programming language by paradigm .

Classification of the principal programming paradigms How programming paradigms evolve and get adopted?

Software engineering v t e Types of computer language Types Architecture description Data exchange Hardware description Knowledge representation Markup Modeling Programming language Query Shading Specification Stylesheet Transformation See also Category:Lists of computer languages Category:Lists of programming languages List of programming languages by type v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Systems design Requirements Functional requirement Non-functional requirement Capacity Users Compute Memory Storage Network Web traffic Interface API SOAP REST GraphQL gRPC Webhook High-level design Client Load balancing Application server Message queue Integration Vertical Peer-to-peer API gateway pub-sub Event source ETL Batch Stream Orchestration Architectures Monolithic Microservices Event-driven Client–server Serverless Circuit breaker Rate limiting Database Relational NoSQL Graph Key–value LSM tree Time series Column oriented Principles Consistency Reliability CAP theorem Maintainability Configurability Modularity Durability Scalability Stateless Asynchronous I/O Loose coupling Availability Fault tolerance Failover Single point of failure Replication Consistent hashing Circuit breaker Latency Cache CDN Shard Database index Pre-caching Storage Object storage Block storage Observability Logging Metrics Tracing Error rate Queries per second Notification system Anomaly detection Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Commons Category v t e Computer science Note: This template roughly follows the 2012 ACM Computing Classification System .

Hardware Printed circuit board Peripheral Integrated circuit Very-large-scale integration System on a chip (SoC) Energy consumption (green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Cyber-physical system Fault tolerance Wireless sensor network Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control variable Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human–centered computing Interaction design Augmented reality Virtual reality Social computing Ubiquitous computing Visualization Accessibility Human–computer interaction Mobile computing Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Image compression Solid modeling Applied computing Quantum computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Category Outline Glossaries Programming v t e Programming paradigms ( Comparison by language ) Imperative Structured Jackson structures Block-structured Modular Non-structured Procedural Programming in the large and in the small Design by contract Invariant-based Nested function Object-oriented ( comparison , list ) Class-based , Prototype-based , Object-based Agent Immutable object Persistent Uniform function call syntax Declarative Functional ( comparison ) Recursive Anonymous function ( Partial application ) Higher-order Purely functional Total Strict GADTs Dependent types Functional logic Point-free style Expression-oriented Applicative , Concatenative Function-level , Value-level Dataflow Flow-based Reactive ( Functional reactive ) Signals Streams Synchronous Logic Abductive logic Answer set Constraint ( Constraint logic ) Inductive logic Nondeterministic Ontology Probabilistic logic Query Domain- specific language (DSL) Algebraic modeling Array Automata-based ( Action ) Command ( Spacecraft ) Differentiable End-user Grammar-oriented Interface description Language-oriented List comprehension Low-code Modeling Natural language Non-English-based Page description Pipes and filters Probabilistic Quantum Scientific Scripting Set-theoretic Simulation Stack-based System Tactile Templating Transformation ( Graph rewriting , Production , Pattern ) Visual Concurrent , distributed , parallel Actor-based Automatic mutual exclusion Choreographic programming Concurrent logic ( Concurrent constraint logic ) Concurrent OO Macroprogramming Multitier programming Organic computing Parallel programming models Partitioned global address space Process-oriented Relativistic programming Service-oriented Structured concurrency Metaprogramming Attribute-oriented Automatic ( Inductive ) Dynamic Extensible Generic Homoiconicity Interactive Macro ( Hygienic ) Metalinguistic abstraction Multi-stage Program synthesis ( Bayesian , Inferential , by demonstration , by example ) Reflective Self-modifying code Symbolic Template Separation of concerns Aspects Components Data-driven Data-oriented Event-driven Features Literate Roles Subjects v t e Types of programming languages Level Machine Assembly Compiled Interpreted Low-level High-level Very high-level Esoteric Generation First Second Third Fourth Fifth v t e Programming languages Comparison Timeline History Ada ALGOL Simula APL Assembly BASIC Visual Basic classic .NET C C++ C# COBOL Erlang Elixir Forth Fortran Go Haskell Java JavaScript Julia Kotlin Lisp Lua MATLAB ML Caml OCaml Pascal Object Pascal Perl Raku PHP Prolog Python R Ruby Rust SAS SQL Scratch Shell Smalltalk Swift more...

Lists: Alphabetical Categorical Generational Non-English-based Category v t e Types of programming languages Level Machine Assembly Compiled Interpreted Low-level High-level Very high-level Esoteric Generation First Second Third Fourth Fifth v t e Computer science Note: This template roughly follows the 2012 ACM Computing Classification System .

Hardware Printed circuit board Peripheral Integrated circuit Very-large-scale integration System on a chip (SoC) Energy consumption (green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Cyber-physical system Fault tolerance Wireless sensor network Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control variable Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human–centered computing Interaction design Augmented reality Virtual reality Social computing Ubiquitous computing Visualization Accessibility Human–computer interaction Mobile computing Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Image compression Solid modeling Applied computing Quantum computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Category Outline Glossaries Authority control databases : National Germany NewPP limit report
Parsed by mw‐web.codfw.main‐7c956d68b4‐wbpml
Cached time: 20250817070316
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.636 seconds
Real time usage: 0.800 seconds
Preprocessor visited node count: 2711/1000000
Revision size: 24911/2097152 bytes
Post‐expand include size: 279173/2097152 bytes
Template argument size: 82043/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 5/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 134458/5000000 bytes
Lua time usage: 0.341/10.000 seconds
Lua memory usage: 7054472/52428800 bytes
Number of Wikibase entities loaded: 1/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  595.217      1 -total
 31.27%  186.114      1 Template:Reflist
 24.15%  143.751      2 Template:Navboxes
 21.43%  127.531     11 Template:Navbox
 19.09%  113.648      8 Template:Cite_web
 13.18%   78.470      1 Template:Short_description
 12.58%   74.888      1 Template:Computer_language
  9.40%   55.959      1 Template:Commons_category
  9.05%   53.896      1 Template:Sister_project
  8.77%   52.214      1 Template:Side_box Saved in parser cache with key enwiki:pcache:189897:|#|:idhash:canonical and timestamp 20250817070316 and revision id 1297024545. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Programming_paradigm&oldid=1297024545 " Categories : Programming paradigms Programming language classification Programming language topics Hidden categories: Articles with short description Short description is different from Wikidata All articles with unsourced statements Articles with unsourced statements from March 2018 Commons category link is on Wikidata This page was last edited on 23 June 2025, at 19:04 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Programming paradigm 53 languages Add topic

