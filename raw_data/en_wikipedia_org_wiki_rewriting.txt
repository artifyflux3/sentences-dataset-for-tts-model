Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Example cases Toggle Example cases subsection 1.1 Logic 1.2 Arithmetic 1.3 Linguistics 2 Abstract rewriting systems 3 String rewriting systems 4 Term rewriting systems Toggle Term rewriting systems subsection 4.1 Formal definition 4.2 Termination 4.3 Higher-order rewriting systems 4.4 Graph rewriting systems 5 Trace rewriting systems 6 See also 7 Notes 8 Further reading 9 External links 10 References Toggle the table of contents Rewriting 16 languages Deutsch Español فارسی Français 한국어 Ido IsiZulu Italiano Nederlands 日本語 Português Qaraqalpaqsha Русский Türkçe Українська 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Replacing subterm in a formula with another term For other uses, see Rewriting (disambiguation) .

In mathematics , linguistics , computer science , and logic , rewriting covers a wide range of methods of replacing subterms of a formula with other terms. Such methods may be achieved by rewriting systems (also known as rewrite systems , rewrite engines , [ 1 ] [ 2 ] or reduction systems ). In their most basic form, they consist of a set of objects, plus relations on how to transform those objects.

Rewriting can be non-deterministic . One rule to rewrite a term could be applied in many different ways to that term, or more than one rule could be applicable. Rewriting systems then do not provide an algorithm for changing one term to another, but a set of possible rule applications. When combined with an appropriate algorithm, however, rewrite systems can be viewed as computer programs , and several theorem provers [ 3 ] and declarative programming languages are based on term rewriting.

[ 4 ] [ 5 ] Example cases [ edit ] Logic [ edit ] In logic , the procedure for obtaining the conjunctive normal form (CNF) of a formula can be implemented as a rewriting system.

[ 6 ] For example, the rules of such a system would be: ¬ ¬ ¬ ¬ A → → A {\displaystyle \neg \neg A\to A} ( double negation elimination ) ¬ ¬ ( A ∧ ∧ B ) → → ¬ ¬ A ∨ ∨ ¬ ¬ B {\displaystyle \neg (A\land B)\to \neg A\lor \neg B} ( De Morgan's laws ) ¬ ¬ ( A ∨ ∨ B ) → → ¬ ¬ A ∧ ∧ ¬ ¬ B {\displaystyle \neg (A\lor B)\to \neg A\land \neg B} ( A ∧ ∧ B ) ∨ ∨ C → → ( A ∨ ∨ C ) ∧ ∧ ( B ∨ ∨ C ) {\displaystyle (A\land B)\lor C\to (A\lor C)\land (B\lor C)} ( distributivity ) A ∨ ∨ ( B ∧ ∧ C ) → → ( A ∨ ∨ B ) ∧ ∧ ( A ∨ ∨ C ) , {\displaystyle A\lor (B\land C)\to (A\lor B)\land (A\lor C),} [ note 1 ] For each rule, each variable denotes a subexpression, and the symbol ( → → {\displaystyle \to } ) indicates that an expression matching the left hand side of it can be rewritten to one matching the right hand side of it. In such a system, each rule is a logical equivalence , so performing a rewrite on an expression by these rules does not change the truth value of it. Other useful rewriting systems in logic may not preserve truth values, see e.g.

equisatisfiability .

Arithmetic [ edit ] Term rewriting systems can be employed to compute arithmetic operations on natural numbers .
To this end, each such number has to be encoded as a term .
The simplest encoding is the one used in the Peano axioms , based on the constant 0 (zero) and the successor function S . For example, the numbers 0, 1, 2, and 3 are represented by the terms 0, S(0), S(S(0)), and S(S(S(0))), respectively.
The following term rewriting system can then be used to compute sum and product of given natural numbers.

[ 7 ] A + 0 → → A (1) , A + S ( B ) → → S ( A + B ) (2) , A ⋅ ⋅ 0 → → 0 (3) , A ⋅ ⋅ S ( B ) → → A + ( A ⋅ ⋅ B ) (4) .

{\displaystyle {\begin{aligned}A+0&\to A&{\textrm {(1)}},\\A+S(B)&\to S(A+B)&{\textrm {(2)}},\\A\cdot 0&\to 0&{\textrm {(3)}},\\A\cdot S(B)&\to A+(A\cdot B)&{\textrm {(4)}}.\end{aligned}}} For example, the computation of 2+2 to result in 4 can be duplicated by term rewriting as follows: S ( S ( 0 ) ) + S ( S ( 0 ) ) {\displaystyle S(S(0))+S(S(0))} → → ( 2 ) {\displaystyle \;\;{\stackrel {(2)}{\to }}\;\;} S ( S ( S ( 0 ) ) + S ( 0 ) ) {\displaystyle S(\;S(S(0))+S(0)\;)} → → ( 2 ) {\displaystyle \;\;{\stackrel {(2)}{\to }}\;\;} S ( S ( S ( S ( 0 ) ) + 0 ) ) {\displaystyle S(S(\;S(S(0))+0\;))} → → ( 1 ) {\displaystyle \;\;{\stackrel {(1)}{\to }}\;\;} S ( S ( S ( S ( 0 ) ) ) ) , {\displaystyle S(S(S(S(0)))),} where the notation above each arrow indicates the rule used for each rewrite.

As another example, the computation of 2⋅2 looks like: S ( S ( 0 ) ) ⋅ ⋅ S ( S ( 0 ) ) {\displaystyle S(S(0))\cdot S(S(0))} → → ( 4 ) {\displaystyle \;\;{\stackrel {(4)}{\to }}\;\;} S ( S ( 0 ) ) + S ( S ( 0 ) ) ⋅ ⋅ S ( 0 ) {\displaystyle S(S(0))+S(S(0))\cdot S(0)} → → ( 4 ) {\displaystyle \;\;{\stackrel {(4)}{\to }}\;\;} S ( S ( 0 ) ) + S ( S ( 0 ) ) + S ( S ( 0 ) ) ⋅ ⋅ 0 {\displaystyle S(S(0))+S(S(0))+S(S(0))\cdot 0} → → ( 3 ) {\displaystyle \;\;{\stackrel {(3)}{\to }}\;\;} S ( S ( 0 ) ) + S ( S ( 0 ) ) + 0 {\displaystyle S(S(0))+S(S(0))+0} → → ( 1 ) {\displaystyle \;\;{\stackrel {(1)}{\to }}\;\;} S ( S ( 0 ) ) + S ( S ( 0 ) ) {\displaystyle S(S(0))+S(S(0))} → → s.a.

{\displaystyle \;\;{\stackrel {\textrm {s.a.}}{\to }}\;\;} S ( S ( S ( S ( 0 ) ) ) ) , {\displaystyle S(S(S(S(0)))),} where the last step comprises the previous example computation.

Linguistics [ edit ] In linguistics , phrase structure rules , also called rewrite rules , are used in some systems of generative grammar , [ 8 ] as a means of generating the grammatically correct sentences of a language. Such a rule typically takes the form A → → X {\displaystyle {\rm {A\rightarrow X}}} , where A is a syntactic category label, such as noun phrase or sentence , and X is a sequence of such labels or morphemes , expressing the fact that A can be replaced by X in generating the constituent structure of a sentence. For example, the rule S → → N P V P {\displaystyle {\rm {S\rightarrow NP\ VP}}} means that a sentence can consist of a noun phrase (NP) followed by a verb phrase (VP); further rules will specify what sub-constituents a noun phrase and a verb phrase can consist of, and so on.

Abstract rewriting systems [ edit ] Main article: Abstract rewriting system From the above examples, it is clear that we can think of rewriting systems in an abstract manner. We need to specify a set of objects and the rules that can be applied to transform them. The most general (unidimensional) setting of this notion is called an abstract reduction system [ 9 ] or abstract rewriting system (abbreviated ARS ).

[ 10 ] An ARS is simply a set A of objects, together with a binary relation → on A called the reduction relation , rewrite relation [ 11 ] or just reduction .

[ 9 ] Many notions and notations can be defined in the general setting of an ARS.

→ → ∗ ∗ {\displaystyle {\overset {*}{\rightarrow }}} is the reflexive transitive closure of → → {\displaystyle \rightarrow } .

↔ ↔ {\displaystyle \leftrightarrow } is the symmetric closure of → → {\displaystyle \rightarrow } .

↔ ↔ ∗ ∗ {\displaystyle {\overset {*}{\leftrightarrow }}} is the reflexive transitive symmetric closure of → → {\displaystyle \rightarrow } . The word problem for an ARS is determining, given x and y , whether x ↔ ↔ ∗ ∗ y {\displaystyle x{\overset {*}{\leftrightarrow }}y} . An object x in A is called reducible if there exists some other y in A such that x → → y {\displaystyle x\rightarrow y} ; otherwise it is called irreducible or a normal form . An object y is called a "normal form of x " if x → → ∗ ∗ y {\displaystyle x{\stackrel {*}{\rightarrow }}y} , and y is irreducible. If the normal form of x is unique, then this is usually denoted with x ↓ ↓ {\displaystyle x{\downarrow }} . If every object has at least one normal form, the ARS is called normalizing .

x ↓ ↓ y {\displaystyle x\downarrow y} or x and y are said to be joinable if there exists some z with the property that x → → ∗ ∗ z ← ← ∗ ∗ y {\displaystyle x{\overset {*}{\rightarrow }}z{\overset {*}{\leftarrow }}y} . An ARS is said to possess the Church–Rosser property if x ↔ ↔ ∗ ∗ y {\displaystyle x{\overset {*}{\leftrightarrow }}y} implies x ↓ ↓ y {\displaystyle x\downarrow y} . An ARS is confluent if for all w , x , and y in A , x ← ← ∗ ∗ w → → ∗ ∗ y {\displaystyle x{\overset {*}{\leftarrow }}w{\overset {*}{\rightarrow }}y} implies x ↓ ↓ y {\displaystyle x\downarrow y} . An ARS is locally confluent if and only if for all w , x , and y in A , x ← ← w → → y {\displaystyle x\leftarrow w\rightarrow y} implies x ↓ ↓ y {\displaystyle x{\mathbin {\downarrow }}y} . An ARS is said to be terminating or noetherian if there is no infinite chain x 0 → → x 1 → → x 2 → → ⋯ ⋯ {\displaystyle x_{0}\rightarrow x_{1}\rightarrow x_{2}\rightarrow \cdots } . A confluent and terminating ARS is called convergent or canonical .

Important theorems for abstract rewriting systems are that an ARS is confluent iff it has the Church–Rosser property, Newman's lemma (a terminating ARS is confluent if and only if it is locally confluent), and that the word problem for an ARS is undecidable in general.

String rewriting systems [ edit ] Main article: String rewriting system A string rewriting system (SRS), also known as semi-Thue system , exploits the free monoid structure of the strings (words) over an alphabet to extend a rewriting relation, R {\displaystyle R} , to all strings in the alphabet that contain left- and respectively right-hand sides of some rules as substrings . Formally a semi-Thue system is a tuple ( Σ Σ , R ) {\displaystyle (\Sigma ,R)} where Σ Σ {\displaystyle \Sigma } is a (usually finite) alphabet, and R {\displaystyle R} is a binary relation between some (fixed) strings in the alphabet, called the set of rewrite rules . The one-step rewriting relation → → R {\displaystyle {\underset {R}{\rightarrow }}} induced by R {\displaystyle R} on Σ Σ ∗ ∗ {\displaystyle \Sigma ^{*}} is defined as: if s , t ∈ ∈ Σ Σ ∗ ∗ {\displaystyle s,t\in \Sigma ^{*}} are any strings, then s → → R t {\displaystyle s{\underset {R}{\rightarrow }}t} if there exist x , y , u , v ∈ ∈ Σ Σ ∗ ∗ {\displaystyle x,y,u,v\in \Sigma ^{*}} such that s = x u y {\displaystyle s=xuy} , t = x v y {\displaystyle t=xvy} , and u R v {\displaystyle uRv} . Since → → R {\displaystyle {\underset {R}{\rightarrow }}} is a relation on Σ Σ ∗ ∗ {\displaystyle \Sigma ^{*}} , the pair ( Σ Σ ∗ ∗ , → → R ) {\displaystyle (\Sigma ^{*},{\underset {R}{\rightarrow }})} fits the definition of an abstract rewriting system. Since the empty string is in Σ Σ ∗ ∗ {\displaystyle \Sigma ^{*}} , R {\displaystyle R} is a subset of → → R {\displaystyle {\underset {R}{\rightarrow }}} . If the relation R {\displaystyle R} is symmetric , then the system is called a Thue system .

In a SRS, the reduction relation → → R ∗ ∗ {\displaystyle {\overset {*}{\underset {R}{\rightarrow }}}} is compatible with the monoid operation, meaning that x → → R ∗ ∗ y {\displaystyle x{\overset {*}{\underset {R}{\rightarrow }}}y} implies u x v → → R ∗ ∗ u y v {\displaystyle uxv{\overset {*}{\underset {R}{\rightarrow }}}uyv} for all strings x , y , u , v ∈ ∈ Σ Σ ∗ ∗ {\displaystyle x,y,u,v\in \Sigma ^{*}} . Similarly, the reflexive transitive symmetric closure of → → R {\displaystyle {\underset {R}{\rightarrow }}} , denoted ↔ ↔ R ∗ ∗ {\displaystyle {\overset {*}{\underset {R}{\leftrightarrow }}}} , is a congruence , meaning it is an equivalence relation (by definition) and it is also compatible with string concatenation. The relation ↔ ↔ R ∗ ∗ {\displaystyle {\overset {*}{\underset {R}{\leftrightarrow }}}} is called the Thue congruence generated by R {\displaystyle R} . In a Thue system, i.e. if R {\displaystyle R} is symmetric, the rewrite relation → → R ∗ ∗ {\displaystyle {\overset {*}{\underset {R}{\rightarrow }}}} coincides with the Thue congruence ↔ ↔ R ∗ ∗ {\displaystyle {\overset {*}{\underset {R}{\leftrightarrow }}}} .

The notion of a semi-Thue system essentially coincides with the presentation of a monoid . Since ↔ ↔ R ∗ ∗ {\displaystyle {\overset {*}{\underset {R}{\leftrightarrow }}}} is a congruence, we can define the factor monoid M R = Σ Σ ∗ ∗ / ↔ ↔ R ∗ ∗ {\displaystyle {\mathcal {M}}_{R}=\Sigma ^{*}/{\overset {*}{\underset {R}{\leftrightarrow }}}} of the free monoid Σ Σ ∗ ∗ {\displaystyle \Sigma ^{*}} by the Thue congruence. If a monoid M {\displaystyle {\mathcal {M}}} is isomorphic with M R {\displaystyle {\mathcal {M}}_{R}} , then the semi-Thue system ( Σ Σ , R ) {\displaystyle (\Sigma ,R)} is called a monoid presentation of M {\displaystyle {\mathcal {M}}} .

We immediately get some very useful connections with other areas of algebra. For example, the alphabet { a , b } {\displaystyle \{a,b\}} with the rules { a b → → ε ε , b a → → ε ε } {\displaystyle \{ab\rightarrow \varepsilon ,ba\rightarrow \varepsilon \}} , where ε ε {\displaystyle \varepsilon } is the empty string , is a presentation of the free group on one generator. If instead the rules are just { a b → → ε ε } {\displaystyle \{ab\rightarrow \varepsilon \}} , then we obtain a presentation of the bicyclic monoid . Thus semi-Thue systems constitute a natural framework for solving the word problem for monoids and groups. In fact, every monoid has a presentation of the form ( Σ Σ , R ) {\displaystyle (\Sigma ,R)} , i.e. it may always be presented by a semi-Thue system, possibly over an infinite alphabet.

The word problem for a semi-Thue system is undecidable in general; this result is sometimes known as the Post–Markov theorem .

[ 12 ] Term rewriting systems [ edit ] Pic.1: Schematic triangle diagram of application of a rewrite rule l ⟶ ⟶ r {\displaystyle l\longrightarrow r} at position p {\displaystyle p} in a term, with matching substitution σ σ {\displaystyle \sigma } Pic.2: Rule lhs term x ∗ ∗ ( y ∗ ∗ z ) {\displaystyle x*(y*z)} matching in term a ∗ ∗ ( ( a + 1 ) ∗ ∗ ( a + 2 ) ) 1 ∗ ∗ ( 2 ∗ ∗ 3 ) {\displaystyle {\frac {a*((a+1)*(a+2))}{1*(2*3)}}} A term rewriting system ( TRS ) is a rewriting system whose objects are terms , which are expressions with nested sub-expressions. For example, the system shown under § Logic above is a term rewriting system. The terms in this system are composed of binary operators ( ∨ ∨ ) {\displaystyle (\vee )} and ( ∧ ∧ ) {\displaystyle (\wedge )} and the unary operator ( ¬ ¬ ) {\displaystyle (\neg )} . Also present in the rules are variables, which represent any possible term (though a single variable always represents the same term throughout a single rule).

In contrast to string rewriting systems, whose objects are sequences of symbols, the objects of a term rewriting system form a term algebra . A term can be visualized as a tree of symbols, the set of admitted symbols being fixed by a given signature . As a formalism, term rewriting systems have the full power of Turing machines , that is, every computable function can be defined by a term rewriting system.

[ 13 ] Some programming languages are based on term rewriting. One such example is Pure, a functional programming language for mathematical applications.

[ 14 ] [ 15 ] Formal definition [ edit ] "Redex" redirects here. For the medication, see Tadalafil .

A rewrite rule is a pair of terms , commonly written as l → → r {\displaystyle l\rightarrow r} , to indicate that the left-hand side l can be replaced by the right-hand side r . A term rewriting system is a set R of such rules. A rule l → → r {\displaystyle l\rightarrow r} can be applied to a term s if the left term l matches some subterm of s , that is, if there is some substitution σ σ {\displaystyle \sigma } such that the subterm of s {\displaystyle s} rooted at some position p is the result of applying the substitution σ σ {\displaystyle \sigma } to the term l . The subterm matching the left hand side of the rule is called a redex or reducible expression .

[ 16 ] The result term t of this rule application is then the result of replacing the subterm at position p in s by the term r {\displaystyle r} with the substitution σ σ {\displaystyle \sigma } applied, see picture 1. In this case, s {\displaystyle s} is said to be rewritten in one step , or rewritten directly , to t {\displaystyle t} by the system R {\displaystyle R} , formally denoted as s → → R t {\displaystyle s\rightarrow _{R}t} , s → → R t {\displaystyle s{\underset {R}{\rightarrow }}t} , or as s → → R t {\displaystyle s{\overset {R}{\rightarrow }}t} by some authors.

If a term t 1 {\displaystyle t_{1}} can be rewritten in several steps into a term t n {\displaystyle t_{n}} , that is, if t 1 → → R t 2 → → R ⋯ ⋯ → → R t n {\displaystyle t_{1}{\underset {R}{\rightarrow }}t_{2}{\underset {R}{\rightarrow }}\cdots {\underset {R}{\rightarrow }}t_{n}} , the term t 1 {\displaystyle t_{1}} is said to be rewritten to t n {\displaystyle t_{n}} , formally denoted as t 1 → → R + t n {\displaystyle t_{1}{\overset {+}{\underset {R}{\rightarrow }}}t_{n}} . In other words, the relation → → R + {\displaystyle {\overset {+}{\underset {R}{\rightarrow }}}} is the transitive closure of the relation → → R {\displaystyle {\underset {R}{\rightarrow }}} ; often, also the notation → → R ∗ ∗ {\displaystyle {\overset {*}{\underset {R}{\rightarrow }}}} is used to denote the reflexive-transitive closure of → → R {\displaystyle {\underset {R}{\rightarrow }}} , that is, s → → R ∗ ∗ t {\displaystyle s{\overset {*}{\underset {R}{\rightarrow }}}t} if s = t {\displaystyle s=t} or s → → R + t {\displaystyle s{\overset {+}{\underset {R}{\rightarrow }}}t} .

[ 17 ] A term rewriting given by a set R {\displaystyle R} of rules can be viewed as an abstract rewriting system as defined above , with terms as its objects and → → R {\displaystyle {\underset {R}{\rightarrow }}} as its rewrite relation.

For example, x ∗ ∗ ( y ∗ ∗ z ) → → ( x ∗ ∗ y ) ∗ ∗ z {\displaystyle x*(y*z)\rightarrow (x*y)*z} is a rewrite rule, commonly used to establish a normal form with respect to the associativity of ∗ ∗ {\displaystyle *} .
That rule can be applied at the numerator in the term a ∗ ∗ ( ( a + 1 ) ∗ ∗ ( a + 2 ) ) 1 ∗ ∗ ( 2 ∗ ∗ 3 ) {\displaystyle {\frac {a*((a+1)*(a+2))}{1*(2*3)}}} with the matching substitution { x ↦ ↦ a , y ↦ ↦ a + 1 , z ↦ ↦ a + 2 } {\displaystyle \{x\mapsto a,\;y\mapsto a+1,\;z\mapsto a+2\}} , see picture 2.

[ note 2 ] Applying that substitution to the rule's right-hand side yields the term ( a ∗ ∗ ( a + 1 ) ) ∗ ∗ ( a + 2 ) {\displaystyle (a*(a+1))*(a+2)} , and replacing the numerator by that term yields ( a ∗ ∗ ( a + 1 ) ) ∗ ∗ ( a + 2 ) 1 ∗ ∗ ( 2 ∗ ∗ 3 ) {\displaystyle {\frac {(a*(a+1))*(a+2)}{1*(2*3)}}} , which is the result term of applying the rewrite rule. Altogether, applying the rewrite rule has achieved what is called "applying the associativity law for ∗ ∗ {\displaystyle *} to a ∗ ∗ ( ( a + 1 ) ∗ ∗ ( a + 2 ) ) 1 ∗ ∗ ( 2 ∗ ∗ 3 ) {\displaystyle {\frac {a*((a+1)*(a+2))}{1*(2*3)}}} " in elementary algebra. Alternately, the rule could have been applied to the denominator of the original term, yielding a ∗ ∗ ( ( a + 1 ) ∗ ∗ ( a + 2 ) ) ( 1 ∗ ∗ 2 ) ∗ ∗ 3 {\displaystyle {\frac {a*((a+1)*(a+2))}{(1*2)*3}}} .

Termination [ edit ] Termination issues of rewrite systems in general are handled in Abstract rewriting system#Termination and convergence . For term rewriting systems in particular, the following additional subtleties are to be considered.

Termination even of a system consisting of one rule with a linear left-hand side is undecidable.

[ 18 ] [ 19 ] Termination is also undecidable for systems using only unary function symbols; however, it is decidable for finite ground systems.

[ 20 ] The following term rewrite system is normalizing, [ note 3 ] but not terminating, [ note 4 ] and not confluent: [ 21 ] f ( x , x ) → → g ( x ) , f ( x , g ( x ) ) → → b , h ( c , x ) → → f ( h ( x , c ) , h ( x , x ) ) .

{\displaystyle {\begin{aligned}f(x,x)&\rightarrow g(x),\\f(x,g(x))&\rightarrow b,\\h(c,x)&\rightarrow f(h(x,c),h(x,x)).\\\end{aligned}}} The following two examples of terminating term rewrite systems are due to Toyama: [ 22 ] f ( 0 , 1 , x ) → → f ( x , x , x ) {\displaystyle f(0,1,x)\rightarrow f(x,x,x)} and g ( x , y ) → → x , {\displaystyle g(x,y)\rightarrow x,} g ( x , y ) → → y .

{\displaystyle g(x,y)\rightarrow y.} Their union is a non-terminating system, since f ( g ( 0 , 1 ) , g ( 0 , 1 ) , g ( 0 , 1 ) ) → → f ( 0 , g ( 0 , 1 ) , g ( 0 , 1 ) ) → → f ( 0 , 1 , g ( 0 , 1 ) ) → → f ( g ( 0 , 1 ) , g ( 0 , 1 ) , g ( 0 , 1 ) ) → → ⋯ ⋯ {\displaystyle {\begin{aligned}&f(g(0,1),g(0,1),g(0,1))\\\rightarrow &f(0,g(0,1),g(0,1))\\\rightarrow &f(0,1,g(0,1))\\\rightarrow &f(g(0,1),g(0,1),g(0,1))\\\rightarrow &\cdots \end{aligned}}} This result disproves a conjecture of Dershowitz , [ 23 ] who claimed that the union of two terminating term rewrite systems R 1 {\displaystyle R_{1}} and R 2 {\displaystyle R_{2}} is again terminating if all left-hand sides of R 1 {\displaystyle R_{1}} and right-hand sides of R 2 {\displaystyle R_{2}} are linear , and there are no " overlaps " between left-hand sides of R 1 {\displaystyle R_{1}} and right-hand sides of R 2 {\displaystyle R_{2}} . All these properties are satisfied by Toyama's examples.

See Rewrite order and Path ordering (term rewriting) for ordering relations used in termination proofs for term rewriting systems.

Higher-order rewriting systems [ edit ] Higher-order rewriting systems are a generalization of first-order term rewriting systems to lambda terms , allowing higher order functions and bound variables.

[ 24 ] Various results about first-order TRSs can be reformulated for HRSs as well.

[ 25 ] Graph rewriting systems [ edit ] Graph rewrite systems are another generalization of term rewrite systems, operating on graphs instead of ( ground -) terms / their corresponding tree representation.

Trace rewriting systems [ edit ] Trace theory provides a means for discussing multiprocessing in more formal terms, such as via the trace monoid and the history monoid .  Rewriting can be performed in trace systems as well.

See also [ edit ] Critical pair (logic) Compiler Knuth–Bendix completion algorithm L-systems specify rewriting that is done in parallel.

Referential transparency in computer science Regulated rewriting Interaction nets Notes [ edit ] ^ This variant of the previous rule is needed since the commutative law A ∨ B = B ∨ A cannot be turned into a rewrite rule. A rule like A ∨ B → B ∨ A would cause the rewrite system to be nonterminating.

^ since applying that substitution to the rule's left hand side x ∗ ∗ ( y ∗ ∗ z ) {\displaystyle x*(y*z)} yields the numerator a ∗ ∗ ( ( a + 1 ) ∗ ∗ ( a + 2 ) ) {\displaystyle a*((a+1)*(a+2))} ^ i.e. for each term, some normal form exists, e.g.

h ( c , c ) has the normal forms b and g ( b ), since h ( c , c ) → f ( h ( c , c ), h ( c , c )) → f ( h ( c , c ), f ( h ( c , c ), h ( c , c ))) → f ( h ( c , c ), g ( h ( c , c )))  → b , and h ( c , c ) → f ( h ( c , c ), h ( c , c )) → g ( h ( c , c )) → ... → g ( b ); neither b nor g ( b ) can be rewritten any further, therefore the system is not confluent ^ i.e., there are infinite derivations, e.g.

h ( c , c ) → f ( h ( c , c ), h ( c , c )) → f ( f ( h ( c , c ), h ( c , c )) , h ( c , c )) → f ( f ( f ( h ( c , c ), h ( c , c )), h ( c , c )) , h ( c , c )) → ...

Further reading [ edit ] Baader, Franz ; Nipkow, Tobias (1999).

Term rewriting and all that . Cambridge University Press.

ISBN 978-0-521-77920-3 .

316 pages.

Marc Bezem , Jan Willem Klop , Roel de Vrijer ("Terese"), Term Rewriting Systems ("TeReSe"), Cambridge University Press, 2003, ISBN 0-521-39115-6 . This is the most recent comprehensive monograph. It uses however a fair deal of non-yet-standard notations and definitions. For instance, the Church–Rosser property is defined to be identical with confluence.

Nachum Dershowitz and Jean-Pierre Jouannaud "Rewrite Systems" , Chapter 6 in Jan van Leeuwen (Ed.), Handbook of Theoretical Computer Science , Volume B: Formal Models and Semantics.

, Elsevier and MIT Press, 1990, ISBN 0-444-88074-7 , pp. 243–320. The preprint of this chapter is freely available from the authors, but it is missing the figures.

Nachum Dershowitz and David Plaisted .

"Rewriting" , Chapter 9 in John Alan Robinson and Andrei Voronkov (Eds.), Handbook of Automated Reasoning , Volume 1 .

Gérard Huet et Derek Oppen, Equations and Rewrite Rules, A Survey (1980) Stanford Verification Group, Report N° 15 Computer Science Department Report N° STAN-CS-80-785 Jan Willem Klop . "Term Rewriting Systems", Chapter 1 in Samson Abramsky , Dov M. Gabbay and Tom Maibaum (Eds.), Handbook of Logic in Computer Science , Volume 2: Background: Computational Structures .

David Plaisted.

"Equational reasoning and term rewriting systems" , in Dov M. Gabbay , C. J. Hogger and John Alan Robinson (Eds.), Handbook of Logic in Artificial Intelligence and Logic Programming , Volume 1 .

Jürgen Avenhaus and Klaus Madlener. "Term rewriting and equational reasoning". In Ranan B. Banerji (Ed.), Formal Techniques in Artificial Intelligence: A Sourcebook , Elsevier (1990).

String rewriting Ronald V. Book and Friedrich Otto, String-Rewriting Systems , Springer (1993).

Benjamin Benninghofen, Susanne Kemmerich and Michael M. Richter , Systems of Reductions .

LNCS 277 , Springer-Verlag (1987).

Other Martin Davis , Ron Sigal , Elaine J. Weyuker , (1994) Computability, Complexity, and Languages: Fundamentals of Theoretical Computer Science – 2nd edition , Academic Press, ISBN 0-12-206382-1 .

External links [ edit ] Look up rewriting in Wiktionary, the free dictionary.

The Rewriting Home Page IFIP Working Group 1.6 Researchers in rewriting by Aart Middeldorp , University of Innsbruck Termination Portal Maude System — a software implementation of a generic term rewriting system.

[ 5 ] References [ edit ] ^ Joseph Goguen "Proving and Rewriting" International Conference on Algebraic and Logic Programming, 1990 Nancy, France pp 1-24 ^ Sculthorpe, Neil; Frisby, Nicolas; Gill, Andy (2014).

"The Kansas University rewrite engine" (PDF) .

Journal of Functional Programming .

24 (4): 434– 473.

doi : 10.1017/S0956796814000185 .

ISSN 0956-7968 .

S2CID 16807490 .

Archived (PDF) from the original on 2017-09-22 . Retrieved 2019-02-12 .

^ Hsiang, Jieh; Kirchner, Hélène; Lescanne, Pierre; Rusinowitch, Michaël (1992).

"The term rewriting approach to automated theorem proving" .

The Journal of Logic Programming .

14 ( 1– 2): 71– 99.

doi : 10.1016/0743-1066(92)90047-7 .

^ Frühwirth, Thom (1998).

"Theory and practice of constraint handling rules" .

The Journal of Logic Programming .

37 ( 1– 3): 95– 138.

doi : 10.1016/S0743-1066(98)10005-5 .

^ a b Clavel, M.; Durán, F.; Eker, S.; Lincoln, P.; Martí-Oliet, N.; Meseguer, J.; Quesada, J.F. (2002).

"Maude: Specification and programming in rewriting logic" .

Theoretical Computer Science .

285 (2): 187– 243.

doi : 10.1016/S0304-3975(01)00359-0 .

^ Kim Marriott; Peter J. Stuckey (1998).

Programming with Constraints: An Introduction . MIT Press. pp. 436–.

ISBN 978-0-262-13341-8 .

^ Jürgen Avenhaus; Klaus Madlener (1990). "Term Rewriting and Equational Reasoning". In R.B. Banerji (ed.).

Formal Techniques in Artificial Intelligence . Sourcebook. Elsevier. pp.

1– 43.

Here: Example in sect.4.1, p.24.

^ Robert Freidin (1992).

Foundations of Generative Syntax . MIT Press.

ISBN 978-0-262-06144-5 .

^ a b Book and Otto, p. 10 ^ Bezem et al., p. 7, ^ Bezem et al., p. 7 ^ Martin Davis et al. 1994, p. 178 ^ Dershowitz, Jouannaud (1990), sect.1, p.245 ^ Albert, Gräf (2009).

"Signal Processing in the Pure Programming Language" .

Linux Audio Conference .

^ Riepe, Von Michael (November 18, 2009).

"Pure – eine einfache funktionale Sprache" . Archived from the original on March 19, 2011.

^ Klop, J. W.

"Term Rewriting Systems" (PDF) .

Papers by Nachum Dershowitz and students . Tel Aviv University. p. 12.

Archived (PDF) from the original on 15 August 2021 . Retrieved 14 August 2021 .

^ N. Dershowitz, J.-P. Jouannaud (1990).

Jan van Leeuwen (ed.).

Rewrite Systems . Handbook of Theoretical Computer Science. Vol. B. Elsevier. pp.

243– 320.

; here: Sect. 2.3 ^ Max Dauchet (1989). "Simulation of Turing Machines by a Left-Linear Rewrite Rule".

Proc. 3rd Int. Conf. on Rewriting Techniques and Applications . LNCS. Vol. 355. Springer. pp.

109– 120.

^ Max Dauchet (Sep 1992).

"Simulation of Turing machines by a regular rewrite rule" .

Theoretical Computer Science .

103 (2): 409– 420.

doi : 10.1016/0304-3975(92)90022-8 .

^ Gerard Huet, D.S. Lankford (Mar 1978).

On the Uniform Halting Problem for Term Rewriting Systems (PDF) (Technical report). IRIA. p. 8. 283 . Retrieved 16 June 2013 .

^ Bernhard Gramlich (Jun 1993).

"Relating Innermost, Weak, Uniform, and Modular Termination of Term Rewriting Systems" . In Voronkov, Andrei (ed.).

Proc. International Conference on Logic Programming and Automated Reasoning (LPAR) . LNAI. Vol. 624. Springer. pp.

285– 296.

Archived from the original on 2016-03-04 . Retrieved 2014-06-19 .

Here: Example 3.3 ^ Yoshihito Toyama (1987).

"Counterexamples to Termination for the Direct Sum of Term Rewriting Systems" (PDF) .

Inf. Process. Lett .

25 (3): 141– 143.

doi : 10.1016/0020-0190(87)90122-0 .

hdl : 2433/99946 .

Archived (PDF) from the original on 2019-11-13 . Retrieved 2019-11-13 .

^ N. Dershowitz (1985).

"Termination" (PDF) . In Jean-Pierre Jouannaud (ed.).

Proc. RTA . LNCS. Vol. 220. Springer. pp.

180– 224.

Archived (PDF) from the original on 2013-11-12 . Retrieved 2013-06-16 .

; here: p.210 ^ Wolfram, D. A. (1993).

The Clausal Theory of Types . Cambridge University Press. pp.

47– 50.

doi : 10.1017/CBO9780511569906 .

ISBN 9780521395380 .

S2CID 42331173 .

^ Nipkow, Tobias; Prehofer, Christian (1998).

"Higher-Order Rewriting and Equational Reasoning" . In Bibel, W.; Schmitt, P. (eds.).

Automated Deduction - A Basis for Applications. Volume I: Foundations . Kluwer. pp.

399– 430.

Archived from the original on 2021-08-16 . Retrieved 2021-08-16 .

Authority control databases International FAST National United States Israel Other Yale LUX NewPP limit report
Parsed by mw‐web.codfw.main‐7c956d68b4‐j84l7
Cached time: 20250816234841
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.666 seconds
Real time usage: 0.948 seconds
Preprocessor visited node count: 3071/1000000
Revision size: 32610/2097152 bytes
Post‐expand include size: 53129/2097152 bytes
Template argument size: 1574/2097152 bytes
Highest expansion depth: 9/100
Expensive parser function count: 6/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 99437/5000000 bytes
Lua time usage: 0.333/10.000 seconds
Lua memory usage: 6493610/52428800 bytes
Number of Wikibase entities loaded: 1/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  511.834      1 -total
 34.24%  175.265      2 Template:Reflist
 28.53%  146.027     10 Template:Cite_book
 15.37%   78.653      1 Template:Short_description
 14.48%   74.114      1 Template:Authority_control
 10.62%   54.362      7 Template:Cite_journal
 10.60%   54.265      2 Template:Pagetype
  4.48%   22.909      1 Template:Wiktionary
  4.38%   22.398      1 Template:Other_uses
  4.19%   21.465      1 Template:Sister_project Saved in parser cache with key enwiki:pcache:415847:|#|:idhash:canonical and timestamp 20250816234841 and revision id 1306285405. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Rewriting&oldid=1306285405 " Categories : Formal languages Logic in computer science Mathematical logic Rewriting systems Hidden categories: Articles with short description Short description is different from Wikidata This page was last edited on 16 August 2025, at 23:47 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Rewriting 16 languages Add topic

