Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Approaches 2 Usages Toggle Usages subsection 2.1 Code generation 2.2 Code instrumentation 3 Challenges 4 Uses in programming languages Toggle Uses in programming languages subsection 4.1 Macro systems 4.2 Macro assemblers 4.3 Metaclasses 4.4 Template metaprogramming 4.5 Staged metaprogramming 4.6 Dependent types 5 Implementations 6 See also 7 References 8 External links Toggle the table of contents Metaprogramming 29 languages العربية বাংলা Български Català Čeština Deutsch Eesti Ελληνικά Español Esperanto فارسی Français 한국어 Հայերեն Magyar Nederlands 日本語 Norsk bokmål Norsk nynorsk Polski Português Română Русский Српски / srpski ไทย Українська Tiếng Việt 粵語 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Programming paradigm This article is about the computer programming technique. For the management technique, see Charles Simonyi .

This article has multiple issues.

Please help improve it or discuss these issues on the talk page .

( Learn how and when to remove these messages ) This article needs additional citations for verification .

Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed.

Find sources: "Metaprogramming" – news · newspapers · books · scholar · JSTOR ( August 2011 ) ( Learn how and when to remove this message ) This article's tone or style may not reflect the encyclopedic tone used on Wikipedia .

See Wikipedia's guide to writing better articles for suggestions.

( February 2017 ) ( Learn how and when to remove this message ) ( Learn how and when to remove this message ) Metaprogramming is a computer programming technique in which computer programs have the ability to treat other programs as their data . It means that a program can be designed to read, generate, analyse, or transform other programs, and even modify itself, while running.

[ 1 ] [ 2 ] In some cases, this allows programmers to minimize the number of lines of code to express a solution, in turn reducing development time.

[ 3 ] It also allows programs more flexibility to efficiently handle new situations with no recompiling.

Metaprogramming can be used to move computations from runtime to compile time , to generate code using compile time computations , and to enable self-modifying code . The ability of a programming language to be its own metalanguage allows reflective programming , and is termed reflection .

[ 4 ] Reflection is a valuable language feature to facilitate metaprogramming.

Metaprogramming was popular in the 1970s and 1980s using list processing languages such as Lisp .

Lisp machine hardware gained some notice in the 1980s, and enabled applications that could process code. They were often used for artificial intelligence applications.

Approaches [ edit ] Metaprogramming enables developers to write programs and develop code that falls under the generic programming paradigm . Having the programming language itself as a first-class data type (as in Lisp , Prolog , SNOBOL , or Rebol ) is also very useful; this is known as homoiconicity .

Generic programming invokes a metaprogramming facility within a language by allowing one to write code without the concern of specifying data types since they can be supplied as parameters when used.

Metaprogramming usually works in one of three ways.

[ 5 ] The first approach is to expose the internals of the runtime system (engine) to the programming code through application programming interfaces (APIs) like that for the .NET Common Intermediate Language (CIL) emitter.

The second approach is dynamic execution of expressions that contain programming commands, often composed from strings, but can also be from other methods using arguments or context, like JavaScript .

[ 6 ] Thus, "programs can write programs." Although both approaches can be used in the same language, most languages tend to lean toward one or the other.

The third approach is to step outside the language entirely. General purpose program transformation systems such as compilers , which accept language descriptions and carry out arbitrary transformations on those languages, are direct implementations of general metaprogramming. This allows metaprogramming to be applied to virtually any target language without regard to whether that target language has any metaprogramming abilities of its own. One can see this at work with Scheme and how it allows tackling some limits faced in C by using constructs that are part of the Scheme language to extend C.

[ 7 ] Lisp is probably the quintessential language with metaprogramming facilities, both because of its historical precedence and because of the simplicity and power of its metaprogramming. In Lisp metaprogramming, the unquote operator (typically a comma) introduces code that is evaluated at program definition time rather than at run time. The metaprogramming language is thus identical to the host programming language, and existing Lisp routines can be directly reused for metaprogramming if desired. This approach has been implemented in other languages by incorporating an interpreter in the program, which works directly with the program's data. There are implementations of this kind for some common high-level languages, such as RemObjects ’ Pascal Script for Object Pascal .

Usages [ edit ] Code generation [ edit ] A simple example of a metaprogram is this POSIX Shell script , which is an example of generative programming : #!/bin/sh # metaprogram echo '#!/bin/sh' > program for i in $( seq 992 ) do echo "echo $i " >> program done chmod +x program This script (or program) generates a new 993-line program that prints out the numbers 1–992. This is only an illustration of how to use code to write more code; it is not the most efficient way to print out a list of numbers. Nonetheless, a programmer can write and execute this metaprogram in less than a minute, and will have generated over 1000 lines of code in that amount of time.

A quine is a special kind of metaprogram that produces its own source code as its output. Quines are generally of recreational or theoretical interest only.

Not all metaprogramming involves generative programming. If programs are modifiable at runtime, or if incremental compiling is available (such as in C# , Forth , Frink , Groovy , JavaScript , Lisp , Elixir , Lua , Nim , Perl , PHP , Python , Rebol , Ruby , Rust , R , SAS , Smalltalk , and Tcl ), then techniques can be used to perform metaprogramming without generating source code.

One style of generative approach is to employ domain-specific languages (DSLs). A fairly common example of using DSLs involves generative metaprogramming: lex and yacc , two tools used to generate lexical analysers and parsers , let the user describe the language using regular expressions and context-free grammars , and embed the complex algorithms required to efficiently parse the language.

Code instrumentation [ edit ] One usage of metaprogramming is to instrument programs in order to do dynamic program analysis .

Challenges [ edit ] Some argue that there is a sharp learning curve to make complete use of metaprogramming features.

[ 8 ] Since metaprogramming gives more flexibility and configurability at runtime, misuse or incorrect use of metaprogramming can result in unwarranted and unexpected errors that can be extremely difficult to debug to an average developer. It can introduce risks in the system and make it more vulnerable if not used with care. Some of the common problems, which can occur due to wrong use of metaprogramming are inability of the compiler to identify missing configuration parameters, invalid or incorrect data can result in unknown exception or different results.

[ 9 ] Due to this, some believe [ 8 ] that only high-skilled developers should work on developing features which exercise metaprogramming in a language or platform and average developers must learn how to use these features as part of convention.

Uses in programming languages [ edit ] Macro systems [ edit ] Main article: Macro (computer science) Lisp , most dialects Clojure Common Lisp Racket Scheme hygienic macros MacroML Template Haskell Scala Nim Rust Haxe Julia Elixir Macro assemblers [ edit ] Main article: Macro assembler The IBM/360 and derivatives had powerful macro assembler facilities that were often used to generate complete assembly language programs [ citation needed ] or sections of programs (for different operating systems for instance). Macros provided with CICS transaction processing system had assembler macros that generated COBOL statements as a pre-processing step.

Other assemblers, such as MASM , also support macros.

Metaclasses [ edit ] Main article: Metaclass Metaclasses are provided by the following programming languages: Common Lisp [ 10 ] Python NIL Groovy Ruby Smalltalk Lua Template metaprogramming [ edit ] Main article: Template metaprogramming C "X Macros" C++ Templates [ 11 ] D Common Lisp , Scheme and most Lisp dialects by using the quasiquote ("backquote") operator.

[ 12 ] Nim Staged metaprogramming [ edit ] Main article: Multi-stage programming MetaML MetaOCaml Scala natively or using the Lightweight Modular Staging Framework [ 13 ] [ 14 ] Terra Dependent types [ edit ] Main article: Dependent type Use of dependent types allows proving that generated code is never invalid.

[ 15 ] However, this approach is leading-edge and rarely found outside of research programming languages.

Implementations [ edit ] The list of notable metaprogramming systems is maintained at List of program transformation systems .

See also [ edit ] Aspect weaver Comparison of code generation tools Compile-time function execution Genetic programming Homoiconicity Inferential programming Instruction set simulator Interpreted language Machine learning Metacompiler Metaobject Partial evaluation Reflective programming , also compile time reflection Self-interpreter Self-modifying code Source code generation Transcompiler (also known as transpilation) Very-large-scale integration Halting problem References [ edit ] ^ Sondergaard, Harald (2013).

"Course on Program Analysis and Transformation" . Retrieved 18 September 2014 .

^ Czarnecki, Krzysztof ; Eisenecker, Ulrich W. (2000).

Generative Programming . Addison Wesley.

ISBN 0-201-30977-7 .

^ Walker, Max.

"The Art of Metaprogrmming in Java" .

New Circle . Retrieved 28 January 2014 .

^ Krauss, Aaron.

"Programming Concepts: Type Introspection and Reflection" . Archived from the original on 10 March 2016 . Retrieved 10 March 2016 .

^ Joshi, Prateek (5 April 2014).

"What Is Metaprogramming? – Part 2/2" .

Perpetual Enigma . Retrieved 14 August 2014 .

^ for example, instance_eval in Ruby takes a string or an anonymous function.

"Class BasicObject Ruby 3.5" .

^ "Art of Metaprogramming" .

IBM .

^ a b Bicking, Ian.

"The challenge of metaprogramming" .

IanBicking.org . Retrieved 21 September 2016 .

^ Terry, Matt (21 August 2013).

"Beware of Metaprogramming" .

Medium.com . Medium Corporation . Retrieved 21 August 2014 .

^ Through Common Lisp Object System 's "Meta Object Protocol" ^ "C++ Template Metaprogramming" .

aszt.inf.elte.hu . Retrieved 2022-07-23 .

^ Lisp (programming language) "Self-evaluating forms and quoting", quasi-quote operator.

^ "LMS: Program Generation and Embedded Compilers in Scala" .

scala-lms.github.io . Retrieved 2017-12-06 .

^ Rompf, Tiark; Odersky, Martin (June 2012).

"Lightweight Modular Staging: A Pragmatic Approach to Runtime Code Generation and Compiled DSLs" .

Communications of the ACM .

55 (6): 121– 130.

doi : 10.1145/2184319.2184345 .

ISSN 0001-0782 .

S2CID 52898203 .

^ Chlipala, Adam (June 2010).

"Ur: statically-typed metaprogramming with type-level record computation" (PDF) .

ACM SIGPLAN Notices . PLDI '10.

45 (6): 122– 133.

doi : 10.1145/1809028.1806612 . Retrieved 29 August 2012 .

External links [ edit ] c2.com Wiki: Metaprogramming article Meta Programming on the Program Transformation Wiki Code generation Vs Metaprogramming "Solenoid" : The first metaprogramming framework for eXist-db This article may require cleanup to meet Wikipedia's quality standards . The specific problem is: archive-org link links to unrelated maybe-spam site, unclear if legitimate bit rot or malice.

Please help improve this article if you can.

( April 2025 ) ( Learn how and when to remove this message ) v t e Programming paradigms ( Comparison by language ) Imperative Structured Jackson structures Block-structured Modular Non-structured Procedural Programming in the large and in the small Design by contract Invariant-based Nested function Object-oriented ( comparison , list ) Class-based , Prototype-based , Object-based Agent Immutable object Persistent Uniform function call syntax Declarative Functional ( comparison ) Recursive Anonymous function ( Partial application ) Higher-order Purely functional Total Strict GADTs Dependent types Functional logic Point-free style Expression-oriented Applicative , Concatenative Function-level , Value-level Dataflow Flow-based Reactive ( Functional reactive ) Signals Streams Synchronous Logic Abductive logic Answer set Constraint ( Constraint logic ) Inductive logic Nondeterministic Ontology Probabilistic logic Query Domain- specific language (DSL) Algebraic modeling Array Automata-based ( Action ) Command ( Spacecraft ) Differentiable End-user Grammar-oriented Interface description Language-oriented List comprehension Low-code Modeling Natural language Non-English-based Page description Pipes and filters Probabilistic Quantum Scientific Scripting Set-theoretic Simulation Stack-based System Tactile Templating Transformation ( Graph rewriting , Production , Pattern ) Visual Concurrent , distributed , parallel Actor-based Automatic mutual exclusion Choreographic programming Concurrent logic ( Concurrent constraint logic ) Concurrent OO Macroprogramming Multitier programming Organic computing Parallel programming models Partitioned global address space Process-oriented Relativistic programming Service-oriented Structured concurrency Metaprogramming Attribute-oriented Automatic ( Inductive ) Dynamic Extensible Generic Homoiconicity Interactive Macro ( Hygienic ) Metalinguistic abstraction Multi-stage Program synthesis ( Bayesian , Inferential , by demonstration , by example ) Reflective Self-modifying code Symbolic Template Separation of concerns Aspects Components Data-driven Data-oriented Event-driven Features Literate Roles Subjects v t e Types of programming languages Level Machine Assembly Compiled Interpreted Low-level High-level Very high-level Esoteric Generation First Second Third Fourth Fifth NewPP limit report
Parsed by mw‐web.codfw.main‐7c956d68b4‐kpqtj
Cached time: 20250817061327
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.399 seconds
Real time usage: 0.514 seconds
Preprocessor visited node count: 2020/1000000
Revision size: 14833/2097152 bytes
Post‐expand include size: 110527/2097152 bytes
Template argument size: 11349/2097152 bytes
Highest expansion depth: 17/100
Expensive parser function count: 16/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 74018/5000000 bytes
Lua time usage: 0.243/10.000 seconds
Lua memory usage: 7271251/52428800 bytes
Number of Wikibase entities loaded: 0/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  430.356      1 -total
 32.31%  139.032      1 Template:Reflist
 24.70%  106.313     10 Template:Cite_web
 17.24%   74.214      1 Template:Multiple_issues
 17.15%   73.797      4 Template:Navbox
 16.18%   69.630      1 Template:Programming_paradigms_navbox
 12.64%   54.405      1 Template:Short_description
 11.84%   50.939      3 Template:Ambox
  9.59%   41.255      1 Template:More_citations_needed
  7.38%   31.763      2 Template:Pagetype Saved in parser cache with key enwiki:pcache:393460:|#|:idhash:canonical and timestamp 20250817061327 and revision id 1292150577. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Metaprogramming&oldid=1292150577 " Categories : Metaprogramming Programming paradigms Hidden categories: Articles with short description Short description matches Wikidata Articles needing additional references from August 2011 All articles needing additional references Wikipedia articles with style issues from February 2017 All articles with style issues Articles with multiple maintenance issues All articles with unsourced statements Articles with unsourced statements from August 2011 Articles needing cleanup from April 2025 All pages needing cleanup Cleanup tagged articles with a reason field from April 2025 Wikipedia pages needing cleanup from April 2025 This page was last edited on 25 May 2025, at 13:08 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Metaprogramming 29 languages Add topic

