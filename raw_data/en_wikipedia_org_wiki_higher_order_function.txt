Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 General examples 2 Support in programming languages Toggle Support in programming languages subsection 2.1 Direct support 2.1.1 APL 2.1.2 C++ 2.1.3 C# 2.1.4 Clojure 2.1.5 ColdFusion Markup Language (CFML) 2.1.6 Common Lisp 2.1.7 D 2.1.8 Dart 2.1.9 Elixir 2.1.10 Erlang 2.1.11 F# 2.1.12 Go 2.1.13 Groovy 2.1.14 Haskell 2.1.15 J 2.1.16 Java (1.8+) 2.1.17 JavaScript 2.1.18 Julia 2.1.19 Kotlin 2.1.20 Lua 2.1.21 MATLAB 2.1.22 OCaml 2.1.23 PHP 2.1.24 Perl 2.1.25 Python 2.1.26 R 2.1.27 Raku 2.1.28 Ruby 2.1.29 Rust 2.1.30 Scala 2.1.31 Scheme 2.1.32 Swift 2.1.33 Tcl 2.1.34 XACML 2.1.35 XQuery 2.2 Alternatives 2.2.1 Function pointers 2.2.2 Macros 2.2.3 Dynamic code evaluation 2.2.4 Objects 2.2.5 Defunctionalization 3 See also 4 References Toggle the table of contents Higher-order function 20 languages العربية Català Deutsch Eesti Ελληνικά Español فارسی Français 한국어 Italiano Nederlands 日本語 Polski Русский Shqip Svenska தமிழ் Українська Tiếng Việt 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Function that takes one or more functions as an input or that outputs a function This article needs additional citations for verification .

Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed.

Find sources: "Higher-order function" – news · newspapers · books · scholar · JSTOR ( November 2024 ) ( Learn how and when to remove this message ) Not to be confused with Functor (category theory) .

In mathematics and computer science , a higher-order function ( HOF ) is a function that does at least one of the following: takes one or more functions as arguments (i.e. a procedural parameter , which is a parameter of a procedure that is itself a procedure), returns a function as its result.

All other functions are first-order functions . In mathematics higher-order functions are also termed operators or functionals . The differential operator in calculus is a common example, since it maps a function to its derivative , also a function. Higher-order functions should not be confused with other uses of the word "functor" throughout mathematics, see Functor (disambiguation) .

In the untyped lambda calculus , all functions are higher-order; in a typed lambda calculus , from which most functional programming languages are derived, higher-order functions that take one function as argument are values with types of the form ( τ τ 1 → → τ τ 2 ) → → τ τ 3 {\displaystyle (\tau _{1}\to \tau _{2})\to \tau _{3}} .

General examples [ edit ] map function, found in many functional programming languages, is one example of a higher-order function. It takes arguments as a function f and a collection of elements, and as the result, returns a new collection with f applied to each element from the collection.

Sorting functions, which take a comparison function as a parameter, allowing the programmer to separate the sorting algorithm from the comparisons of the items being sorted. The C standard function qsort is an example of this.

filter fold scan apply Function composition Integration Callback Tree traversal Montague grammar , a semantic theory of natural language, uses higher-order functions Support in programming languages [ edit ] Direct support [ edit ] The examples are not intended to compare and contrast programming languages, but to serve as examples of higher-order function syntax In the following examples, the higher-order function twice takes a function, and applies the function to some value twice. If twice has to be applied several times for the same f it preferably should return a function rather than a value. This is in line with the " don't repeat yourself " principle.

APL [ edit ] Further information: APL (programming language) twice ← { ⍺⍺ ⍺⍺ ⍵ } plusthree ← { ⍵ + 3 } g ← { plusthree twice ⍵ } g 7 13 Or in a tacit manner: twice ← ⍣ 2 plusthree ← + ∘ 3 g ← plusthree twice g 7 13 C++ [ edit ] Further information: C++ Using std::function in C++11 : #include <iostream> #include <functional> auto twice = []( const std :: function < int ( int ) >& f ) { return [ f ]( int x ) { return f ( f ( x )); }; }; auto plus_three = []( int i ) { return i + 3 ; }; int main () { auto g = twice ( plus_three ); std :: cout << g ( 7 ) << '\n' ; // 13 } Or, with generic lambdas provided by C++14: #include <iostream> auto twice = []( const auto & f ) { return [ f ]( int x ) { return f ( f ( x )); }; }; auto plus_three = []( int i ) { return i + 3 ; }; int main () { auto g = twice ( plus_three ); std :: cout << g ( 7 ) << '\n' ; // 13 } C# [ edit ] Further information: C Sharp (programming language) Using just delegates: using System ; public class Program { public static void Main ( string [] args ) { Func < Func < int , int > , Func < int , int >> twice = f => x => f ( f ( x )); Func < int , int > plusThree = i => i + 3 ; var g = twice ( plusThree ); Console .

WriteLine ( g ( 7 )); // 13 } } Or equivalently, with static methods: using System ; public class Program { private static Func < int , int > Twice ( Func < int , int > f ) { return x => f ( f ( x )); } private static int PlusThree ( int i ) => i + 3 ; public static void Main ( string [] args ) { var g = Twice ( PlusThree ); Console .

WriteLine ( g ( 7 )); // 13 } } Clojure [ edit ] Further information: Clojure ( defn twice [ f ] ( fn [ x ] ( f ( f x )))) ( defn plus-three [ i ] ( + i 3 )) ( def g ( twice plus-three )) ( println ( g 7 )) ; 13 ColdFusion Markup Language (CFML) [ edit ] Further information: ColdFusion Markup Language twice = function ( f ) { return function ( x ) { return f ( f ( x )); }; }; plusThree = function ( i ) { return i + 3 ; }; g = twice ( plusThree ); writeOutput ( g ( 7 )); // 13 Common Lisp [ edit ] Further information: Common Lisp ( defun twice ( f ) ( lambda ( x ) ( funcall f ( funcall f x )))) ( defun plus-three ( i ) ( + i 3 )) ( defvar g ( twice #' plus-three )) ( print ( funcall g 7 )) D [ edit ] Further information: D (programming language) import std .

stdio : writeln ; alias twice = ( f ) => ( int x ) => f ( f ( x )); alias plusThree = ( int i ) => i + 3 ; void main () { auto g = twice ( plusThree ); writeln ( g ( 7 )); // 13 } Dart [ edit ] Further information: Dart (programming language) int Function ( int ) twice ( int Function ( int ) f ) { return ( x ) { return f ( f ( x )); }; } int plusThree ( int i ) { return i + 3 ; } void main () { final g = twice ( plusThree ); print ( g ( 7 )); // 13 } Elixir [ edit ] Further information: Elixir (programming language) In Elixir, you can mix module definitions and anonymous functions defmodule Hof do def twice ( f ) do fn ( x ) -> f .

( f .

( x )) end end end plus_three = fn ( i ) -> i + 3 end g = Hof .

twice ( plus_three ) IO .

puts g .

( 7 ) # 13 Alternatively, we can also compose using pure anonymous functions.

twice = fn ( f ) -> fn ( x ) -> f .

( f .

( x )) end end plus_three = fn ( i ) -> i + 3 end g = twice .

( plus_three ) IO .

puts g .

( 7 ) # 13 Erlang [ edit ] Further information: Erlang (programming language) or_else ([], _) -> false ; or_else ([ F | Fs ], X ) -> or_else ( Fs , X , F ( X )).

or_else ( Fs , X , false ) -> or_else ( Fs , X ); or_else ( Fs , _, { false , Y }) -> or_else ( Fs , Y ); or_else (_, _, R ) -> R .

or_else ([ fun erlang : is_integer / 1 , fun erlang : is_atom / 1 , fun erlang : is_list / 1 ], 3 .

23 ).

In this Erlang example, the higher-order function or_else/2 takes a list of functions ( Fs ) and argument ( X ). It evaluates the function F with the argument X as argument. If the function F returns false then the next function in Fs will be evaluated. If the function F returns {false, Y} then the next function in Fs with argument Y will be evaluated. If the function F returns R the higher-order function or_else/2 will return R . Note that X , Y , and R can be functions. The example returns false .

F# [ edit ] Further information: F Sharp (programming language) let twice f = f >> f let plus_three = (+) 3 let g = twice plus_three g 7 |> printf "%A" // 13 Go [ edit ] Further information: Go (programming language) package main import "fmt" func twice ( f func ( int ) int ) func ( int ) int { return func ( x int ) int { return f ( f ( x )) } } func main () { plusThree := func ( i int ) int { return i + 3 } g := twice ( plusThree ) fmt .

Println ( g ( 7 )) // 13 } Notice a function literal can be defined either with an identifier ( twice ) or anonymously (assigned to variable plusThree ).

Groovy [ edit ] Further information: Groovy (programming language) def twice = { f , x -> f ( f ( x )) } def plusThree = { it + 3 } def g = twice .

curry ( plusThree ) println g ( 7 ) // 13 Haskell [ edit ] Further information: Haskell twice :: ( Int -> Int ) -> ( Int -> Int ) twice f = f .

f plusThree :: Int -> Int plusThree = ( + 3 ) main :: IO () main = print ( g 7 ) -- 13 where g = twice plusThree J [ edit ] Further information: J (programming language) Explicitly, twice =.

adverb : 'u u y' plusthree =.

verb : 'y + 3' g =.

plusthree twice g 7 13 or tacitly, twice =.

^: 2 plusthree =.

+& 3 g =.

plusthree twice g 7 13 Java (1.8+) [ edit ] Further information: Java (programming language) and Java version history Using just functional interfaces: import java.util.function.* ; class Main { public static void main ( String [] args ) { Function < IntUnaryOperator , IntUnaryOperator > twice = f -> f .

andThen ( f ); IntUnaryOperator plusThree = i -> i + 3 ; var g = twice .

apply ( plusThree ); System .

out .

println ( g .

applyAsInt ( 7 )); // 13 } } Or equivalently, with static methods: import java.util.function.* ; class Main { private static IntUnaryOperator twice ( IntUnaryOperator f ) { return f .

andThen ( f ); } private static int plusThree ( int i ) { return i + 3 ; } public static void main ( String [] args ) { var g = twice ( Main :: plusThree ); System .

out .

println ( g .

applyAsInt ( 7 )); // 13 } } JavaScript [ edit ] Further information: JavaScript With arrow functions: "use strict" ; const twice = f => x => f ( f ( x )); const plusThree = i => i + 3 ; const g = twice ( plusThree ); console .

log ( g ( 7 )); // 13 Or with classical syntax: "use strict" ; function twice ( f ) { return function ( x ) { return f ( f ( x )); }; } function plusThree ( i ) { return i + 3 ; } const g = twice ( plusThree ); console .

log ( g ( 7 )); // 13 Julia [ edit ] Further information: Julia (programming language) julia> function twice ( f ) function result ( x ) return f ( f ( x )) end return result end twice (generic function with 1 method) julia> plusthree ( i ) = i + 3 plusthree (generic function with 1 method) julia> g = twice ( plusthree ) (::var"#result#3"{typeof(plusthree)}) (generic function with 1 method) julia> g ( 7 ) 13 Kotlin [ edit ] Further information: Kotlin (programming language) fun twice ( f : ( Int ) -> Int ): ( Int ) -> Int { return { f ( f ( it )) } } fun plusThree ( i : Int ) = i + 3 fun main () { val g = twice ( :: plusThree ) println ( g ( 7 )) // 13 } Lua [ edit ] Further information: Lua (programming language) function twice ( f ) return function ( x ) return f ( f ( x )) end end function plusThree ( i ) return i + 3 end local g = twice ( plusThree ) print ( g ( 7 )) -- 13 MATLAB [ edit ] Further information: MATLAB function result = twice ( f ) result = @( x ) f ( f ( x )); end plusthree = @( i ) i + 3 ; g = twice ( plusthree ) disp ( g ( 7 )); % 13 OCaml [ edit ] Further information: OCaml let twice f x = f ( f x ) let plus_three = (+) 3 let () = let g = twice plus_three in print_int ( g 7 ); (* 13 *) print_newline () PHP [ edit ] Further information: PHP <?php declare ( strict_types = 1 ); function twice ( callable $f ) : Closure { return function ( int $x ) use ( $f ) : int { return $f ( $f ( $x )); }; } function plusThree ( int $i ) : int { return $i + 3 ; } $g = twice ( 'plusThree' ); echo $g ( 7 ), " \n " ; // 13 or with all functions in variables: <?php declare ( strict_types = 1 ); $twice = fn ( callable $f ) : Closure => fn ( int $x ) : int => $f ( $f ( $x )); $plusThree = fn ( int $i ) : int => $i + 3 ; $g = $twice ( $plusThree ); echo $g ( 7 ), " \n " ; // 13 Note that arrow functions implicitly capture any variables that come from the parent scope, [ 1 ] whereas anonymous functions require the use keyword to do the same.

Perl [ edit ] Further information: Perl use strict ; use warnings ; sub twice { my ( $f ) = @_ ; sub { $f -> ( $f -> ( @_ )); }; } sub plusThree { my ( $i ) = @_ ; $i + 3 ; } my $g = twice ( \& plusThree ); print $g -> ( 7 ), "\n" ; # 13 or with all functions in variables: use strict ; use warnings ; my $twice = sub { my ( $f ) = @_ ; sub { $f -> ( $f -> ( @_ )); }; }; my $plusThree = sub { my ( $i ) = @_ ; $i + 3 ; }; my $g = $twice -> ( $plusThree ); print $g -> ( 7 ), "\n" ; # 13 Python [ edit ] Further information: Python (programming language) >>> def twice ( f ): ...

def result ( x ): ...

return f ( f ( x )) ...

return result >>> plus_three = lambda i : i + 3 >>> g = twice ( plus_three ) >>> g ( 7 ) 13 Python decorator syntax is often used to replace a function with the result of passing that function through a higher-order function. E.g., the function g could be implemented equivalently: >>> @twice ...

def g ( i ): ...

return i + 3 >>> g ( 7 ) 13 R [ edit ] Further information: R (programming language) twice <- \ ( f ) \ ( x ) f ( f ( x )) plusThree <- function ( i ) i + 3 g <- twice ( plusThree ) > g ( 7 ) [ 1 ] 13 Raku [ edit ] Further information: Raku (programming language) sub twice ( Callable:D $f ) { return sub { $f ( $f ( $^x )) };
} sub plusThree ( Int:D $i ) { return $i + 3 ;
} my $g = twice ( &plusThree ); say $g ( 7 ); # 13 In Raku, all code objects are closures and therefore can reference inner "lexical" variables from an outer scope because the lexical variable is "closed" inside of the function. Raku also supports "pointy block" syntax for lambda expressions which can be assigned to a variable or invoked anonymously.

Ruby [ edit ] Further information: Ruby (programming language) def twice ( f ) -> ( x ) { f .

call ( f .

call ( x )) } end plus_three = -> ( i ) { i + 3 } g = twice ( plus_three ) puts g .

call ( 7 ) # 13 Rust [ edit ] Further information: Rust (programming language) fn twice ( f : impl Fn ( i32 ) -> i32 ) -> impl Fn ( i32 ) -> i32 { move | x | f ( f ( x )) } fn plus_three ( i : i32 ) -> i32 { i + 3 } fn main () { let g = twice ( plus_three ); println!

( "{}" , g ( 7 )) // 13 } Scala [ edit ] Further information: Scala (programming language) object Main { def twice ( f : Int => Int ): Int => Int = f compose f def plusThree ( i : Int ): Int = i + 3 def main ( args : Array [ String ]): Unit = { val g = twice ( plusThree ) print ( g ( 7 )) // 13 } } Scheme [ edit ] Further information: Scheme (programming language) ( define ( compose f g ) ( lambda ( x ) ( f ( g x )))) ( define ( twice f ) ( compose f f )) ( define ( plus-three i ) ( + i 3 )) ( define g ( twice plus-three )) ( display ( g 7 )) ; 13 ( display " \n " ) Swift [ edit ] Further information: Swift (programming language) func twice ( _ f : @ escaping ( Int ) -> Int ) -> ( Int ) -> Int { return { f ( f ( $0 )) } } let plusThree = { $0 + 3 } let g = twice ( plusThree ) print ( g ( 7 )) // 13 Tcl [ edit ] Further information: Tcl set twice {{ f x } {apply $f [apply $f $x ]}} set plusThree {{ i } {return [expr $i + 3 ]}} # result: 13 puts [apply $twice $plusThree 7 ] Tcl uses apply command to apply an anonymous function (since 8.6).

XACML [ edit ] Further information: XACML The XACML standard defines higher-order functions in the standard to apply a function to multiple values of attribute bags.

rule allowEntry { permit condition anyOfAny(function [ stringEqual ], citizenships , allowedCitizenships ) } The list of higher-order functions in XACML can be found here .

XQuery [ edit ] Further information: XQuery declare function local:twice ( $ f , $ x ) { $ f ( $ f ( $ x )) }; declare function local:plusthree ( $ i ) { $ i + 3 }; local:twice ( local:plusthree # 1 , 7 ) (: 13 :) Alternatives [ edit ] Function pointers [ edit ] Function pointers in languages such as C , C++ , Fortran , and Pascal allow programmers to pass around references to functions. The following C code computes an approximation of the integral of an arbitrary function: #include <stdio.h> double square ( double x ) { return x * x ; } double cube ( double x ) { return x * x * x ; } /* Compute the integral of f() within the interval [a,b] */ double integral ( double f ( double x ), double a , double b , int n ) { int i ; double sum = 0 ; double dt = ( b - a ) / n ; for ( i = 0 ; i < n ; ++ i ) { sum += f ( a + ( i + 0.5 ) * dt ); } return sum * dt ; } int main () { printf ( "%g \n " , integral ( square , 0 , 1 , 100 )); printf ( "%g \n " , integral ( cube , 0 , 1 , 100 )); return 0 ; } The qsort function from the C standard library uses a function pointer to emulate the behavior of a higher-order function.

Macros [ edit ] Macros can also be used to achieve some of the effects of higher-order functions. However, macros cannot easily avoid the problem of variable capture; they may also result in large amounts of duplicated code, which can be more difficult for a compiler to optimize. Macros are generally not strongly typed, although they may produce strongly typed code.

Dynamic code evaluation [ edit ] In other imperative programming languages, it is possible to achieve some of the same algorithmic results as are obtained via higher-order functions by dynamically executing code (sometimes called Eval or Execute operations) in the scope of evaluation. There can be significant drawbacks to this approach: The argument code to be executed is usually not statically typed ; these languages generally rely on dynamic typing to determine the well-formedness and safety of the code to be executed.

The argument is usually provided as a string, the value of which may not be known until run-time. This string must either be compiled during program execution (using just-in-time compilation ) or evaluated by interpretation , causing some added overhead at run-time, and usually generating less efficient code.

Objects [ edit ] In object-oriented programming languages that do not support higher-order functions, objects can be an effective substitute. An object's methods act in essence like functions, and a method may accept objects as parameters and produce objects as return values. Objects often carry added run-time overhead compared to pure functions, however, and added boilerplate code for defining and instantiating an object and its method(s). Languages that permit stack -based (versus heap -based) objects or structs can provide more flexibility with this method.

An example of using a simple stack based record in Free Pascal with a function that returns a function: program example ; type int = integer ; Txy = record x , y : int ; end ; Tf = function ( xy : Txy ) : int ; function f ( xy : Txy ) : int ; begin Result := xy .

y + xy .

x ; end ; function g ( func : Tf ) : Tf ; begin result := func ; end ; var a : Tf ; xy : Txy = ( x : 3 ; y : 7 ) ; begin a := g ( @ f ) ; // return a function to "a" writeln ( a ( xy )) ; // prints 10 end .

The function a() takes a Txy record as input and returns the integer value of the sum of the record's x and y fields (3 + 7).

Defunctionalization [ edit ] Defunctionalization can be used to implement higher-order functions in languages that lack first-class functions : // Defunctionalized function data structures template < typename T > struct Add { T value ; }; template < typename T > struct DivBy { T value ; }; template < typename F , typename G > struct Composition { F f ; G g ; }; // Defunctionalized function application implementations template < typename F , typename G , typename X > auto apply ( Composition < F , G > f , X arg ) { return apply ( f .

f , apply ( f .

g , arg )); } template < typename T , typename X > auto apply ( Add < T > f , X arg ) { return arg + f .

value ; } template < typename T , typename X > auto apply ( DivBy < T > f , X arg ) { return arg / f .

value ; } // Higher-order compose function template < typename F , typename G > Composition < F , G > compose ( F f , G g ) { return Composition < F , G > { f , g }; } int main ( int argc , const char * argv []) { auto f = compose ( DivBy < float > { 2.0f }, Add < int > { 5 }); apply ( f , 3 ); // 4.0f apply ( f , 9 ); // 7.0f return 0 ; } In this case, different types are used to trigger different functions via function overloading . The overloaded function in this example has the signature auto apply .

See also [ edit ] First-class function Combinatory logic Function-level programming Functional programming Kappa calculus - a formalism for functions which excludes higher-order functions Strategy pattern Higher order messages References [ edit ] ^ "PHP: Arrow Functions - Manual" .

www.php.net . Retrieved 2021-03-01 .

v t e Function History List of specific functions Types by domain and codomain X → 𝔹 𝔹 → X 𝔹ⁿ → X X → ℤ ℤ → X X → ℝ ℝ → X ℝⁿ → X X → ℂ ℂ → X ℂⁿ → X Classes/properties Constant Identity Linear Polynomial Rational Algebraic Analytic Smooth Continuous Measurable Injective Surjective Bijective Constructions Restriction Composition λ Inverse Generalizations Relation ( Binary relation ) Set-valued Multivalued Partial Implicit Space Higher-order Morphism Functor Category NewPP limit report
Parsed by mw‐web.codfw.main‐6cc77c66b8‐bq8cd
Cached time: 20250812020904
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.422 seconds
Real time usage: 0.559 seconds
Preprocessor visited node count: 2400/1000000
Revision size: 25014/2097152 bytes
Post‐expand include size: 39238/2097152 bytes
Template argument size: 1767/2097152 bytes
Highest expansion depth: 11/100
Expensive parser function count: 114/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 137201/5000000 bytes
Lua time usage: 0.216/10.000 seconds
Lua memory usage: 4806742/52428800 bytes
Number of Wikibase entities loaded: 0/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  381.586      1 -total
 20.11%   76.732      1 Template:Functions_navbox
 19.71%   75.216      1 Template:Navbox
 19.26%   73.477      1 Template:Short_description
 19.11%   72.925      1 Template:Reflist
 16.86%   64.348      1 Template:Cite_web
 15.83%   60.395     35 Template:Further_information
 13.26%   50.600      1 Template:More_sources
 12.75%   48.666      2 Template:Pagetype
 12.20%   46.535      1 Template:Ambox Saved in parser cache with key enwiki:pcache:244689:|#|:idhash:canonical and timestamp 20250812020904 and revision id 1281997674. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Higher-order_function&oldid=1281997674 " Categories : Functional programming Lambda calculus Higher-order functions Subroutines Hidden categories: Articles with short description Short description is different from Wikidata Articles needing additional references from November 2024 All articles needing additional references Articles with example C code Articles with example C++ code Articles with example D code Articles with example Haskell code Articles with example Java code Articles with example JavaScript code Articles with example Julia code Articles with example Lisp (programming language) code Articles with example MATLAB/Octave code Articles with example Pascal code Articles with example Perl code Articles with example PHP code Articles with example Python (programming language) code Articles with example R code Articles with example Scala code Articles with example Scheme (programming language) code Articles with example Tcl code Articles with example Swift code This page was last edited on 23 March 2025, at 18:43 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Higher-order function 20 languages Add topic

