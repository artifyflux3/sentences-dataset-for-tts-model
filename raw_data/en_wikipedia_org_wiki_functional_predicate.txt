Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Introducing new function symbols 2 Doing without functional predicates 3 See also Toggle the table of contents Functional predicate 3 languages Italiano Polski 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Symbol representing a mathematical concept This article does not cite any sources .

Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed .

Find sources: "Functional predicate" – news · newspapers · books · scholar · JSTOR ( December 2009 ) ( Learn how and when to remove this message ) In formal logic and related branches of mathematics , a functional predicate , [ citation needed ] or function symbol , is a logical symbol that may be applied to an object term to produce another object term.
Functional predicates are also sometimes called mappings , but that term has additional meanings in mathematics .
In a model , a function symbol will be modelled by a function .

Specifically, the symbol F in a formal language is a functional symbol if, given any symbol X representing an object in the language, F ( X ) is again a symbol representing an object in that language.
In typed logic , F is a functional symbol with domain type T and codomain type U if, given any symbol X representing an object of type T , F ( X ) is a symbol representing an object of type U .
One can similarly define function symbols of more than one variable, analogous to functions of more than one variable; a function symbol in zero variables is simply a constant symbol.

Now consider a model of the formal language, with the types T and U modelled by sets [ T ] and [ U ] and each symbol X of type T modelled by an element [ X ] in [ T ].
Then F can be modelled by the set [ F ] := { ( [ X ] , [ F ( X ) ] ) : [ X ] ∈ ∈ [ T ] } , {\displaystyle [F]:={\big \{}([X],[F(X)]):[X]\in [\mathbf {T} ]{\big \}},} which is simply a function with domain [ T ] and codomain [ U ].
It is a requirement of a consistent model that [ F ( X )] = [ F ( Y )] whenever [ X ] = [ Y ].

Introducing new function symbols [ edit ] In a treatment of predicate logic that allows one to introduce new predicate symbols, one will also want to be able to introduce new function symbols. Given the function symbols F and G , one can introduce a new function symbol F ∘ G , the composition of F and G , satisfying ( F ∘ G )( X ) = F ( G ( X )), for all X .
Of course, the right side of this equation doesn't make sense in typed logic unless the domain type of F matches the codomain type of G , so this is required for the composition to be defined.

One also gets certain function symbols automatically.
In untyped logic, there is an identity predicate id that satisfies id( X ) = X for all X .
In typed logic, given any type T , there is an identity predicate id T with domain and codomain type T ; it satisfies id T ( X ) = X for all X of type T .
Similarly, if T is a subtype of U , then there is an inclusion predicate of domain type T and codomain type U that satisfies the same equation; there are additional function symbols associated with other ways of constructing new types out of old ones.

Additionally, one can define functional predicates after proving an appropriate theorem .
(If you're working in a formal system that doesn't allow you to introduce new symbols after proving theorems, then you will have to use relation symbols to get around this, as in the next section.)
Specifically, if you can prove that for every X (or every X of a certain type), there exists a unique Y satisfying some condition P , then you can introduce a function symbol F to indicate this.
Note that P will itself be a relational predicate involving both X and Y .
So if there is such a predicate P and a theorem: For all X of type T , for some unique Y of type U , P ( X , Y ), then you can introduce a function symbol F of domain type T and codomain type U that satisfies: For all X of type T , for all Y of type U , P ( X , Y ) if and only if Y = F ( X ).

Doing without functional predicates [ edit ] Many treatments of predicate logic don't allow functional predicates, only relational predicates .
This is useful, for example, in the context of proving metalogical theorems (such as Gödel's incompleteness theorems ), where one doesn't want to allow the introduction of new functional symbols (nor any other new symbols, for that matter).
But there is a method of replacing functional symbols with relational symbols wherever the former may occur; furthermore, this is algorithmic and thus suitable for applying most metalogical theorems to the result.

Specifically, if F has domain type T and codomain type U , then it can be replaced with a predicate P of type ( T , U ).
Intuitively, P ( X , Y ) means F ( X ) = Y .
Then whenever F ( X ) would appear in a statement, you can replace it with a new symbol Y of type U and include another statement P ( X , Y ).
To be able to make the same deductions, you need an additional proposition: For all X of type T , for some unique Y of type U , P ( X , Y ).

(Of course, this is the same proposition that had to be proven as a theorem before introducing a new function symbol in the previous section.) Because the elimination of functional predicates is both convenient for some purposes and possible, many treatments of formal logic do not deal explicitly with function symbols but instead use only relation symbols; another way to think of this is that a functional predicate is a special kind of predicate, specifically one that satisfies the proposition above.
This may seem to be a problem if you wish to specify a proposition schema that applies only to functional predicates F ; how do you know ahead of time whether it satisfies that condition?
To get an equivalent formulation of the schema, first replace anything of the form F ( X ) with a new variable Y .
Then universally quantify over each Y immediately after the corresponding X is introduced (that is, after X is quantified over, or at the beginning of the statement if X is free), and guard the quantification with P ( X , Y ).
Finally, make the entire statement a material consequence of the uniqueness condition for a functional predicate above.

Let us take as an example the axiom schema of replacement in Zermelo–Fraenkel set theory .
(This example uses mathematical symbols .)
This schema states (in one form), for any functional predicate F in one variable: ∀ ∀ A , ∃ ∃ B , ∀ ∀ C , C ∈ ∈ A → → F ( C ) ∈ ∈ B .

{\displaystyle \forall A,\exists B,\forall C,C\in A\rightarrow F(C)\in B.} First, we must replace F ( C ) with some other variable D : ∀ ∀ A , ∃ ∃ B , ∀ ∀ C , C ∈ ∈ A → → D ∈ ∈ B .

{\displaystyle \forall A,\exists B,\forall C,C\in A\rightarrow D\in B.} Of course, this statement isn't correct; D must be quantified over just after C : ∀ ∀ A , ∃ ∃ B , ∀ ∀ C , ∀ ∀ D , C ∈ ∈ A → → D ∈ ∈ B .

{\displaystyle \forall A,\exists B,\forall C,\forall D,C\in A\rightarrow D\in B.} We still must introduce P to guard this quantification: ∀ ∀ A , ∃ ∃ B , ∀ ∀ C , ∀ ∀ D , P ( C , D ) → → ( C ∈ ∈ A → → D ∈ ∈ B ) .

{\displaystyle \forall A,\exists B,\forall C,\forall D,P(C,D)\rightarrow (C\in A\rightarrow D\in B).} This is almost correct, but it applies to too many predicates; what we actually want is: ( ∀ ∀ X , ∃ ∃ !

Y , P ( X , Y ) ) → → ( ∀ ∀ A , ∃ ∃ B , ∀ ∀ C , ∀ ∀ D , P ( C , D ) → → ( C ∈ ∈ A → → D ∈ ∈ B ) ) .

{\displaystyle (\forall X,\exists !Y,P(X,Y))\rightarrow (\forall A,\exists B,\forall C,\forall D,P(C,D)\rightarrow (C\in A\rightarrow D\in B)).} This version of the axiom schema of replacement is now suitable for use in a formal language that doesn't allow the introduction of new function symbols. Alternatively, one may interpret the original statement as a statement in such a formal language; it was merely an abbreviation for the statement produced at the end.

See also [ edit ] Function symbol (logic) Logical connective Logical constant v t e Mathematical logic General Axiom list Cardinality First-order logic Formal proof Formal semantics Foundations of mathematics Information theory Lemma Logical consequence Model Theorem Theory Type theory Theorems ( list ) and paradoxes Gödel's completeness and incompleteness theorems Tarski's undefinability Banach–Tarski paradox Cantor's theorem, paradox and diagonal argument Compactness Halting problem Lindström's Löwenheim–Skolem Russell's paradox Logics Traditional Classical logic Logical truth Tautology Proposition Inference Logical equivalence Consistency Equiconsistency Argument Soundness Validity Syllogism Square of opposition Venn diagram Propositional Boolean algebra Boolean functions Logical connectives Propositional calculus Propositional formula Truth tables Many-valued logic 3 finite ∞ Predicate First-order list Second-order Monadic Higher-order Fixed-point Free Quantifiers Predicate Monadic predicate calculus Set theory Set hereditary Class ( Ur- ) Element Ordinal number Extensionality Forcing Relation equivalence partition Set operations: intersection union complement Cartesian product power set identities Types of sets Countable Uncountable Empty Inhabited Singleton Finite Infinite Transitive Ultrafilter Recursive Fuzzy Universal Universe constructible Grothendieck Von Neumann Maps and cardinality Function / Map domain codomain image In / Sur / Bi -jection Schröder–Bernstein theorem Isomorphism Gödel numbering Enumeration Large cardinal inaccessible Aleph number Operation binary Set theories Zermelo–Fraenkel axiom of choice continuum hypothesis General Kripke–Platek Morse–Kelley Naive New Foundations Tarski–Grothendieck Von Neumann–Bernays–Gödel Ackermann Constructive Formal systems ( list ), language and syntax Alphabet Arity Automata Axiom schema Expression ground Extension by definition conservative Relation Formation rule Grammar Formula atomic closed ground open Free/bound variable Language Metalanguage Logical connective ¬ ∨ ∧ → ↔ = Predicate functional variable propositional variable Proof Quantifier ∃ !

∀ rank Sentence atomic spectrum Signature String Substitution Symbol function logical/constant non-logical variable Term Theory list Example axiomatic systems ( list ) of arithmetic : Peano second-order elementary function primitive recursive Robinson Skolem of the real numbers Tarski's axiomatization of Boolean algebras canonical minimal axioms of geometry : Euclidean : Elements Hilbert's Tarski's non-Euclidean Principia Mathematica Proof theory Formal proof Natural deduction Logical consequence Rule of inference Sequent calculus Theorem Systems axiomatic deductive Hilbert list Complete theory Independence ( from ZFC ) Proof of impossibility Ordinal analysis Reverse mathematics Self-verifying theories Model theory Interpretation function of models Model equivalence finite saturated spectrum submodel Non-standard model of arithmetic Diagram elementary Categorical theory Model complete theory Satisfiability Semantics of logic Strength Theories of truth semantic Tarski's Kripke's T-schema Transfer principle Truth predicate Truth value Type Ultraproduct Validity Computability theory Church encoding Church–Turing thesis Computably enumerable Computable function Computable set Decision problem decidable undecidable P NP P versus NP problem Kolmogorov complexity Lambda calculus Primitive recursive function Recursion Recursive set Turing machine Type theory Related Abstract logic Algebraic logic Automated theorem proving Category theory Concrete / Abstract category Category of sets History of logic History of mathematical logic timeline Logicism Mathematical object Philosophy of mathematics Supertask Mathematics portal NewPP limit report
Parsed by mw‐web.codfw.main‐6cc77c66b8‐zkljf
Cached time: 20250812040816
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1]
CPU time usage: 0.305 seconds
Real time usage: 0.428 seconds
Preprocessor visited node count: 815/1000000
Revision size: 8165/2097152 bytes
Post‐expand include size: 74648/2097152 bytes
Template argument size: 1606/2097152 bytes
Highest expansion depth: 15/100
Expensive parser function count: 3/500
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 10097/5000000 bytes
Lua time usage: 0.184/10.000 seconds
Lua memory usage: 3104706/52428800 bytes
Number of Wikibase entities loaded: 0/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  297.278      1 -total
 46.73%  138.904      4 Template:Navbox
 43.00%  127.821      1 Template:Mathematical_logic
 29.46%   87.573      1 Template:Short_description
 21.87%   65.007      1 Template:Unreferenced
 20.39%   60.611      1 Template:Ambox
 15.97%   47.486      2 Template:Pagetype
  9.11%   27.083      7 Template:Main_other
  8.11%   24.118      1 Template:SDcat
  5.50%   16.345      1 Template:Cn Saved in parser cache with key enwiki:pcache:174908:|#|:idhash:canonical and timestamp 20250812040816 and revision id 1300503143. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Functional_predicate&oldid=1300503143 " Category : Model theory Hidden categories: Articles with short description Short description is different from Wikidata Articles lacking sources from December 2009 All articles lacking sources All articles with unsourced statements Articles with unsourced statements from July 2025 This page was last edited on 14 July 2025, at 18:49 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Functional predicate 3 languages Add topic

