Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Definition Toggle Definition subsection 1.1 Example 1.2 Upper and lower bounds 2 Applications 3 Relationship with other edit distance metrics 4 Computation Toggle Computation subsection 4.1 Recursive 4.2 Iterative with full matrix 4.3 Iterative with two matrix rows 4.4 Automata 4.5 Approximation 4.6 Computational complexity 5 See also 6 References 7 External links Toggle the table of contents Levenshtein distance 37 languages Afrikaans Asturianu Azərbaycanca Català Čeština Deutsch Eesti Español Euskara فارسی Français Bahasa Indonesia Italiano עברית ქართული Latviešu Lietuvių Lombard Nederlands 日本語 Norsk bokmål Norsk nynorsk Plattdüütsch Polski Português Русский Simple English Slovenščina Ślůnski Српски / srpski Suomi Svenska ไทย Тоҷикӣ Українська Tiếng Việt 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikibooks Wikifunctions Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia Computer science metric for string similarity Levenshtein distance Edit distance matrix for two words using cost of substitution as 1 and cost of deletion or insertion as 0.5 Class measuring the difference between two sequences In information theory , linguistics , and computer science , the Levenshtein distance is a string metric for measuring the difference between two sequences. The Levenshtein distance between two words is the minimum number of single-character edits (insertions, deletions or substitutions) required to change one word into the other. It is named after Soviet mathematician Vladimir Levenshtein , who defined the metric in 1965.

[ 1 ] Levenshtein distance may also be referred to as edit distance , although that term may also denote a larger family of distance metrics.

[ 2 ] : 32 It is closely related to pairwise string alignments .

Definition [ edit ] The Levenshtein distance between two strings a , b {\displaystyle a,b} (of length | a | {\displaystyle |a|} and | b | {\displaystyle |b|} respectively) is given by lev ⁡ ⁡ ( a , b ) {\displaystyle \operatorname {lev} (a,b)} where lev ⁡ ⁡ ( a , b ) = { | a | if | b | = 0 , | b | if | a | = 0 , lev ⁡ ⁡ ( tail ⁡ ⁡ ( a ) , tail ⁡ ⁡ ( b ) ) if head ⁡ ⁡ ( a ) = head ⁡ ⁡ ( b ) , 1 + min { lev ⁡ ⁡ ( tail ⁡ ⁡ ( a ) , b ) lev ⁡ ⁡ ( a , tail ⁡ ⁡ ( b ) ) lev ⁡ ⁡ ( tail ⁡ ⁡ ( a ) , tail ⁡ ⁡ ( b ) ) otherwise {\displaystyle \operatorname {lev} (a,b)={\begin{cases}|a|&{\text{ if }}|b|=0,\\|b|&{\text{ if }}|a|=0,\\\operatorname {lev} {\big (}\operatorname {tail} (a),\operatorname {tail} (b){\big )}&{\text{ if }}\operatorname {head} (a)=\operatorname {head} (b),\\1+\min {\begin{cases}\operatorname {lev} {\big (}\operatorname {tail} (a),b{\big )}\\\operatorname {lev} {\big (}a,\operatorname {tail} (b){\big )}\\\operatorname {lev} {\big (}\operatorname {tail} (a),\operatorname {tail} (b){\big )}\\\end{cases}}&{\text{ otherwise}}\end{cases}}} where the tail {\displaystyle \operatorname {tail} } of some string x {\displaystyle x} is a string of all but the first character of x {\displaystyle x} (i.e.

tail ⁡ ⁡ ( x 0 x 1 … … x n ) = x 1 x 2 … … x n {\displaystyle \operatorname {tail} (x_{0}x_{1}\dots x_{n})=x_{1}x_{2}\dots x_{n}} ), and head ⁡ ⁡ ( x ) {\displaystyle \operatorname {head} (x)} is the first character of x {\displaystyle x} (i.e.

head ⁡ ⁡ ( x 0 x 1 … … x n ) = x 0 {\displaystyle \operatorname {head} (x_{0}x_{1}\dots x_{n})=x_{0}} ).  Either the notation x [ n ] {\displaystyle x[n]} or x n {\displaystyle x_{n}} is used to refer to the n {\displaystyle n} th character of the string x {\displaystyle x} , counting from 0 , thus head ⁡ ⁡ ( x ) = x 0 = x [ 0 ] {\displaystyle \operatorname {head} (x)=x_{0}=x[0]} .

The first element in the minimum corresponds to deletion (from a {\displaystyle a} to b {\displaystyle b} ), the second to insertion and the third to replacement.

This definition corresponds directly to the naive recursive implementation .

Example [ edit ] Edit distance matrix for two words using cost of substitution as 1 and cost of deletion or insertion as 0.5 For example, the Levenshtein distance between "kitten" and "sitting" is 3, since the following 3 edits change one into the other, and there is no way to do it with fewer than 3 edits: k itten → s itten (substitution of "s" for "k"), sitt e n → sitt i n (substitution of "i" for "e"), sittin → sittin g (insertion of "g" at the end).

A simple example of a deletion can be seen with "uninformed" and "uniformed" which have a distance of 1: uni n formed → uniformed (deletion of "n").

Upper and lower bounds [ edit ] The Levenshtein distance has several simple upper and lower bounds. These include: It is at least the absolute value of the difference of the sizes of the two strings.

It is at most the length of the longer string.

It is zero if and only if the strings are equal.

If the strings have the same size, the Hamming distance is an upper bound on the Levenshtein distance. The Hamming distance is the number of positions at which the corresponding symbols in the two strings are different.

The Levenshtein distance between two strings is no greater than the sum of their Levenshtein distances from a third string ( triangle inequality ).

An example where the Levenshtein distance between two strings of the same length is strictly less than the Hamming distance is given by the pair "flaw" and "lawn". Here the Levenshtein distance equals 2 (delete "f" from the front; insert "n" at the end). The Hamming distance is 4.

Applications [ edit ] In approximate string matching , the objective is to find matches for short strings in many longer texts, in situations where a small number of differences is to be expected. The short strings could come from a dictionary, for instance. Here, one of the strings is typically short, while the other is arbitrarily long. This has a wide range of applications, for instance, spell checkers , correction systems for optical character recognition , and software to assist natural-language translation based on translation memory .

The Levenshtein distance can also be computed between two longer strings, but the cost to compute it, which is roughly proportional to the product of the two string lengths, makes this impractical. Thus, when used to aid in fuzzy string searching in applications such as record linkage , the compared strings are usually short to help improve speed of comparisons.

[ citation needed ] In linguistics, the Levenshtein distance is used as a metric to quantify the linguistic distance , or how different two languages are from one another.

[ 3 ] It is related to mutual intelligibility : the higher the linguistic distance, the lower the mutual intelligibility, and the lower the linguistic distance, the higher the mutual intelligibility.

Relationship with other edit distance metrics [ edit ] Main article: Edit distance There are other popular measures of edit distance , which are calculated using a different set of allowable edit operations. For instance: the Damerau–Levenshtein distance allows the transposition of two adjacent characters alongside insertion, deletion, substitution; the longest common subsequence (LCS) distance allows only insertion and deletion, not substitution; the Hamming distance allows only substitution, hence, it only applies to strings of the same length.

the Jaro distance allows only transposition .

Edit distance is usually defined as a parameterizable metric calculated with a specific set of allowed edit operations, and each operation is assigned a cost (possibly infinite). This is further generalized by DNA sequence alignment algorithms such as the Smith–Waterman algorithm , which make an operation's cost depend on where it is applied.

Computation [ edit ] Recursive [ edit ] This is a straightforward, but inefficient, recursive Haskell implementation of a lDistance function that takes two strings, s and t , together with their lengths, and returns the Levenshtein distance between them: lDistance :: Eq a => [ a ] -> [ a ] -> Int lDistance [] t = length t -- If s is empty, the distance is the number of characters in t lDistance s [] = length s -- If t is empty, the distance is the number of characters in s lDistance ( a : s' ) ( b : t' ) | a == b = lDistance s' t' -- If the first characters are the same, they can be ignored | otherwise = 1 + minimum -- Otherwise try all three possible actions and select the best one [ lDistance ( a : s' ) t' -- Character is inserted (b inserted) , lDistance s' ( b : t' ) -- Character is deleted  (a deleted) , lDistance s' t' -- Character is replaced (a replaced with b) ] This implementation is very inefficient because it recomputes the Levenshtein distance of the same substrings many times.

A more efficient method would never repeat the same distance calculation. For example, the Levenshtein distance of all possible suffixes might be stored in an array M {\displaystyle M} , where M [ i ] [ j ] {\displaystyle M[i][j]} is the distance between the last i {\displaystyle i} characters of string s and the last j {\displaystyle j} characters of string t . The table is easy to construct one row at a time starting with row 0. When the entire table has been built, the desired distance is in the table in the last row and column, representing the distance between all of the characters in s and all the characters in t .

Iterative with full matrix [ edit ] Main article: Wagner–Fischer algorithm This section uses 1-based strings rather than 0-based strings. If m is a matrix, m [ i , j ] {\displaystyle m[i,j]} is the i th row and the j th column of the matrix, with the first row having index 0 and the first column having index 0.

Computing the Levenshtein distance is based on the observation that if we reserve a matrix to hold the Levenshtein distances between all prefixes of the first string and all prefixes of the second, then we can compute the values in the matrix in a dynamic programming fashion, and thus find the distance between the two full strings as the last value computed.

This algorithm, an example of bottom-up dynamic programming , is discussed, with variants, in the 1974 article The String-to-string correction problem by Robert A. Wagner and Michael J. Fischer.

[ 4 ] This is a straightforward pseudocode implementation for a function LevenshteinDistance that takes two strings, s of length m , and t of length n , and returns the Levenshtein distance between them: function LevenshteinDistance ( char s [ 1 ..

m ] , char t [ 1 ..

n ]) : // for all i and j, d[i,j] will hold the Levenshtein distance between // the first i characters of s and the first j characters of t declare int d [ 0 ..

m , 0 ..

n ] set each element in d to zero // source prefixes can be transformed into empty string by // dropping all characters for i from 1 to m : d [ i , 0 ] := i // target prefixes can be reached from empty source prefix // by inserting every character for j from 1 to n : d [ 0 , j ] := j for j from 1 to n : for i from 1 to m : if s [ i ] = t [ j ] : substitutionCost := 0 else : substitutionCost := 1 d [ i , j ] := minimum ( d [ i - 1 , j ] + 1 , // deletion d [ i , j - 1 ] + 1 , // insertion d [ i - 1 , j - 1 ] + substitutionCost ) // substitution return d [ m , n ] Two examples of the resulting matrix (hovering over a tagged number reveals the operation performed to get that number): k i t t e n 0 1 2 3 4 5 6 s 1 1 2 3 4 5 6 i 2 2 1 2 3 4 5 t 3 3 2 1 2 3 4 t 4 4 3 2 1 2 3 i 5 5 4 3 2 2 3 n 6 6 5 4 3 3 2 g 7 7 6 5 4 4 3 S a t u r d a y 0 1 2 3 4 5 6 7 8 S 1 0 1 2 3 4 5 6 7 u 2 1 1 2 2 3 4 5 6 n 3 2 2 2 3 3 4 5 6 d 4 3 3 3 3 4 3 4 5 a 5 4 3 4 4 4 4 3 4 y 6 5 4 4 5 5 5 4 3 The invariant maintained throughout the algorithm is that we can transform the initial segment s [ 1.

.

i ] into t [ 1.

.

j ] using a minimum of d [ i , j ] operations. At the end, the bottom-right element of the array contains the answer.

Iterative with two matrix rows [ edit ] It turns out that only two rows of the table –  the previous row and the current row being calculated –  are needed for the construction, if one does not want to reconstruct the edited input strings.

The Levenshtein distance may be calculated iteratively using the following algorithm: [ 5 ] function LevenshteinDistance ( char s [ 0 ..

m - 1 ] , char t [ 0 ..

n - 1 ]) : // create two work vectors of integer distances declare int v0 [ n + 1 ] declare int v1 [ n + 1 ] // initialize v0 (the previous row of distances) // this row is A[0][i]: edit distance from an empty s to t; // that distance is the number of characters to append to  s to make t.

for i from 0 to n : v0 [ i ] = i for i from 0 to m - 1 : // calculate v1 (current row distances) from the previous row v0 // first element of v1 is A[i + 1][0] //   edit distance is delete (i + 1) chars from s to match empty t v1 [ 0 ] = i + 1 // use formula to fill in the rest of the row for j from 0 to n - 1 : // calculating costs for A[i + 1][j + 1] deletionCost := v0 [ j + 1 ] + 1 insertionCost := v1 [ j ] + 1 if s [ i ] = t [ j ] : substitutionCost := v0 [ j ] else : substitutionCost := v0 [ j ] + 1 v1 [ j + 1 ] := minimum ( deletionCost , insertionCost , substitutionCost ) // copy v1 (current row) to v0 (previous row) for next iteration // since data in v1 is always invalidated, a swap without copy could be more efficient swap v0 with v1 // after the last swap, the results of v1 are now in v0 return v0 [ n ] Hirschberg's algorithm combines this method with divide and conquer . It can compute the optimal edit sequence, and not just the edit distance, in the same asymptotic time and space bounds.

[ 6 ] Automata [ edit ] Levenshtein automata efficiently determine whether a string has an edit distance lower than a given constant from a given string.

[ 7 ] Approximation [ edit ] The Levenshtein distance between two strings of length n can be approximated to within a factor ( log ⁡ ⁡ n ) O ( 1 / ε ε ) , {\displaystyle (\log n)^{O(1/\varepsilon )},} where ε > 0 is a free parameter to be tuned, in time O ( n 1 + ε ) .

[ 8 ] Computational complexity [ edit ] It has been shown that the Levenshtein distance of two strings of length n cannot be computed in time O ( n 2 − ε ) for any ε greater than zero unless the strong exponential time hypothesis is false.

[ 9 ] Another (unconditional) lower bound on the complexity of this problem is Ω Ω ( m n ) {\displaystyle \Omega (mn)} in a model where the only query on symbols of the strings is comparison of two symbols.

[ 10 ] See also [ edit ] agrep approximate string matching diff Dynamic time warping Euclidean distance Homology of sequences in genetics Hunt–Szymanski algorithm Jaccard index Jaro–Winkler distance Locality-sensitive hashing Lucene (an open source search engine that implements edit distance) Manhattan distance Metric space MinHash Numerical taxonomy Optimal matching algorithm Sørensen similarity index References [ edit ] ^ В. И. Левенштейн (1965).

Двоичные коды с исправлением выпадений, вставок и замещений символов [Binary codes capable of correcting deletions, insertions, and reversals].

Доклады Академии Наук СССР (in Russian).

163 (4): 845– 848.

Appeared in English as: Levenshtein, Vladimir I. (February 1966). "Binary codes capable of correcting deletions, insertions, and reversals".

Soviet Physics Doklady .

10 (8): 707– 710.

Bibcode : 1966SPhD...10..707L .

^ Navarro, Gonzalo (2001).

"A guided tour to approximate string matching" (PDF) .

ACM Computing Surveys .

33 (1): 31– 88.

CiteSeerX 10.1.1.452.6317 .

doi : 10.1145/375360.375365 .

S2CID 207551224 .

^ Jan D. ten Thije; Ludger Zeevaert (1 January 2007), Receptive multilingualism: linguistic analyses, language policies, and didactic concepts , John Benjamins Publishing Company, ISBN 978-90-272-1926-8 , Assuming that intelligibility is inversely related to linguistic distance ... the content words the percentage of cognates (related directly or via a synonym) ... lexical relatedness ... grammatical relatedness .

^ Wagner, Robert A.; Fischer, Michael J.

(1974), "The String-to-String Correction Problem", Journal of the ACM , 21 (1): 168– 173, doi : 10.1145/321796.321811 , S2CID 13381535 ^ Hjelmqvist, Sten (26 March 2012), Fast, memory efficient Levenshtein algorithm .

^ Hirschberg, D. S.

(1975).

"A linear space algorithm for computing maximal common subsequences" (PDF) .

Communications of the ACM (Submitted manuscript).

18 (6): 341– 343.

CiteSeerX 10.1.1.348.4774 .

doi : 10.1145/360825.360861 .

MR 0375829 .

S2CID 207694727 .

^ Schulz, Klaus U.; Mihov, Stoyan (2002). "Fast String Correction with Levenshtein-Automata".

International Journal of Document Analysis and Recognition .

5 (1): 67– 85.

CiteSeerX 10.1.1.16.652 .

doi : 10.1007/s10032-002-0082-8 .

S2CID 207046453 .

^ Andoni, Alexandr; Krauthgamer, Robert; Onak, Krzysztof (2010).

Polylogarithmic approximation for edit distance and the asymmetric query complexity . IEEE Symp. Foundations of Computer Science (FOCS).

arXiv : 1005.4033 .

Bibcode : 2010arXiv1005.4033A .

CiteSeerX 10.1.1.208.2079 .

^ Backurs, Arturs; Indyk, Piotr (2015).

Edit Distance Cannot Be Computed in Strongly Subquadratic Time (unless SETH is false) . Forty-Seventh Annual ACM on Symposium on Theory of Computing (STOC).

arXiv : 1412.0348 .

Bibcode : 2014arXiv1412.0348B .

^ Wong, C. K.; Chandra, Ashok K. (1976). "Bounds for the string editing problem".

Journal of the ACM .

23 (1): 13– 16.

External links [ edit ] The Wikibook Algorithm implementation has a page on the topic of: Levenshtein distance Black, Paul E., ed. (14 August 2008), "Levenshtein distance", Dictionary of Algorithms and Data Structures [online] , U.S. National Institute of Standards and Technology , retrieved 2 November 2016 Rosetta Code implementations of Levenshtein distance v t e Natural language processing General terms AI-complete Bag-of-words n -gram Bigram Trigram Computational linguistics Natural language understanding Stop words Text processing Text analysis Argument mining Collocation extraction Concept mining Coreference resolution Deep linguistic processing Distant reading Information extraction Named-entity recognition Ontology learning Parsing Semantic parsing Syntactic parsing Part-of-speech tagging Semantic analysis Semantic role labeling Semantic decomposition Semantic similarity Sentiment analysis Terminology extraction Text mining Textual entailment Truecasing Word-sense disambiguation Word-sense induction Text segmentation Compound-term processing Lemmatisation Lexical analysis Text chunking Stemming Sentence segmentation Word segmentation Automatic summarization Multi-document summarization Sentence extraction Text simplification Machine translation Computer-assisted Example-based Rule-based Statistical Transfer-based Neural Distributional semantics models BERT Document-term matrix Explicit semantic analysis fastText GloVe Language model ( large ) Latent semantic analysis Seq2seq Word embedding Word2vec Language resources , datasets and corpora Types and standards Corpus linguistics Lexical resource Linguistic Linked Open Data Machine-readable dictionary Parallel text PropBank Semantic network Simple Knowledge Organization System Speech corpus Text corpus Thesaurus (information retrieval) Treebank Universal Dependencies Data BabelNet Bank of English DBpedia FrameNet Google Ngram Viewer UBY WordNet Wikidata Automatic identification and data capture Speech recognition Speech segmentation Speech synthesis Natural language generation Optical character recognition Topic model Document classification Latent Dirichlet allocation Pachinko allocation Computer-assisted reviewing Automated essay scoring Concordancer Grammar checker Predictive text Pronunciation assessment Spell checker Natural language user interface Chatbot Interactive fiction Question answering Virtual assistant Voice user interface Related Formal semantics Hallucination Natural Language Toolkit spaCy v t e Strings String metric Approximate string matching Bitap algorithm Damerau–Levenshtein distance Edit distance Gestalt pattern matching Hamming distance Jaro–Winkler distance Lee distance Levenshtein automaton Levenshtein distance Wagner–Fischer algorithm String-searching algorithm Apostolico–Giancarlo algorithm Boyer–Moore string-search algorithm Boyer–Moore–Horspool algorithm Knuth–Morris–Pratt algorithm Rabin–Karp algorithm Raita algorithm Trigram search Two-way string-matching algorithm Zhu–Takaoka string matching algorithm Multiple string searching Aho–Corasick Commentz-Walter algorithm Regular expression Comparison of regular-expression engines Regular grammar Thompson's construction Nondeterministic finite automaton Sequence alignment BLAST Hirschberg's algorithm Needleman–Wunsch algorithm Smith–Waterman algorithm Data structure DAFSA Substring index Suffix array Suffix automaton Suffix tree Compressed suffix array LCP array FM-index Generalized suffix tree Rope Ternary search tree Trie Other Parsing Pattern matching Compressed pattern matching Longest common subsequence Longest common substring Sequential pattern mining Sorting String rewriting systems String operations NewPP limit report
Parsed by mw‐web.codfw.main‐7c956d68b4‐d69s7
Cached time: 20250817192632
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.555 seconds
Real time usage: 0.738 seconds
Preprocessor visited node count: 4442/1000000
Revision size: 21853/2097152 bytes
Post‐expand include size: 85734/2097152 bytes
Template argument size: 4970/2097152 bytes
Highest expansion depth: 16/100
Expensive parser function count: 11/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 89106/5000000 bytes
Lua time usage: 0.292/10.000 seconds
Lua memory usage: 7393836/52428800 bytes
Number of Wikibase entities loaded: 0/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  553.668      1 -total
 27.95%  154.771      1 Template:Reflist
 18.62%  103.108      6 Template:Cite_journal
 15.93%   88.224      4 Template:Navbox
 15.42%   85.374      1 Template:Natural_Language_Processing
 13.28%   73.516      1 Template:Short_description
  8.00%   44.274      2 Template:Pagetype
  7.18%   39.764     15 Template:Tooltip
  6.83%   37.818      1 Template:Citation_needed
  5.88%   32.537      1 Template:Fix Saved in parser cache with key enwiki:pcache:406418:|#|:idhash:canonical and timestamp 20250817192632 and revision id 1306438304. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Levenshtein_distance&oldid=1306438304 " Categories : String metrics Dynamic programming Quantitative linguistics Computational linguistics Hidden categories: CS1 uses Russian-language script (ru) CS1 Russian-language sources (ru) Articles with short description Short description matches Wikidata All articles with unsourced statements Articles with unsourced statements from January 2019 Use dmy dates from April 2017 Articles with example pseudocode This page was last edited on 17 August 2025, at 19:25 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Levenshtein distance 37 languages Add topic

