Jump to content Main menu Main menu move to sidebar hide Navigation Main page Contents Current events Random article About Wikipedia Contact us Contribute Help Learn to edit Community portal Recent changes Upload file Special pages Search Search Appearance Donate Create account Log in Personal tools Donate Create account Log in Pages for logged out editors learn more Contributions Talk CentralNotice Contents move to sidebar hide (Top) 1 Prime decomposition 2 Current state of the art Toggle Current state of the art subsection 2.1 Time complexity 3 Factoring algorithms Toggle Factoring algorithms subsection 3.1 Special-purpose 3.2 General-purpose 3.3 Other notable algorithms 4 Heuristic running time 5 Rigorous running time Toggle Rigorous running time subsection 5.1 Schnorr–Seysen–Lenstra algorithm 5.2 Expected running time 6 See also 7 Notes 8 References 9 External links Toggle the table of contents Integer factorization 35 languages Alemannisch العربية Català Čeština Dansk Deutsch Eesti Español Esperanto Euskara فارسی Français Galego ГӀалгӀай 한국어 Bahasa Indonesia Íslenska עברית Lëtzebuergesch Magyar Nederlands 日本語 Português Română Русский Simple English Slovenščina Српски / srpski Suomi Svenska ไทย Türkçe Українська Tiếng Việt 中文 Edit links Article Talk English Read Edit View history Tools Tools move to sidebar hide Actions Read Edit View history General What links here Related changes Upload file Permanent link Page information Cite this page Get shortened URL Download QR code Print/export Download as PDF Printable version In other projects Wikimedia Commons Wikidata item Appearance move to sidebar hide From Wikipedia, the free encyclopedia (Redirected from Prime factorization ) Decomposition of a number into a product "Prime decomposition" redirects here. For the prime decomposition theorem for 3-manifolds, see Prime decomposition of 3-manifolds .

Unsolved problem in computer science Can integer factorization be solved in polynomial time on a classical computer?

More unsolved problems in computer science In mathematics , integer factorization is the decomposition of a positive integer into a product of integers. Every positive integer greater than 1 is either the product of two or more integer factors greater than 1, in which case it is a composite number , or it is not, in which case it is a prime number . For example, 15 is a composite number because 15 = 3 · 5 , but 7 is a prime number because it cannot be decomposed in this way. If one of the factors is composite, it can in turn be written as a product of smaller factors, for example 60 = 3 · 20 = 3 · (5 · 4) . Continuing this process until every factor is prime is called prime factorization ; the result is always unique up to the order of the factors by the prime factorization theorem .

To factorize a small integer n using mental or pen-and-paper arithmetic, the simplest method is trial division : checking if the number is divisible by prime numbers 2 , 3 , 5 , and so on, up to the square root of n . For larger numbers, especially when using a computer, various more sophisticated factorization algorithms are more efficient. A prime factorization algorithm typically involves testing whether each factor is prime each time a factor is found.

When the numbers are sufficiently large, no efficient non- quantum integer factorization algorithm is known. However, it has not been proven that such an algorithm does not exist. The presumed difficulty of this problem is important for the algorithms used in cryptography such as RSA public-key encryption and the RSA digital signature .

[ 1 ] Many areas of mathematics and computer science have been brought to bear on this problem, including elliptic curves , algebraic number theory , and quantum computing.

Not all numbers of a given length are equally hard to factor. The hardest instances of these problems (for currently known techniques) are semiprimes , the product of two prime numbers. When they are both large, for instance more than two thousand bits long, randomly chosen, and about the same size (but not too close, for example, to avoid efficient factorization by Fermat's factorization method ), even the fastest prime factorization algorithms on the fastest classical computers can take enough time to make the search impractical; that is, as the number of digits of the integer being factored increases, the number of operations required to perform the factorization on any classical computer increases drastically.

Many cryptographic protocols are based on the presumed difficulty of factoring large composite integers or a related problem –for example, the RSA problem . An algorithm that efficiently factors an arbitrary integer would render RSA -based public-key cryptography insecure.

Prime decomposition [ edit ] Prime decomposition of n = 864 as 2 5 × 3 3 By the fundamental theorem of arithmetic , every positive integer has a unique prime factorization . (By convention, 1 is the empty product .) Testing whether the integer is prime can be done in polynomial time , for example, by the AKS primality test . If composite, however, the polynomial time tests give no insight into how to obtain the factors.

Given a general algorithm for integer factorization, any integer can be factored into its constituent prime factors by repeated application of this algorithm. The situation is more complicated with special-purpose factorization algorithms, whose benefits may not be realized as well or even at all with the factors produced during decomposition. For example, if n = 171 × p × q where p < q are very large primes, trial division will quickly produce the factors 3 and 19 but will take p divisions to find the next factor. As a contrasting example, if n is the product of the primes 13729 , 1372933 , and 18848997161 , where 13729 × 1372933 = 18848997157 , Fermat's factorization method will begin with ⌈ √ n ⌉ = 18848997159 which immediately yields b = √ a 2 − n = √ 4 = 2 and hence the factors a − b = 18848997157 and a + b = 18848997161 . While these are easily recognized as composite and prime respectively, Fermat's method will take much longer to factor the composite number because the starting value of ⌈ √ 18848997157 ⌉ = 137292 for a is a factor of 10 from 1372933 .

Current state of the art [ edit ] See also: Integer factorization records Among the b -bit numbers, the most difficult to factor in practice using existing algorithms are those semiprimes whose factors are of similar size. For this reason, these are the integers used in cryptographic applications.

In 2019, a 240-digit (795-bit) number ( RSA-240 ) was factored by a team of researchers including Paul Zimmermann , utilizing approximately 900 core-years of computing power.

[ 2 ] These researchers estimated that a 1024-bit RSA modulus would take about 500 times as long.

[ 3 ] The largest such semiprime yet factored was RSA-250 , an 829-bit number with 250 decimal digits, in February 2020. The total computation time was roughly 2700 core-years of computing using Intel Xeon Gold 6130 at 2.1 GHz. Like all recent factorization records, this factorization was completed with a highly optimized implementation of the general number field sieve run on hundreds of machines.

Time complexity [ edit ] No algorithm has been published that can factor all integers in polynomial time , that is, that can factor a b -bit number n in time O ( b k ) for some constant k . Neither the existence nor non-existence of such algorithms has been proved, but it is generally suspected that they do not exist.

[ 4 ] [ 5 ] There are published algorithms that are faster than O((1 + ε ) b ) for all positive ε , that is, sub-exponential .  As of 2022 [update] , the algorithm with best theoretical asymptotic running time is the general number field sieve (GNFS), first published in 1993, [ 6 ] running on a b -bit number n in time: exp ⁡ ⁡ ( ( ( 8 3 ) 2 3 + o ( 1 ) ) ( log ⁡ ⁡ n ) 1 3 ( log ⁡ ⁡ log ⁡ ⁡ n ) 2 3 ) .

{\displaystyle \exp \left(\left(\left({\tfrac {8}{3}}\right)^{\frac {2}{3}}+o(1)\right)\left(\log n\right)^{\frac {1}{3}}\left(\log \log n\right)^{\frac {2}{3}}\right).} For current computers, GNFS is the best published algorithm for large n (more than about 400 bits). For a quantum computer , however, Peter Shor discovered an algorithm in 1994 that solves it in polynomial time.

Shor's algorithm takes only O( b 3 ) time and O( b ) space on b -bit number inputs. In 2001, Shor's algorithm was implemented for the first time, by using NMR techniques on molecules that provide seven qubits.

[ 7 ] In order to talk about complexity classes such as P, NP, and co-NP, the problem has to be stated as a decision problem .

Decision problem (Integer factorization) — For every natural numbers n {\displaystyle n} and k {\displaystyle k} , does n have a factor smaller than k besides 1?

It is known to be in both NP and co-NP , meaning that both "yes" and "no" answers can be verified in polynomial time. An answer of "yes" can be certified by exhibiting a factorization n = d ( ⁠ n / d ⁠ ) with d ≤ k . An answer of "no" can be certified by exhibiting the factorization of n into distinct primes, all larger than k ; one can verify their primality using the AKS primality test , and then multiply them to obtain n . The fundamental theorem of arithmetic guarantees that there is only one possible string of increasing primes that will be accepted, which shows that the problem is in both UP and co-UP.

[ 8 ] It is known to be in BQP because of Shor's algorithm.

The problem is suspected to be outside all three of the complexity classes P, NP-complete, [ 9 ] and co-NP-complete .
It is therefore a candidate for the NP-intermediate complexity class.

In contrast, the decision problem "Is n a composite number?" (or equivalently: "Is n a prime number?") appears to be much easier than the problem of specifying factors of n . The composite/prime problem can be solved in polynomial time (in the number b of digits of n ) with the AKS primality test . In addition, there are several probabilistic algorithms that can test primality very quickly in practice if one is willing to accept a vanishingly small possibility of error. The ease of primality testing is a crucial part of the RSA algorithm, as it is necessary to find large prime numbers to start with.

Factoring algorithms [ edit ] Special-purpose [ edit ] A special-purpose factoring algorithm's running time depends on the properties of the number to be factored or on one of its unknown factors: size, special form, etc. The parameters which determine the running time vary among algorithms.

An important subclass of special-purpose factoring algorithms is the Category 1 or First Category algorithms, whose running time depends on the size of smallest prime factor. Given an integer of unknown form, these methods are usually applied before general-purpose methods to remove small factors.

[ 10 ] For example, naive trial division is a Category 1 algorithm.

Trial division Wheel factorization Pollard's rho algorithm , which has two common flavors to identify group cycles : one by Floyd and one by Brent.

Algebraic-group factorization algorithms , among which are Pollard's p − 1 algorithm , Williams' p + 1 algorithm , and Lenstra elliptic curve factorization Fermat's factorization method Euler's factorization method Special number field sieve Difference of two squares General-purpose [ edit ] A general-purpose factoring algorithm, also known as a Category 2 , Second Category , or Kraitchik family algorithm, [ 10 ] has a running time which depends solely on the size of the integer to be factored. This is the type of algorithm used to factor RSA numbers . Most general-purpose factoring algorithms are based on the congruence of squares method.

Dixon's factorization method Continued fraction factorization (CFRAC) Quadratic sieve Rational sieve General number field sieve Shanks's square forms factorization (SQUFOF) Other notable algorithms [ edit ] Shor's algorithm , for quantum computers Heuristic running time [ edit ] In number theory, there are many integer factoring algorithms that heuristically have expected running time L n [ 1 2 , 1 + o ( 1 ) ] = e ( 1 + o ( 1 ) ) ( log ⁡ ⁡ n ) ( log ⁡ ⁡ log ⁡ ⁡ n ) {\displaystyle L_{n}\left[{\tfrac {1}{2}},1+o(1)\right]=e^{(1+o(1)){\sqrt {(\log n)(\log \log n)}}}} in little-o and L-notation .
Some examples of those algorithms are the elliptic curve method and the quadratic sieve .
Another such algorithm is the class group relations method proposed by Schnorr, [ 11 ] Seysen, [ 12 ] and Lenstra, [ 13 ] which they proved only assuming the unproved generalized Riemann hypothesis .

Rigorous running time [ edit ] The Schnorr–Seysen–Lenstra probabilistic algorithm has been rigorously proven by Lenstra and Pomerance [ 14 ] to have expected running time L n [ ⁠ 1 / 2 ⁠ , 1+ o (1)] by replacing the GRH assumption with the use of multipliers.
The algorithm uses the class group of positive binary quadratic forms of discriminant Δ denoted by G Δ .

G Δ is the set of triples of integers ( a , b , c ) in which those integers are relative prime.

Schnorr–Seysen–Lenstra algorithm [ edit ] Given an integer n that will be factored, where n is an odd positive integer greater than a certain constant. In this factoring algorithm the discriminant Δ is chosen as a multiple of n , Δ = − dn , where d is some positive multiplier. The algorithm expects that for one d there exist enough smooth forms in G Δ . Lenstra and Pomerance show that the choice of d can be restricted to a small set to guarantee the smoothness result.

Denote by P Δ the set of all primes q with Kronecker symbol ( ⁠ Δ / q ⁠ ) = 1 . By constructing a set of generators of G Δ and prime forms f q of G Δ with q in P Δ a sequence of relations between the set of generators and f q are produced.
The size of q can be bounded by c 0 (log| Δ |) 2 for some constant c 0 .

The relation that will be used is a relation between the product of powers that is equal to the neutral element of G Δ . These relations will be used to construct a so-called ambiguous form of G Δ , which is an element of G Δ of order dividing 2. By calculating the corresponding factorization of Δ and by taking a gcd , this ambiguous form provides the complete prime factorization of n . This algorithm has these main steps: Let n be the number to be factored.

Let Δ be a negative integer with Δ = − dn , where d is a multiplier and Δ is the negative discriminant of some quadratic form.

Take the t first primes p 1 = 2, p 2 = 3, p 3 = 5, ..., p t , for some t ∈ N .

Let f q be a random prime form of G Δ with ( ⁠ Δ / q ⁠ ) = 1 .

Find a generating set X of G Δ .

Collect a sequence of relations between set X and { f q : q ∈ P Δ } satisfying: ( ∏ ∏ x ∈ ∈ X x r ( x ) ) .

( ∏ ∏ q ∈ ∈ P Δ Δ f q t ( q ) ) = 1.

{\displaystyle \left(\prod _{x\in X_{}}x^{r(x)}\right).\left(\prod _{q\in P_{\Delta }}f_{q}^{t(q)}\right)=1.} Construct an ambiguous form ( a , b , c ) that is an element f ∈ G Δ of order dividing 2 to obtain a coprime factorization of the largest odd divisor of Δ in which Δ = −4 ac or Δ = a ( a − 4 c ) or Δ = ( b − 2 a )( b + 2 a ) .

If the ambiguous form provides a factorization of n then stop, otherwise find another ambiguous form until the factorization of n is found. In order to prevent useless ambiguous forms from generating, build up the 2-Sylow group Sll 2 (Δ) of G (Δ) .

To obtain an algorithm for factoring any positive integer, it is necessary to add a few steps to this algorithm such as trial division, and the Jacobi sum test .

Expected running time [ edit ] The algorithm as stated is a probabilistic algorithm as it makes random choices. Its expected running time is at most L n [ ⁠ 1 / 2 ⁠ , 1+ o (1)] .

[ 14 ] See also [ edit ] Aurifeuillean factorization Bach's algorithm for generating random numbers with their factorizations Canonical representation of a positive integer Factorization Multiplicative partition p -adic valuation Integer partition – a way of writing a number as a sum of positive integers.

Notes [ edit ] ^ Lenstra, Arjen K. (2011), "Integer Factoring", in van Tilborg, Henk C. A.; Jajodia, Sushil (eds.), Encyclopedia of Cryptography and Security , Boston: Springer, pp.

611– 618, doi : 10.1007/978-1-4419-5906-5_455 , ISBN 978-1-4419-5905-8 ^ "[Cado-nfs-discuss] 795-bit factoring and discrete logarithms" . Archived from the original on 2019-12-02.

^ Kleinjung, Thorsten; Aoki, Kazumaro; Franke, Jens; Lenstra, Arjen K.; Thomé, Emmanuel; Bos, Joppe W.; Gaudry, Pierrick; Kruppa, Alexander; Montgomery, Peter L.; Osvik, Dag Arne; te Riele, Herman J. J.; Timofeev, Andrey; Zimmermann, Paul (2010).

"Factorization of a 768-Bit RSA Modulus" (PDF) . In Rabin, Tal (ed.).

Advances in Cryptology - CRYPTO 2010, 30th Annual Cryptology Conference, Santa Barbara, CA, USA, August 15-19, 2010. Proceedings . Lecture Notes in Computer Science. Vol. 6223. Springer. pp.

333– 350.

doi : 10.1007/978-3-642-14623-7_18 .

ISBN 978-3-642-14622-0 .

^ Krantz, Steven G.

(2011), The Proof is in the Pudding: The Changing Nature of Mathematical Proof , New York: Springer, p. 203, doi : 10.1007/978-0-387-48744-1 , ISBN 978-0-387-48908-7 , MR 2789493 ^ Arora, Sanjeev ; Barak, Boaz (2009), Computational complexity , Cambridge: Cambridge University Press, p. 230, doi : 10.1017/CBO9780511804090 , ISBN 978-0-521-42426-4 , MR 2500087 , S2CID 215746906 ^ Buhler, J. P.; Lenstra, H. W. Jr.; Pomerance, Carl (1993). "Factoring integers with the number field sieve".

The development of the number field sieve . Lecture Notes in Mathematics. Vol. 1554. Springer. pp.

50– 94.

doi : 10.1007/BFb0091539 .

hdl : 1887/2149 .

ISBN 978-3-540-57013-4 . Retrieved 12 March 2021 .

^ Vandersypen, Lieven M. K.; et al. (2001). "Experimental realization of Shor's quantum factoring algorithm using nuclear magnetic resonance".

Nature .

414 (6866): 883– 887.

arXiv : quant-ph/0112176 .

Bibcode : 2001Natur.414..883V .

doi : 10.1038/414883a .

PMID 11780055 .

S2CID 4400832 .

^ Lance Fortnow (2002-09-13).

"Computational Complexity Blog: Complexity Class of the Week: Factoring" .

^ Goldreich, Oded ; Wigderson, Avi (2008), "IV.20 Computational Complexity", in Gowers, Timothy ; Barrow-Green, June ; Leader, Imre (eds.), The Princeton Companion to Mathematics , Princeton, New Jersey: Princeton University Press, pp.

575– 604, ISBN 978-0-691-11880-2 , MR 2467561 . See in particular p. 583 .

^ a b David Bressoud and Stan Wagon (2000).

A Course in Computational Number Theory . Key College Publishing/Springer. pp.

168–69 .

ISBN 978-1-930190-10-8 .

^ Schnorr, Claus P. (1982).

"Refined analysis and improvements on some factoring algorithms" .

Journal of Algorithms .

3 (2): 101– 127.

doi : 10.1016/0196-6774(82)90012-8 .

MR 0657269 . Archived from the original on September 24, 2017.

^ Seysen, Martin (1987).

"A probabilistic factorization algorithm with quadratic forms of negative discriminant" .

Mathematics of Computation .

48 (178): 757– 780.

doi : 10.1090/S0025-5718-1987-0878705-X .

MR 0878705 .

^ Lenstra, Arjen K (1988).

"Fast and rigorous factorization under the generalized Riemann hypothesis" (PDF) .

Indagationes Mathematicae .

50 (4): 443– 454.

doi : 10.1016/S1385-7258(88)80022-2 .

^ a b Lenstra, H. W.; Pomerance, Carl (July 1992).

"A Rigorous Time Bound for Factoring Integers" (PDF) .

Journal of the American Mathematical Society .

5 (3): 483– 516.

doi : 10.1090/S0894-0347-1992-1137100-0 .

MR 1137100 .

References [ edit ] Richard Crandall and Carl Pomerance (2001).

Prime Numbers: A Computational Perspective . Springer.

ISBN 0-387-94777-9 .

Chapter 5: Exponential Factoring Algorithms, pp. 191–226. Chapter 6: Subexponential Factoring Algorithms, pp. 227–284. Section 7.4: Elliptic curve method, pp. 301–313.

Donald Knuth .

The Art of Computer Programming , Volume 2: Seminumerical Algorithms , Third Edition. Addison-Wesley, 1997.

ISBN 0-201-89684-2 . Section 4.5.4: Factoring into Primes, pp. 379–417.

Samuel S. Wagstaff Jr.

(2013).

The Joy of Factoring . Providence, RI: American Mathematical Society.

ISBN 978-1-4704-1048-3 .

.

Warren, Henry S. Jr. (2013).

Hacker's Delight (2 ed.).

Addison Wesley - Pearson Education, Inc.

ISBN 978-0-321-84268-8 .

External links [ edit ] msieve – SIQS and NFS – has helped complete some of the largest public factorizations known Richard P. Brent, "Recent Progress and Prospects for Integer Factorisation Algorithms", Computing and Combinatorics" , 2000, pp. 3–22.

download Manindra Agrawal , Neeraj Kayal, Nitin Saxena, "PRIMES is in P." Annals of Mathematics 160(2): 781–793 (2004).

August 2005 version PDF Eric W. Weisstein, “RSA-640 Factored” MathWorld Headline News , November 8, 2005 Dario Alpern's Integer factorization calculator – A web app for factoring large integers v t e Computational hardness assumptions Number theoretic Integer factorization Phi-hiding RSA problem Strong RSA Quadratic residuosity Decisional composite residuosity Higher residuosity Group theoretic Discrete logarithm Diffie-Hellman Decisional Diffie–Hellman Computational Diffie–Hellman Pairings External Diffie–Hellman Sub-group hiding Decision linear Lattices Shortest vector problem ( gap ) Closest vector problem ( gap ) Learning with errors Ring learning with errors Short integer solution Non-cryptographic Exponential time hypothesis Unique games conjecture Planted clique conjecture v t e Number-theoretic algorithms Primality tests AKS APR Baillie–PSW Elliptic curve Pocklington Fermat Lucas Lucas–Lehmer Lucas–Lehmer–Riesel Proth's theorem Pépin's Quadratic Frobenius Solovay–Strassen Miller–Rabin Prime-generating Sieve of Atkin Sieve of Eratosthenes Sieve of Pritchard Sieve of Sundaram Wheel factorization Integer factorization Continued fraction (CFRAC) Dixon's Lenstra elliptic curve (ECM) Euler's Pollard's rho p − 1 p + 1 Quadratic sieve (QS) General number field sieve (GNFS) Special number field sieve (SNFS) Rational sieve Fermat's Shanks's square forms Trial division Shor's Multiplication Ancient Egyptian Long Karatsuba Toom–Cook Schönhage–Strassen Fürer's Euclidean division Binary Chunking Fourier Goldschmidt Newton-Raphson Long Short SRT Discrete logarithm Baby-step giant-step Pollard rho Pollard kangaroo Pohlig–Hellman Index calculus Function field sieve Greatest common divisor Binary Euclidean Extended Euclidean Lehmer's Modular square root Cipolla Pocklington's Tonelli–Shanks Berlekamp Other algorithms Chakravala Cornacchia Exponentiation by squaring Integer square root Integer relation ( LLL ; KZ ) Modular exponentiation Montgomery reduction Schoof Trachtenberg system Italics indicate that algorithm is for numbers of special forms v t e Divisibility-based sets of integers Overview Integer factorization Divisor Unitary divisor Divisor function Prime factor Fundamental theorem of arithmetic Factorization forms Prime Composite Semiprime Pronic Sphenic Square-free Powerful Perfect power Achilles Smooth Regular Rough Unusual Constrained divisor sums Perfect Almost perfect Quasiperfect Multiply perfect Hemiperfect Hyperperfect Superperfect Unitary perfect Semiperfect Practical Descartes Erdős–Nicolas With many divisors Abundant Primitive abundant Highly abundant Superabundant Colossally abundant Highly composite Superior highly composite Weird Aliquot sequence -related Untouchable Amicable ( Triple ) Sociable Betrothed Base -dependent Equidigital Extravagant Frugal Harshad Polydivisible Smith Other sets Arithmetic Deficient Friendly Solitary Sublime Harmonic divisor Refactorable Superperfect Authority control databases : National Germany NewPP limit report
Parsed by mw‐web.codfw.main‐6cc77c66b8‐7z6c9
Cached time: 20250811235046
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.495 seconds
Real time usage: 0.628 seconds
Preprocessor visited node count: 6482/1000000
Revision size: 25988/2097152 bytes
Post‐expand include size: 118124/2097152 bytes
Template argument size: 11469/2097152 bytes
Highest expansion depth: 15/100
Expensive parser function count: 5/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 100195/5000000 bytes
Lua time usage: 0.265/10.000 seconds
Lua memory usage: 5922279/52428800 bytes
Number of Wikibase entities loaded: 1/500 Transclusion expansion time report (%,ms,calls,template)
100.00%  493.853      1 -total
 33.40%  164.951      1 Template:Reflist
 19.70%   97.302     91 Template:Math
 18.01%   88.923      4 Template:Citation
 13.07%   64.571      3 Template:Navbox
 12.11%   59.796      1 Template:Computational_hardness_assumptions
 11.64%   57.480      1 Template:Short_description
  6.68%   32.976      2 Template:Pagetype
  5.36%   26.467     95 Template:Main_other
  5.29%   26.148      5 Template:Cite_journal Saved in parser cache with key enwiki:pcache:15491:|#|:idhash:canonical and timestamp 20250811235046 and revision id 1305063067. Rendering was triggered because: page-view Retrieved from " https://en.wikipedia.org/w/index.php?title=Integer_factorization&oldid=1305063067 " Categories : Integer factorization algorithms Computational hardness assumptions Unsolved problems in computer science Factorization Hidden categories: Articles with short description Short description matches Wikidata Articles containing potentially dated statements from 2022 All articles containing potentially dated statements This page was last edited on 9 August 2025, at 20:54 (UTC) .

Text is available under the Creative Commons Attribution-ShareAlike 4.0 License ;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy . Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.

, a non-profit organization.

Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Search Search Toggle the table of contents Integer factorization 35 languages Add topic

